"use strict";(self.webpackChunkrust_book_abridged=self.webpackChunkrust_book_abridged||[]).push([[71],{3905:(e,t,n)=>{n.d(t,{Zo:()=>s,kt:()=>c});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var p=a.createContext({}),d=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},s=function(e){var t=d(e.components);return a.createElement(p.Provider,{value:t},e.children)},m="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,p=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),m=d(n),u=i,c=m["".concat(p,".").concat(u)]||m[u]||h[u]||r;return n?a.createElement(c,o(o({ref:t},s),{},{components:n})):a.createElement(c,o({ref:t},s))}));function c(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=u;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l[m]="string"==typeof e?e:i,o[1]=l;for(var d=2;d<r;d++)o[d]=n[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},9063:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var a=n(7462),i=(n(7294),n(3905));const r={},o="Appendix C: Derivable Traits",l={unversionedId:"zz-appendix/appendix-03-derivable-traits",id:"zz-appendix/appendix-03-derivable-traits",title:"Appendix C: Derivable Traits",description:'This appendix was copied directly from "The Rust Programming Language".',source:"@site/docs/zz-appendix/appendix-03-derivable-traits.md",sourceDirName:"zz-appendix",slug:"/zz-appendix/appendix-03-derivable-traits",permalink:"/rust-book-abridged/zz-appendix/appendix-03-derivable-traits",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/zz-appendix/appendix-03-derivable-traits.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Appendix B: Operators and Symbols",permalink:"/rust-book-abridged/zz-appendix/appendix-02-operators"},next:{title:"Appendix D - Useful Development Tools",permalink:"/rust-book-abridged/zz-appendix/appendix-04-useful-development-tools"}},p={},d=[{value:"<code>Debug</code> for Programmer Output",id:"debug-for-programmer-output",level:2},{value:"<code>PartialEq</code> and <code>Eq</code> for Equality Comparisons",id:"partialeq-and-eq-for-equality-comparisons",level:2},{value:"<code>PartialOrd</code> and <code>Ord</code> for Ordering Comparisons",id:"partialord-and-ord-for-ordering-comparisons",level:2},{value:"<code>Clone</code> and <code>Copy</code> for Duplicating Values",id:"clone-and-copy-for-duplicating-values",level:2},{value:"<code>Hash</code> for Mapping a Value to a Value of Fixed Size",id:"hash-for-mapping-a-value-to-a-value-of-fixed-size",level:2},{value:"<code>Default</code> for Default Values",id:"default-for-default-values",level:2}],s={toc:d},m="wrapper";function h(e){let{components:t,...n}=e;return(0,i.kt)(m,(0,a.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"appendix-c-derivable-traits"},"Appendix C: Derivable Traits"),(0,i.kt)("p",null,"This appendix was copied directly from ",(0,i.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/stable/book/appendix-03-derivable-traits.html"},'"The Rust Programming Language"'),"."),(0,i.kt)("p",null,"In various places in the book, we've discussed the ",(0,i.kt)("inlineCode",{parentName:"p"},"derive")," attribute, which\nyou can apply to a struct or enum definition. The ",(0,i.kt)("inlineCode",{parentName:"p"},"derive")," attribute generates\ncode that will implement a trait with its own default implementation on the\ntype you've annotated with the ",(0,i.kt)("inlineCode",{parentName:"p"},"derive")," syntax."),(0,i.kt)("p",null,"In this appendix, we provide a reference of all the traits in the standard\nlibrary that you can use with ",(0,i.kt)("inlineCode",{parentName:"p"},"derive"),". Each section covers:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"What operators and methods deriving this trait will enable"),(0,i.kt)("li",{parentName:"ul"},"What the implementation of the trait provided by ",(0,i.kt)("inlineCode",{parentName:"li"},"derive")," does"),(0,i.kt)("li",{parentName:"ul"},"What implementing the trait signifies about the type"),(0,i.kt)("li",{parentName:"ul"},"The conditions in which you're allowed or not allowed to implement the trait"),(0,i.kt)("li",{parentName:"ul"},"Examples of operations that require the trait")),(0,i.kt)("p",null,"If you want different behavior from that provided by the ",(0,i.kt)("inlineCode",{parentName:"p"},"derive")," attribute,\nconsult the ",(0,i.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/std/index.html"},"standard library documentation"),"\nfor each trait for details of how to manually implement them."),(0,i.kt)("p",null,"These traits listed here are the only ones defined by the standard library that\ncan be implemented on your types using ",(0,i.kt)("inlineCode",{parentName:"p"},"derive"),". Other traits defined in the\nstandard library don't have sensible default behavior, so it's up to you to\nimplement them in the way that makes sense for what you're trying to accomplish."),(0,i.kt)("p",null,"An example of a trait that can't be derived is ",(0,i.kt)("inlineCode",{parentName:"p"},"Display"),", which handles\nformatting for end users. You should always consider the appropriate way to\ndisplay a type to an end user. What parts of the type should an end user be\nallowed to see? What parts would they find relevant? What format of the data\nwould be most relevant to them? The Rust compiler doesn't have this insight, so\nit can't provide appropriate default behavior for you."),(0,i.kt)("p",null,"The list of derivable traits provided in this appendix is not comprehensive:\nlibraries can implement ",(0,i.kt)("inlineCode",{parentName:"p"},"derive")," for their own traits, making the list of\ntraits you can use ",(0,i.kt)("inlineCode",{parentName:"p"},"derive")," with truly open-ended. Implementing ",(0,i.kt)("inlineCode",{parentName:"p"},"derive"),"\ninvolves using a procedural macro, which is covered in the\n",(0,i.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch19/ch19-05-macros#195---macros"},'"Macros"')," section of Chapter 19."),(0,i.kt)("h2",{id:"debug-for-programmer-output"},(0,i.kt)("inlineCode",{parentName:"h2"},"Debug")," for Programmer Output"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Debug")," trait enables debug formatting in format strings, which you\nindicate by adding ",(0,i.kt)("inlineCode",{parentName:"p"},":?")," within ",(0,i.kt)("inlineCode",{parentName:"p"},"{}")," placeholders."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Debug")," trait allows you to print instances of a type for debugging\npurposes, so you and other programmers using your type can inspect an instance\nat a particular point in a program's execution."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Debug")," trait is required, for example, in use of the ",(0,i.kt)("inlineCode",{parentName:"p"},"assert_eq!")," macro.\nThis macro prints the values of instances given as arguments if the equality\nassertion fails so programmers can see why the two instances weren't equal."),(0,i.kt)("h2",{id:"partialeq-and-eq-for-equality-comparisons"},(0,i.kt)("inlineCode",{parentName:"h2"},"PartialEq")," and ",(0,i.kt)("inlineCode",{parentName:"h2"},"Eq")," for Equality Comparisons"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"PartialEq")," trait allows you to compare instances of a type to check for\nequality and enables use of the ",(0,i.kt)("inlineCode",{parentName:"p"},"==")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"!=")," operators."),(0,i.kt)("p",null,"Deriving ",(0,i.kt)("inlineCode",{parentName:"p"},"PartialEq")," implements the ",(0,i.kt)("inlineCode",{parentName:"p"},"eq")," method. When ",(0,i.kt)("inlineCode",{parentName:"p"},"PartialEq")," is derived on\nstructs, two instances are equal only if ",(0,i.kt)("em",{parentName:"p"},"all")," fields are equal, and the\ninstances are not equal if any fields are not equal. When derived on enums,\neach variant is equal to itself and not equal to the other variants."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"PartialEq")," trait is required, for example, with the use of the\n",(0,i.kt)("inlineCode",{parentName:"p"},"assert_eq!")," macro, which needs to be able to compare two instances of a type\nfor equality."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Eq")," trait has no methods. Its purpose is to signal that for every value of\nthe annotated type, the value is equal to itself. The ",(0,i.kt)("inlineCode",{parentName:"p"},"Eq")," trait can only be\napplied to types that also implement ",(0,i.kt)("inlineCode",{parentName:"p"},"PartialEq"),", although not all types that\nimplement ",(0,i.kt)("inlineCode",{parentName:"p"},"PartialEq")," can implement ",(0,i.kt)("inlineCode",{parentName:"p"},"Eq"),". One example of this is floating point\nnumber types: the implementation of floating point numbers states that two\ninstances of the not-a-number (",(0,i.kt)("inlineCode",{parentName:"p"},"NaN"),") value are not equal to each other."),(0,i.kt)("p",null,"An example of when ",(0,i.kt)("inlineCode",{parentName:"p"},"Eq")," is required is for keys in a ",(0,i.kt)("inlineCode",{parentName:"p"},"HashMap<K, V>")," so the\n",(0,i.kt)("inlineCode",{parentName:"p"},"HashMap<K, V>")," can tell whether two keys are the same."),(0,i.kt)("h2",{id:"partialord-and-ord-for-ordering-comparisons"},(0,i.kt)("inlineCode",{parentName:"h2"},"PartialOrd")," and ",(0,i.kt)("inlineCode",{parentName:"h2"},"Ord")," for Ordering Comparisons"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"PartialOrd")," trait allows you to compare instances of a type for sorting\npurposes. A type that implements ",(0,i.kt)("inlineCode",{parentName:"p"},"PartialOrd")," can be used with the ",(0,i.kt)("inlineCode",{parentName:"p"},"<"),", ",(0,i.kt)("inlineCode",{parentName:"p"},">"),",\n",(0,i.kt)("inlineCode",{parentName:"p"},"<="),", and ",(0,i.kt)("inlineCode",{parentName:"p"},">=")," operators. You can only apply the ",(0,i.kt)("inlineCode",{parentName:"p"},"PartialOrd")," trait to types\nthat also implement ",(0,i.kt)("inlineCode",{parentName:"p"},"PartialEq"),"."),(0,i.kt)("p",null,"Deriving ",(0,i.kt)("inlineCode",{parentName:"p"},"PartialOrd")," implements the ",(0,i.kt)("inlineCode",{parentName:"p"},"partial_cmp")," method, which returns an\n",(0,i.kt)("inlineCode",{parentName:"p"},"Option<Ordering>")," that will be ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," when the values given don't produce an\nordering. An example of a value that doesn't produce an ordering, even though\nmost values of that type can be compared, is the not-a-number (",(0,i.kt)("inlineCode",{parentName:"p"},"NaN"),") floating\npoint value. Calling ",(0,i.kt)("inlineCode",{parentName:"p"},"partial_cmp")," with any floating point number and the ",(0,i.kt)("inlineCode",{parentName:"p"},"NaN"),"\nfloating point value will return ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),"."),(0,i.kt)("p",null,"When derived on structs, ",(0,i.kt)("inlineCode",{parentName:"p"},"PartialOrd")," compares two instances by comparing the\nvalue in each field in the order in which the fields appear in the struct\ndefinition. When derived on enums, variants of the enum declared earlier in the\nenum definition are considered less than the variants listed later."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"PartialOrd")," trait is required, for example, for the ",(0,i.kt)("inlineCode",{parentName:"p"},"gen_range")," method\nfrom the ",(0,i.kt)("inlineCode",{parentName:"p"},"rand")," crate that generates a random value in the range specified by a\nrange expression."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Ord")," trait allows you to know that for any two values of the annotated\ntype, a valid ordering will exist. The ",(0,i.kt)("inlineCode",{parentName:"p"},"Ord")," trait implements the ",(0,i.kt)("inlineCode",{parentName:"p"},"cmp")," method,\nwhich returns an ",(0,i.kt)("inlineCode",{parentName:"p"},"Ordering")," rather than an ",(0,i.kt)("inlineCode",{parentName:"p"},"Option<Ordering>")," because a valid\nordering will always be possible. You can only apply the ",(0,i.kt)("inlineCode",{parentName:"p"},"Ord")," trait to types\nthat also implement ",(0,i.kt)("inlineCode",{parentName:"p"},"PartialOrd")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Eq")," (and ",(0,i.kt)("inlineCode",{parentName:"p"},"Eq")," requires ",(0,i.kt)("inlineCode",{parentName:"p"},"PartialEq"),"). When\nderived on structs and enums, ",(0,i.kt)("inlineCode",{parentName:"p"},"cmp")," behaves the same way as the derived\nimplementation for ",(0,i.kt)("inlineCode",{parentName:"p"},"partial_cmp")," does with ",(0,i.kt)("inlineCode",{parentName:"p"},"PartialOrd"),"."),(0,i.kt)("p",null,"An example of when ",(0,i.kt)("inlineCode",{parentName:"p"},"Ord")," is required is when storing values in a ",(0,i.kt)("inlineCode",{parentName:"p"},"BTreeSet<T>"),",\na data structure that stores data based on the sort order of the values."),(0,i.kt)("h2",{id:"clone-and-copy-for-duplicating-values"},(0,i.kt)("inlineCode",{parentName:"h2"},"Clone")," and ",(0,i.kt)("inlineCode",{parentName:"h2"},"Copy")," for Duplicating Values"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Clone")," trait allows you to explicitly create a deep copy of a value, and\nthe duplication process might involve running arbitrary code and copying heap\ndata. See the ",(0,i.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch04-ownership#there-can-only-be-one"},"\u201cWays Variables and Data Interact:\nClone\u201d")," section in\nChapter 4 for more information on ",(0,i.kt)("inlineCode",{parentName:"p"},"Clone"),"."),(0,i.kt)("p",null,"Deriving ",(0,i.kt)("inlineCode",{parentName:"p"},"Clone")," implements the ",(0,i.kt)("inlineCode",{parentName:"p"},"clone")," method, which when implemented for the\nwhole type, calls ",(0,i.kt)("inlineCode",{parentName:"p"},"clone")," on each of the parts of the type. This means all the\nfields or values in the type must also implement ",(0,i.kt)("inlineCode",{parentName:"p"},"Clone")," to derive ",(0,i.kt)("inlineCode",{parentName:"p"},"Clone"),"."),(0,i.kt)("p",null,"An example of when ",(0,i.kt)("inlineCode",{parentName:"p"},"Clone")," is required is when calling the ",(0,i.kt)("inlineCode",{parentName:"p"},"to_vec")," method on a\nslice. The slice doesn't own the type instances it contains, but the vector\nreturned from ",(0,i.kt)("inlineCode",{parentName:"p"},"to_vec")," will need to own its instances, so ",(0,i.kt)("inlineCode",{parentName:"p"},"to_vec")," calls\n",(0,i.kt)("inlineCode",{parentName:"p"},"clone")," on each item. Thus, the type stored in the slice must implement ",(0,i.kt)("inlineCode",{parentName:"p"},"Clone"),"."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Copy")," trait allows you to duplicate a value by only copying bits stored on\nthe stack; no arbitrary code is necessary. See the ",(0,i.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch04-ownership#stack-only-data-copy"},'"Stack-Only Data:\nCopy"')," section in Chapter 4 for more\ninformation on ",(0,i.kt)("inlineCode",{parentName:"p"},"Copy"),"."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Copy")," trait doesn't define any methods to prevent programmers from\noverloading those methods and violating the assumption that no arbitrary code\nis being run. That way, all programmers can assume that copying a value will be\nvery fast."),(0,i.kt)("p",null,"You can derive ",(0,i.kt)("inlineCode",{parentName:"p"},"Copy")," on any type whose parts all implement ",(0,i.kt)("inlineCode",{parentName:"p"},"Copy"),". A type that\nimplements ",(0,i.kt)("inlineCode",{parentName:"p"},"Copy")," must also implement ",(0,i.kt)("inlineCode",{parentName:"p"},"Clone"),", because a type that implements\n",(0,i.kt)("inlineCode",{parentName:"p"},"Copy")," has a trivial implementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"Clone")," that performs the same task as\n",(0,i.kt)("inlineCode",{parentName:"p"},"Copy"),"."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Copy")," trait is rarely required; types that implement ",(0,i.kt)("inlineCode",{parentName:"p"},"Copy")," have\noptimizations available, meaning you don't have to call ",(0,i.kt)("inlineCode",{parentName:"p"},"clone"),", which makes\nthe code more concise."),(0,i.kt)("p",null,"Everything possible with ",(0,i.kt)("inlineCode",{parentName:"p"},"Copy")," you can also accomplish with ",(0,i.kt)("inlineCode",{parentName:"p"},"Clone"),", but the\ncode might be slower or have to use ",(0,i.kt)("inlineCode",{parentName:"p"},"clone")," in places."),(0,i.kt)("h2",{id:"hash-for-mapping-a-value-to-a-value-of-fixed-size"},(0,i.kt)("inlineCode",{parentName:"h2"},"Hash")," for Mapping a Value to a Value of Fixed Size"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Hash")," trait allows you to take an instance of a type of arbitrary size and\nmap that instance to a value of fixed size using a hash function. Deriving\n",(0,i.kt)("inlineCode",{parentName:"p"},"Hash")," implements the ",(0,i.kt)("inlineCode",{parentName:"p"},"hash")," method. The derived implementation of the ",(0,i.kt)("inlineCode",{parentName:"p"},"hash"),"\nmethod combines the result of calling ",(0,i.kt)("inlineCode",{parentName:"p"},"hash")," on each of the parts of the type,\nmeaning all fields or values must also implement ",(0,i.kt)("inlineCode",{parentName:"p"},"Hash")," to derive ",(0,i.kt)("inlineCode",{parentName:"p"},"Hash"),"."),(0,i.kt)("p",null,"An example of when ",(0,i.kt)("inlineCode",{parentName:"p"},"Hash")," is required is in storing keys in a ",(0,i.kt)("inlineCode",{parentName:"p"},"HashMap<K, V>"),"\nto store data efficiently."),(0,i.kt)("h2",{id:"default-for-default-values"},(0,i.kt)("inlineCode",{parentName:"h2"},"Default")," for Default Values"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Default")," trait allows you to create a default value for a type. Deriving\n",(0,i.kt)("inlineCode",{parentName:"p"},"Default")," implements the ",(0,i.kt)("inlineCode",{parentName:"p"},"default")," function. The derived implementation of the\n",(0,i.kt)("inlineCode",{parentName:"p"},"default")," function calls the ",(0,i.kt)("inlineCode",{parentName:"p"},"default")," function on each part of the type,\nmeaning all fields or values in the type must also implement ",(0,i.kt)("inlineCode",{parentName:"p"},"Default")," to\nderive ",(0,i.kt)("inlineCode",{parentName:"p"},"Default"),"."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Default::default")," function is commonly used in combination with the struct\nupdate syntax discussed in the ",(0,i.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch05-structs#creating-instances-from-other-instances-with-struct-update-syntax"},"\u201cCreating Instances From Other Instances With\nStruct Update\nSyntax\u201d"),"\nsection in Chapter 5. You can customize a few fields of a struct and then\nset and use a default value for the rest of the fields by using\n",(0,i.kt)("inlineCode",{parentName:"p"},"..Default::default()"),"."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Default")," trait is required when you use the method ",(0,i.kt)("inlineCode",{parentName:"p"},"unwrap_or_default")," on\n",(0,i.kt)("inlineCode",{parentName:"p"},"Option<T>")," instances, for example. If the ",(0,i.kt)("inlineCode",{parentName:"p"},"Option<T>")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),", the method\n",(0,i.kt)("inlineCode",{parentName:"p"},"unwrap_or_default")," will return the result of ",(0,i.kt)("inlineCode",{parentName:"p"},"Default::default")," for the type\n",(0,i.kt)("inlineCode",{parentName:"p"},"T")," stored in the ",(0,i.kt)("inlineCode",{parentName:"p"},"Option<T>"),"."))}h.isMDXComponent=!0}}]);