"use strict";(self.webpackChunkrust_book_abridged=self.webpackChunkrust_book_abridged||[]).push([[588],{3905:(e,t,n)=>{n.d(t,{Zo:()=>h,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},h=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),c=p(n),d=r,m=c["".concat(l,".").concat(d)]||c[d]||u[d]||i;return n?a.createElement(m,o(o({ref:t},h),{},{components:n})):a.createElement(m,o({ref:t},h))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:r,o[1]=s;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},7061:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const i={},o="8 - Common Collections",s={unversionedId:"ch08-common-collections",id:"ch08-common-collections",title:"8 - Common Collections",description:"Rust's standard library includes a number of collections which store data on the heap:",source:"@site/docs/ch08-common-collections.md",sourceDirName:".",slug:"/ch08-common-collections",permalink:"/rust-book-abridged/ch08-common-collections",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ch08-common-collections.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"7 - Managing Growing Projects with Packages, Crates, and Modules",permalink:"/rust-book-abridged/ch07-packages-crates-modules"},next:{title:"9 - Error Handling",permalink:"/rust-book-abridged/ch09-error-handling"}},l={},p=[{value:"8.1 - Storing Lists of Values with Vectors",id:"81---storing-lists-of-values-with-vectors",level:2},{value:"Creating a New Vector",id:"creating-a-new-vector",level:3},{value:"Updating a Vector",id:"updating-a-vector",level:3},{value:"Reading Elements of Vectors",id:"reading-elements-of-vectors",level:3},{value:"Iterating over the Values in a Vector",id:"iterating-over-the-values-in-a-vector",level:3},{value:"Using an Enum to Store Multiple Types",id:"using-an-enum-to-store-multiple-types",level:3},{value:"Dropping a Vector Drops Its Elements",id:"dropping-a-vector-drops-its-elements",level:3},{value:"8.2 - Storing UTF-8 Encoded Text with Strings",id:"82---storing-utf-8-encoded-text-with-strings",level:2},{value:"What Is a String?",id:"what-is-a-string",level:3},{value:"Creating a New String",id:"creating-a-new-string",level:3},{value:"Updating a String",id:"updating-a-string",level:3},{value:"Indexing into Strings",id:"indexing-into-strings",level:3},{value:"Bytes and Scalar Values and Grapheme Clusters! Oh My!",id:"bytes-and-scalar-values-and-grapheme-clusters-oh-my",level:3},{value:"Slicing Strings",id:"slicing-strings",level:3},{value:"Methods for Iterating Over Strings",id:"methods-for-iterating-over-strings",level:3},{value:"8.3 - Storing Keys with Associated Values in Hash Maps",id:"83---storing-keys-with-associated-values-in-hash-maps",level:2},{value:"Basic Hash Map Operations",id:"basic-hash-map-operations",level:3},{value:"Hash Maps and Ownership",id:"hash-maps-and-ownership",level:3},{value:"Updating a Hash Map",id:"updating-a-hash-map",level:3},{value:"Hashing Functions",id:"hashing-functions",level:3}],h={toc:p},c="wrapper";function u(e){let{components:t,...n}=e;return(0,r.kt)(c,(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"8---common-collections"},"8 - Common Collections"),(0,r.kt)("p",null,"Rust's standard library includes a number of ",(0,r.kt)("em",{parentName:"p"},"collections")," which store data on the heap:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"em"},"Vec<T>"))," (short for Vector) is essentially a variable length array."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"String")," is a variable length collection of characters - like a special vector just for characters."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"HashMap")," allows you to associate values with keys.")),(0,r.kt)("p",null,"These are the most common collections, but if you check ",(0,r.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/stable/std/collections/index.html"},"the collections documentation")," you'll see there are many others."),(0,r.kt)("h2",{id:"81---storing-lists-of-values-with-vectors"},"8.1 - Storing Lists of Values with Vectors"),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"Vec<T>"),", also known as a ",(0,r.kt)("em",{parentName:"p"},"vector"),' is a bit like a "variable-length array". It\'s a generic type (see ',(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch10/ch10-01-generic-data-types"},"chapter 10"),"), so it can hold any type. Internally, vector stores it's data in a contiguous block of memory which it resizes as required. Since the size of a vector isn't know at compile time, it stores values on the heap. Vectors are used often in Rust programs, so ",(0,r.kt)("inlineCode",{parentName:"p"},"Vec")," is part of the prelude."),(0,r.kt)("p",null,"If you want to know the details about how a vector is implemented, check out ",(0,r.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/stable/nomicon/vec/vec.html"},"The Rustonomicon"),". Also be sure to check out ",(0,r.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/stable/std/vec/struct.Vec.html"},"the API documentation")," for methods defined on vector that we don't discuss here."),(0,r.kt)("h3",{id:"creating-a-new-vector"},"Creating a New Vector"),(0,r.kt)("p",null,"Like many structs in Rust, we can create a vector with the associated ",(0,r.kt)("inlineCode",{parentName:"p"},"new")," function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"let v: Vec<i32> = Vec::new();\n")),(0,r.kt)("p",null,"Since we didn't create this vector with any initial values, and we're not calling any functions on it, it's impossible for rustc to infer the generic type of this vector, so we need the ",(0,r.kt)("inlineCode",{parentName:"p"},"Vec<i32>")," type annotation."),(0,r.kt)("p",null,"If you want to create a vector from an array of initial values, Rust provides the ",(0,r.kt)("inlineCode",{parentName:"p"},"vec!")," macro for this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"let v = vec![1, 2, 3];\n")),(0,r.kt)("h3",{id:"updating-a-vector"},"Updating a Vector"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"let mut v = Vec::new();\n\n// Add some members to the vector.\nv.push(5);\nv.push(6);\nv.push(7);\n")),(0,r.kt)("p",null,"We don't need to annotate the type of ",(0,r.kt)("inlineCode",{parentName:"p"},"v")," here. Since we're passing ",(0,r.kt)("inlineCode",{parentName:"p"},"i32"),"s to ",(0,r.kt)("inlineCode",{parentName:"p"},"push"),", Rust can infer the type of the vector. We do need to mark ",(0,r.kt)("inlineCode",{parentName:"p"},"v")," as mutable though, otherwise we wouldn't be allowed to call ",(0,r.kt)("inlineCode",{parentName:"p"},"push"),". In addition to ",(0,r.kt)("inlineCode",{parentName:"p"},"push"),", there's a ",(0,r.kt)("inlineCode",{parentName:"p"},"pop")," method that removes and returns the last element."),(0,r.kt)("h3",{id:"reading-elements-of-vectors"},"Reading Elements of Vectors"),(0,r.kt)("p",null,"You can read elements from a vector using the same syntax you'd use to index elements of an array, or you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"get")," method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"let v = vec![1, 2, 3, 4, 5];\n\nlet third = &v[2]; // This is an &i32.\n\nlet fourth = v.get(3); // This is an Option<&i32>\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"get")," returns an ",(0,r.kt)("inlineCode",{parentName:"p"},"Option"),"; if we try to ",(0,r.kt)("inlineCode",{parentName:"p"},"get")," an index outside the bounds of the vector, then ",(0,r.kt)("inlineCode",{parentName:"p"},"get")," will return ",(0,r.kt)("inlineCode",{parentName:"p"},"None"),". Since the ",(0,r.kt)("inlineCode",{parentName:"p"},"[]")," syntax doesn't return an ",(0,r.kt)("inlineCode",{parentName:"p"},"Option")," then, as you might expect, it will cause a panic if you try to retrieve an index which is out-of-bounds."),(0,r.kt)("p",null,"Here's a quick example that looks at first glance like it ought to work, but will fail to compile:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let mut v = vec![1, 2, 3, 4, 5];\n\nlet first = &v[0];\n\nv.push(6); // This will fail to compile!\n\nprintln!("The first element is: {first}");\n')),(0,r.kt)("p",null,"The simple explanation of why this doesn't work is that, as you may recall from ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch04-ownership#mutable-references"},"chapter 4"),", if you have a mutable reference to a value, you can have no other references to that value. Here ",(0,r.kt)("inlineCode",{parentName:"p"},"v.push(6)")," needs a mutable reference to the vector, which it can't get because of the ref stored in ",(0,r.kt)("inlineCode",{parentName:"p"},"first"),". But ",(0,r.kt)("inlineCode",{parentName:"p"},"first")," is just a ref to the first item in the vector? Why does that prevent us from modifying some other part of the vector?"),(0,r.kt)("p",null,"The problem here has to do with the way that vector is implemented. Vector is, at heart, an array. When we ",(0,r.kt)("inlineCode",{parentName:"p"},"push")," an element onto the vector, if there isn't enough room in the underlying array, vector will allocate a new chunk of memory to hold a larger array and copy elements from the old array to the new one. This means that the reference to ",(0,r.kt)("inlineCode",{parentName:"p"},"first")," is really a pointer to a part of that buffer. If ",(0,r.kt)("inlineCode",{parentName:"p"},"push")," were to free this memory, then ",(0,r.kt)("inlineCode",{parentName:"p"},"first")," would point to unallocated memory."),(0,r.kt)("h3",{id:"iterating-over-the-values-in-a-vector"},"Iterating over the Values in a Vector"),(0,r.kt)("p",null,"We can use a ",(0,r.kt)("inlineCode",{parentName:"p"},"for in")," loop to iterate over elements in a vector:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let v = vec![100, 32, 57];\nfor i in &v {\n    println!("{i}");\n}\n')),(0,r.kt)("p",null,"If our vector is mutable, we can mutate it as we iterate:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"let mut v = vec![100, 32, 57];\nfor mut i in &mut v {\n    *i += 50;\n}\n")),(0,r.kt)("p",null,"Note the explicit '","*","` dereference operator here. We'll talk more about the dereference operator in ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch15-smart-pointers#following-the-pointer-to-the-value"},"chapter 15"),"."),(0,r.kt)("h3",{id:"using-an-enum-to-store-multiple-types"},"Using an Enum to Store Multiple Types"),(0,r.kt)("p",null,"A vector can only store elements that are all the same type. Recall though that the different variants of an enum are all the same underlying type, so we can use this to our advantage. Here's an example of a vector of spreadsheet cells where each cell holds different data:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'enum SpreadsheetCell {\n    Int(i32),\n    Float(f64),\n    Text(String),\n}\n\nlet row = vec![\n    SpreadsheetCell::Int(3),\n    SpreadsheetCell::Text(String::from("blue")),\n    SpreadsheetCell::Float(10.12),\n];\n')),(0,r.kt)("p",null,"This trick only works if you know all the types you want to store in a vector ahead of time. If you don't, you can use a trait object, which we'll discuss in ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch17-object-oriented-features",title:"Chapter 17: Object Oriented Features of Rust"},"chapter 17"),"."),(0,r.kt)("h3",{id:"dropping-a-vector-drops-its-elements"},"Dropping a Vector Drops Its Elements"),(0,r.kt)("p",null,"Once a vector goes out-of-scope, like any other struct it gets dropped and the memory associated with it is freed."),(0,r.kt)("h2",{id:"82---storing-utf-8-encoded-text-with-strings"},"8.2 - Storing UTF-8 Encoded Text with Strings"),(0,r.kt)("p",null,"We're going to talk about strings here in the chapter on collections, because a string is basically a vector of UTF8 bytes. Strings can seem a bit more finicky in Rust than in other languages, but in actual fact most other languages let you do very unsafe things with Strings and the real difference is that Rust tries to protect you from this."),(0,r.kt)("h3",{id:"what-is-a-string"},"What Is a String?"),(0,r.kt)("p",null,"In the core language, Rust only defines the string slice ",(0,r.kt)("inlineCode",{parentName:"p"},"&str"),'. This represents a string of characters that is stored "somewhere else", like in the program binary. The ',(0,r.kt)("inlineCode",{parentName:"p"},"String")," type in Rust isn't actually part of the core language, but part of the standard library."),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"String")," represents a growable, mutable UTF-8 encoded string stored on the heap."),(0,r.kt)("h3",{id:"creating-a-new-string"},"Creating a New String"),(0,r.kt)("p",null,"We can create a String with ",(0,r.kt)("inlineCode",{parentName:"p"},"new"),", just like a vector:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"let mut s = String::new();\n")),(0,r.kt)("p",null,"Any type that implements the ",(0,r.kt)("inlineCode",{parentName:"p"},"Display")," trait has a ",(0,r.kt)("inlineCode",{parentName:"p"},"to_string")," method which can be used to create a string:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let s = "Hello, world!".to_string();\n')),(0,r.kt)("p",null,"And as we've seen we can also use ",(0,r.kt)("inlineCode",{parentName:"p"},"String::from")," to copy a string literal into a String:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let s = String::from("Hello, World!");\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"to_string")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"String::from")," do exactly the same thing here. Which you choose is a matter of style and readability."),(0,r.kt)("h3",{id:"updating-a-string"},"Updating a String"),(0,r.kt)("p",null,"Strings, like vectors, can grow in size and be modified. You can concatenate Strings with the ",(0,r.kt)("inlineCode",{parentName:"p"},"+")," operator or the ",(0,r.kt)("inlineCode",{parentName:"p"},"format!")," macro."),(0,r.kt)("p",null,"Some examples:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let mut foobar = String::from("foo");\n\n// push_str() appends a string slice.\nfoobar.push_str("bar");\n\n// push() appends a single character.\nfoobar.push(\'!\');\n')),(0,r.kt)("p",null,"We can concatenate with the ",(0,r.kt)("inlineCode",{parentName:"p"},"+")," operator, similar to JavaScript, Java, and Go:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// + can be used to concatenate strings:\nlet s1 = String::from("Hello, ");\nlet s2 = String::from("World!");\nlet s3 = s1 + &s2;\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"+")," operator here will take ownership of ",(0,r.kt)("inlineCode",{parentName:"p"},"s1"),", so ",(0,r.kt)("inlineCode",{parentName:"p"},"s1")," won't be valid after the ",(0,r.kt)("inlineCode",{parentName:"p"},"+")," expression. The eagle eyed among you will notice we didn't write ",(0,r.kt)("inlineCode",{parentName:"p"},"s1 + s2"),", but ",(0,r.kt)("inlineCode",{parentName:"p"},"s1 + &s2"),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"+")," operator is actually implemented using the ",(0,r.kt)("inlineCode",{parentName:"p"},"add")," method on String. If you look up ",(0,r.kt)("inlineCode",{parentName:"p"},"add"),", you'll it is implemented using generics, but basically in this particular case the function signature boils down to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"fn add(self, s: &str) -> String\n")),(0,r.kt)("p",null,"And so the second parameter needs to be a reference. Those readers who are especially alert might also notice that we're passing an ",(0,r.kt)("inlineCode",{parentName:"p"},"&String")," to the add operator here and not an ",(0,r.kt)("inlineCode",{parentName:"p"},"&str")," for that second parameter, but this is okay because Rust can ",(0,r.kt)("em",{parentName:"p"},"coerce")," the type of ",(0,r.kt)("inlineCode",{parentName:"p"},"&s2")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"&str"),". We'll talk more about this in ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch15-smart-pointers",title:"Chapter 15: Smart Pointers"},"chapter 15"),"."),(0,r.kt)("p",null,"If we want to concatenate multiple strings, we can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"format!")," macro, which is a bit like ",(0,r.kt)("inlineCode",{parentName:"p"},"println!")," except it evaluates to a ",(0,r.kt)("inlineCode",{parentName:"p"},"String")," instead of printing the result to the screen:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let s1 = String::from("tic");\nlet s2 = String::from("tac");\nlet s3 = String::from("toe");\n\nlet s = format!("{s1}-{s2}-{s3}");\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"format!")," doesn't take ownership of any of these values."),(0,r.kt)("h3",{id:"indexing-into-strings"},"Indexing into Strings"),(0,r.kt)("p",null,"Unlike with a vector, you can't index into a string with ",(0,r.kt)("inlineCode",{parentName:"p"},"[]"),"."),(0,r.kt)("p",null,"Many languages treat indexing into a string as getting the nth byte from a string, but mainly this is a throwback to the days when we used encodings like 8-bit ASCII, where a single byte was a single character on the screen. Rust doesn't allow you to index into a String like this. You can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"s.bytes()")," method to get an iterator over the underlying bytes, or ",(0,r.kt)("inlineCode",{parentName:"p"},"s.chars()")," to get at the underlying unicode scalar values."),(0,r.kt)("h3",{id:"bytes-and-scalar-values-and-grapheme-clusters-oh-my"},"Bytes and Scalar Values and Grapheme Clusters! Oh My!"),(0,r.kt)("p",null,"We can look at any UTF-8 string as a series of bytes, but we can also look at it as a series of ",(0,r.kt)("inlineCode",{parentName:"p"},"char"),"s (which represent ",(0,r.kt)("a",{parentName:"p",href:"https://www.unicode.org/glossary/#unicode_scalar_value"},"unicode scalar values"),'), or as a series of grapheme clusters (i.e. how many "letters" it takes up on the screen).'),(0,r.kt)("p",null,'The word "Hello" contains five bytes, five letters, and five grapheme clusters. If you replaced the first byte with a 74, you\'d change it to "Jello".'),(0,r.kt)("p",null,'The Ukrainian word for "rust" is "\u0456\u0440\u0436\u0430", which contains 8 bytes: ',(0,r.kt)("inlineCode",{parentName:"p"},"[209, 150, 209, 128, 208, 182, 208, 176]"),". Each of pair of bytes encodes a single unicode scalar value, so there are four ",(0,r.kt)("inlineCode",{parentName:"p"},"char"),"s in this, and there are also four grapheme clusters. If you replaced the first byte with a 74 you'd transform it into an invalid unicode string."),(0,r.kt)("p",null,'This is a female astronaut emoji: "\ud83e\uddd1\u200d\ud83d\ude80". She\'s actually two other emoji joined together with a ',(0,r.kt)("a",{parentName:"p",href:"https://www.unicode.org/emoji/charts/emoji-zwj-sequences.html"},"zero-width-joiner"),". Our astronaut emoji contains a total of eleven bytes: ",(0,r.kt)("inlineCode",{parentName:"p"},"[240, 159, 167, 145, 226, 128, 141, 240, 159, 154, 128]"),". These bytes are the encoding of only three ",(0,r.kt)("inlineCode",{parentName:"p"},"char"),"s : ",(0,r.kt)("inlineCode",{parentName:"p"},"['\ud83e\uddd1', '\\u{200D}', '\ud83d\ude80']"),'. And, this string contains only a single grapheme cluster - it displays as a single "letter" in the text of this book.'),(0,r.kt)("h3",{id:"slicing-strings"},"Slicing Strings"),(0,r.kt)("p",null,"While you can't index a single byte or char out of a string, you can get a slice of bytes out of a string:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let hello = "\u0417\u0434\u0440\u0430\u0432\u0441\u0442\u0432\u0443\u0439\u0442\u0435";\n\nlet s = &hello[0..4];\n')),(0,r.kt)("p",null,"Here ",(0,r.kt)("inlineCode",{parentName:"p"},"s")," ends up being a ",(0,r.kt)("inlineCode",{parentName:"p"},"&str"),' that contains the first four bytes of the string, which will be the string "\u0417\u0434". If you tried to get ',(0,r.kt)("inlineCode",{parentName:"p"},"&hello[0..1]"),", this would return the first byte, but since this would result in an invalid UTF-8 string, this will cause a panic. You need to be extremely careful when slicing strings that you are slicing at valid char boundaries."),(0,r.kt)("h3",{id:"methods-for-iterating-over-strings"},"Methods for Iterating Over Strings"),(0,r.kt)("p",null,"If you want to get at the underlying collection of characters or the collection of bytes, the best way is to use methods defined on String to get these explicitly:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// Get at the underlying chars in a string\nfor c in "\u0417\u0434".chars() {\n    println!("{c}");\n}\n\n// Get at the underlying bytes\nfor b in "\u0417\u0434".bytes() {\n    println!("{b}");\n}\n')),(0,r.kt)("p",null,"Getting Grapheme clusters from a String is a surprisingly non-trivial problem (it's called ",(0,r.kt)("a",{parentName:"p",href:"https://unicode.org/reports/tr29/"},'"Unicode text segmentation"')," if you're interested), so Rust doesn't provide a function to do it in the standard library. If you need this functionality, you'll have to look to ",(0,r.kt)("a",{parentName:"p",href:"https://crates.io"},"a third party crate"),'. If you\'re not careful about this, though, it\'s easy to insert a "-" into the middle of "\ud83e\uddd1\u200d\ud83d\ude80" and accidentally turn it into "\ud83e\uddd1-\ud83d\ude80" on-screen.'),(0,r.kt)("h2",{id:"83---storing-keys-with-associated-values-in-hash-maps"},"8.3 - Storing Keys with Associated Values in Hash Maps"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"HashMap<K, V>")," stores a mapping of keys of type ",(0,r.kt)("inlineCode",{parentName:"p"},"K")," to values of type ",(0,r.kt)("inlineCode",{parentName:"p"},"V"),". This is just like a ",(0,r.kt)("inlineCode",{parentName:"p"},"Map")," in Go or JavaScript, or a HashMap in Java. The underlying implementation is a hash table with a ",(0,r.kt)("em",{parentName:"p"},"hashing function")," that converts each key into a number."),(0,r.kt)("h3",{id:"basic-hash-map-operations"},"Basic Hash Map Operations"),(0,r.kt)("p",null,"Since ",(0,r.kt)("inlineCode",{parentName:"p"},"HashMap")," isn't in the prelude, we have to ",(0,r.kt)("inlineCode",{parentName:"p"},"use")," it:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},'use std::collections::HashMap;\n\nfn main() {\n    let mut scores = HashMap::new();\n\n    // Insert some values into the map\n    scores.insert(String::from("Blue"), 10);\n    scores.insert(String::from("Yellow"), 50);\n\n    // Access values with `get`\n    let team_name = String::from("Blue");\n    let score = scores.get(&team_name).copied().unwrap_or(0);\n\n    // Iterate over the keys with a for loop:\n    for (key, value) in &scores {\n        println!("{key}: {value}");\n    }\n}\n')),(0,r.kt)("p",null,"Note that ",(0,r.kt)("inlineCode",{parentName:"p"},".get()")," here will return an ",(0,r.kt)("inlineCode",{parentName:"p"},"Option<&v>"),". If there's no value in the map we'll get back a ",(0,r.kt)("inlineCode",{parentName:"p"},"None"),". We call ",(0,r.kt)("inlineCode",{parentName:"p"},"copied")," to convert the ",(0,r.kt)("inlineCode",{parentName:"p"},"Option<&i32>")," into an ",(0,r.kt)("inlineCode",{parentName:"p"},"Option<i32>"),", and then call ",(0,r.kt)("inlineCode",{parentName:"p"},"unwrap_or")," to provide a default for the ",(0,r.kt)("inlineCode",{parentName:"p"},"None")," case. One important thing to note here especially if you're coming from JavaScript is that, when iterating over members of a Hash Map, you are not guaranteed to get them back in the same order you inserted them in. The ordering is arbitrary. (If you need predictable iteration order, a ",(0,r.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/std/collections/struct.BTreeMap.html"},(0,r.kt)("inlineCode",{parentName:"a"},"BTreeMap"))," will iterate in sorted order over the keys.)"),(0,r.kt)("h3",{id:"hash-maps-and-ownership"},"Hash Maps and Ownership"),(0,r.kt)("p",null,"HashMaps take ownership of both keys and values passed to them:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'use std::collections::HashMap;\n\nlet field_name = String::from("Favorite color");\nlet field_value = String::from("Blue");\n\nlet mut map = HashMap::new();\nmap.insert(field_name, field_value);\n// field_name and field_value are invalid at this point\n// as they have been moved.\n')),(0,r.kt)("p",null,"For types that implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"Copy")," trait, the values will be copied into the hash map, so we won't have to worry about ownership. If we don't want the hash map to take ownership, we can store keys or values as references, but in this case the values the references point to must be valid for as long as the hash map exists. For this we need to talk about lifetimes, which we'll do in ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch10/ch10-03-lifetimes"},"chapter 10"),"."),(0,r.kt)("h3",{id:"updating-a-hash-map"},"Updating a Hash Map"),(0,r.kt)("p",null,"When inserting into a Hash Map, the value we want to insert might already exist. If we just do a straight ",(0,r.kt)("inlineCode",{parentName:"p"},"insert"),", this will overwrite the value that's already there:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'use std::collections::HashMap;\n\nlet mut scores = HashMap::new();\n\nscores.insert(String::from("Blue"), 10);\n\n// Overwrite an existing value in the HashMap\nscores.insert(String::from("Blue"), 25);\n')),(0,r.kt)("p",null,"We can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"entry")," method on a hash map to get information about an existing entry in the map. The ",(0,r.kt)("inlineCode",{parentName:"p"},"entry")," method returns an ",(0,r.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/std/collections/hash_map/enum.Entry.html"},(0,r.kt)("inlineCode",{parentName:"a"},"Entry")," enum"),", which has methods defined on it that allow us to manipulate the map. For example, ",(0,r.kt)("inlineCode",{parentName:"p"},"Entry")," has an ",(0,r.kt)("inlineCode",{parentName:"p"},"or_insert")," method which will return the existing entry or insert a new entry if there is nothing stored at that key:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'use std::collections::HashMap;\n\nfn main() {\n    let mut scores = HashMap::new();\n\n    scores.insert(String::from("Blue"), 10);\n\n    // Set a value only if it doesn\'t exist\n    let new_score = scores.entry(String::from("Blue")).or_insert(50);\n}\n')),(0,r.kt)("p",null,"One interesting thing about ",(0,r.kt)("inlineCode",{parentName:"p"},"or_insert")," is that it returns a mutable reference to the existing or inserted value, which means we can use the return value from ",(0,r.kt)("inlineCode",{parentName:"p"},"or_insert")," to update the value in the hash map. This example counts how many times each word appears in a string. It works by dereferencing the ",(0,r.kt)("inlineCode",{parentName:"p"},"count")," in the map with the ",(0,r.kt)("inlineCode",{parentName:"p"},"*")," operator to let us increment the value for each word:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'use std::collections::HashMap;\n\nfn main() {\n    let text = "hello world wonderful world";\n\n    let mut map = HashMap::new();\n\n    for word in text.split_whitespace() {\n        let count = map.entry(word).or_insert(0);\n        *count += 1;\n    }\n\n    println!("{:?}", map);\n}\n')),(0,r.kt)("p",null,"If you're a JavaScript programmer this is maybe going to look like magic. What's going on here is that ",(0,r.kt)("inlineCode",{parentName:"p"},"count")," is a reference - essentially a pointer - to memory inside the hash map. We can use that pointer to modify the data in the hash map."),(0,r.kt)("h3",{id:"hashing-functions"},"Hashing Functions"),(0,r.kt)("p",null,'Each entry in a hash map is stored using a "hash" of the key, computed by a ',(0,r.kt)("em",{parentName:"p"},"hash function"),". In Rust the default hash function is unspecified and may change in future versions, but at the time of this writing the default is ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/SipHash"},"SipHash"),". You can replace the default hash function by creating a custom ",(0,r.kt)("em",{parentName:"p"},"hasher"),". You need to implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"BuildHasher")," trait, or find a crate on ",(0,r.kt)("a",{parentName:"p",href:"https://crates.io"},"crates.io")," that implements it."),(0,r.kt)("p",null,"Continue to ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch09-error-handling",title:"Chapter 9: Error Handling"},"chapter 9"),"."))}u.isMDXComponent=!0}}]);