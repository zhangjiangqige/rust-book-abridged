"use strict";(self.webpackChunkrust_book_abridged=self.webpackChunkrust_book_abridged||[]).push([[849],{3905:(t,e,n)=>{n.d(e,{Zo:()=>o,kt:()=>g});var a=n(7294);function r(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function l(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function i(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?l(Object(n),!0).forEach((function(e){r(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function d(t,e){if(null==t)return{};var n,a,r=function(t,e){if(null==t)return{};var n,a,r={},l=Object.keys(t);for(a=0;a<l.length;a++)n=l[a],e.indexOf(n)>=0||(r[n]=t[n]);return r}(t,e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(t);for(a=0;a<l.length;a++)n=l[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(r[n]=t[n])}return r}var p=a.createContext({}),m=function(t){var e=a.useContext(p),n=e;return t&&(n="function"==typeof t?t(e):i(i({},e),t)),n},o=function(t){var e=m(t.components);return a.createElement(p.Provider,{value:e},t.children)},k="mdxType",N={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},u=a.forwardRef((function(t,e){var n=t.components,r=t.mdxType,l=t.originalType,p=t.parentName,o=d(t,["components","mdxType","originalType","parentName"]),k=m(n),u=r,g=k["".concat(p,".").concat(u)]||k[u]||N[u]||l;return n?a.createElement(g,i(i({ref:e},o),{},{components:n})):a.createElement(g,i({ref:e},o))}));function g(t,e){var n=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var l=n.length,i=new Array(l);i[0]=u;var d={};for(var p in e)hasOwnProperty.call(e,p)&&(d[p]=e[p]);d.originalType=t,d[k]="string"==typeof t?t:r,i[1]=d;for(var m=2;m<l;m++)i[m]=n[m];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},4515:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>p,contentTitle:()=>i,default:()=>N,frontMatter:()=>l,metadata:()=>d,toc:()=>m});var a=n(7462),r=(n(7294),n(3905));const l={},i="Appendix B: Operators and Symbols",d={unversionedId:"zz-appendix/appendix-02-operators",id:"zz-appendix/appendix-02-operators",title:"Appendix B: Operators and Symbols",description:'This appendix was copied directly from "The Rust Programming Language".',source:"@site/docs/zz-appendix/appendix-02-operators.md",sourceDirName:"zz-appendix",slug:"/zz-appendix/appendix-02-operators",permalink:"/rust-book-abridged/zz-appendix/appendix-02-operators",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/zz-appendix/appendix-02-operators.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Appendix A: Keywords",permalink:"/rust-book-abridged/zz-appendix/appendix-01-keywords"},next:{title:"Appendix C: Derivable Traits",permalink:"/rust-book-abridged/zz-appendix/appendix-03-derivable-traits"}},p={},m=[{value:"Operators",id:"operators",level:2},{value:"Table B-1: Operators",id:"table-b-1-operators",level:3},{value:"Non-operator Symbols",id:"non-operator-symbols",level:2},{value:"Table B-2: Stand-Alone Syntax",id:"table-b-2-stand-alone-syntax",level:3},{value:"Table B-3: Path-Related Syntax",id:"table-b-3-path-related-syntax",level:3},{value:"Table B-4: Generics",id:"table-b-4-generics",level:3},{value:"Table B-5: Trait Bound Constraints",id:"table-b-5-trait-bound-constraints",level:3},{value:"Table B-6: Macros and Attributes",id:"table-b-6-macros-and-attributes",level:3},{value:"Table B-7: Comments",id:"table-b-7-comments",level:3},{value:"Table B-8: Tuples",id:"table-b-8-tuples",level:3},{value:"Table B-9: Curly Brackets",id:"table-b-9-curly-brackets",level:3},{value:"Table B-10: Square Brackets",id:"table-b-10-square-brackets",level:3}],o={toc:m},k="wrapper";function N(t){let{components:e,...n}=t;return(0,r.kt)(k,(0,a.Z)({},o,n,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"appendix-b-operators-and-symbols"},"Appendix B: Operators and Symbols"),(0,r.kt)("p",null,"This appendix was copied directly from ",(0,r.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/stable/book/appendix-02-operators.html"},'"The Rust Programming Language"'),"."),(0,r.kt)("p",null,"This appendix contains a glossary of Rust's syntax, including operators and\nother symbols that appear by themselves or in the context of paths, generics,\ntrait bounds, macros, attributes, comments, tuples, and brackets."),(0,r.kt)("h2",{id:"operators"},"Operators"),(0,r.kt)("p",null,"Table B-1 contains the operators in Rust, an example of how the operator would\nappear in context, a short explanation, and whether that operator is\noverloadable. If an operator is overloadable, the relevant trait to use to\noverload that operator is listed."),(0,r.kt)("h3",{id:"table-b-1-operators"},"Table B-1: Operators"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Operator"),(0,r.kt)("th",{parentName:"tr",align:null},"Example"),(0,r.kt)("th",{parentName:"tr",align:null},"Explanation"),(0,r.kt)("th",{parentName:"tr",align:null},"Overloadable?"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"!")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"ident!(...)"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"ident!{...}"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"ident![...]")),(0,r.kt)("td",{parentName:"tr",align:null},"Macro expansion"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"!")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"!expr")),(0,r.kt)("td",{parentName:"tr",align:null},"Bitwise or logical complement"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Not"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"!=")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"expr != expr")),(0,r.kt)("td",{parentName:"tr",align:null},"Nonequality comparison"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"PartialEq"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"%")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"expr % expr")),(0,r.kt)("td",{parentName:"tr",align:null},"Arithmetic remainder"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Rem"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"%=")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"var %= expr")),(0,r.kt)("td",{parentName:"tr",align:null},"Arithmetic remainder and assignment"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"RemAssign"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"&")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"&expr"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"&mut expr")),(0,r.kt)("td",{parentName:"tr",align:null},"Borrow"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"&")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"&type"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"&mut type"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"&'a type"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"&'a mut type")),(0,r.kt)("td",{parentName:"tr",align:null},"Borrowed pointer type"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"&")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"expr & expr")),(0,r.kt)("td",{parentName:"tr",align:null},"Bitwise AND"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"BitAnd"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"&=")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"var &= expr")),(0,r.kt)("td",{parentName:"tr",align:null},"Bitwise AND and assignment"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"BitAndAssign"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"&&")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"expr && expr")),(0,r.kt)("td",{parentName:"tr",align:null},"Short-circuiting logical AND"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"*")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"expr * expr")),(0,r.kt)("td",{parentName:"tr",align:null},"Arithmetic multiplication"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Mul"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"*=")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"var *= expr")),(0,r.kt)("td",{parentName:"tr",align:null},"Arithmetic multiplication and assignment"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"MulAssign"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"*")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"*expr")),(0,r.kt)("td",{parentName:"tr",align:null},"Dereference"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Deref"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"*")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"*const type"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"*mut type")),(0,r.kt)("td",{parentName:"tr",align:null},"Raw pointer"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"+")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"trait + trait"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"'a + trait")),(0,r.kt)("td",{parentName:"tr",align:null},"Compound type constraint"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"+")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"expr + expr")),(0,r.kt)("td",{parentName:"tr",align:null},"Arithmetic addition"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Add"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"+=")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"var += expr")),(0,r.kt)("td",{parentName:"tr",align:null},"Arithmetic addition and assignment"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"AddAssign"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},",")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"expr, expr")),(0,r.kt)("td",{parentName:"tr",align:null},"Argument and element separator"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"-")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"- expr")),(0,r.kt)("td",{parentName:"tr",align:null},"Arithmetic negation"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Neg"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"-")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"expr - expr")),(0,r.kt)("td",{parentName:"tr",align:null},"Arithmetic subtraction"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Sub"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"-=")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"var -= expr")),(0,r.kt)("td",{parentName:"tr",align:null},"Arithmetic subtraction and assignment"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"SubAssign"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"->")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"fn(...) -> type"),", ",(0,r.kt)("code",null,"|","...","|"," -> type")),(0,r.kt)("td",{parentName:"tr",align:null},"Function and closure return type"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},".")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"expr.ident")),(0,r.kt)("td",{parentName:"tr",align:null},"Member access"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"..")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},".."),", ",(0,r.kt)("inlineCode",{parentName:"td"},"expr.."),", ",(0,r.kt)("inlineCode",{parentName:"td"},"..expr"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"expr..expr")),(0,r.kt)("td",{parentName:"tr",align:null},"Right-exclusive range literal"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"PartialOrd"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"..=")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"..=expr"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"expr..=expr")),(0,r.kt)("td",{parentName:"tr",align:null},"Right-inclusive range literal"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"PartialOrd"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"..")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"..expr")),(0,r.kt)("td",{parentName:"tr",align:null},"Struct literal update syntax"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"..")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"variant(x, ..)"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"struct_type { x, .. }")),(0,r.kt)("td",{parentName:"tr",align:null},"\u201cAnd the rest\u201d pattern binding"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"...")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"expr...expr")),(0,r.kt)("td",{parentName:"tr",align:null},"(Deprecated, use ",(0,r.kt)("inlineCode",{parentName:"td"},"..=")," instead) In a pattern: inclusive range pattern"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"/")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"expr / expr")),(0,r.kt)("td",{parentName:"tr",align:null},"Arithmetic division"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Div"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"/=")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"var /= expr")),(0,r.kt)("td",{parentName:"tr",align:null},"Arithmetic division and assignment"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"DivAssign"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},":")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"pat: type"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"ident: type")),(0,r.kt)("td",{parentName:"tr",align:null},"Constraints"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},":")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"ident: expr")),(0,r.kt)("td",{parentName:"tr",align:null},"Struct field initializer"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},":")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"'a: loop {...}")),(0,r.kt)("td",{parentName:"tr",align:null},"Loop label"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},";")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"expr;")),(0,r.kt)("td",{parentName:"tr",align:null},"Statement and item terminator"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},";")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"[...; len]")),(0,r.kt)("td",{parentName:"tr",align:null},"Part of fixed-size array syntax"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"<<")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"expr << expr")),(0,r.kt)("td",{parentName:"tr",align:null},"Left-shift"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Shl"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"<<=")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"var <<= expr")),(0,r.kt)("td",{parentName:"tr",align:null},"Left-shift and assignment"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"ShlAssign"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"<")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"expr < expr")),(0,r.kt)("td",{parentName:"tr",align:null},"Less than comparison"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"PartialOrd"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"<=")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"expr <= expr")),(0,r.kt)("td",{parentName:"tr",align:null},"Less than or equal to comparison"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"PartialOrd"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"=")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"var = expr"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"ident = type")),(0,r.kt)("td",{parentName:"tr",align:null},"Assignment/equivalence"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"==")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"expr == expr")),(0,r.kt)("td",{parentName:"tr",align:null},"Equality comparison"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"PartialEq"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"=>")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"pat => expr")),(0,r.kt)("td",{parentName:"tr",align:null},"Part of match arm syntax"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},">")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"expr > expr")),(0,r.kt)("td",{parentName:"tr",align:null},"Greater than comparison"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"PartialOrd"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},">=")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"expr >= expr")),(0,r.kt)("td",{parentName:"tr",align:null},"Greater than or equal to comparison"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"PartialOrd"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},">>")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"expr >> expr")),(0,r.kt)("td",{parentName:"tr",align:null},"Right-shift"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Shr"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},">>=")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"var >>= expr")),(0,r.kt)("td",{parentName:"tr",align:null},"Right-shift and assignment"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"ShrAssign"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"@")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"ident @ pat")),(0,r.kt)("td",{parentName:"tr",align:null},"Pattern binding"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"^")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"expr ^ expr")),(0,r.kt)("td",{parentName:"tr",align:null},"Bitwise exclusive OR"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"BitXor"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"^=")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"var ^= expr")),(0,r.kt)("td",{parentName:"tr",align:null},"Bitwise exclusive OR and assignment"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"BitXorAssign"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("code",null,"|")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("code",null,"pat ","|"," pat")),(0,r.kt)("td",{parentName:"tr",align:null},"Pattern alternatives"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("code",null,"|")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("code",null,"expr ","|"," expr")),(0,r.kt)("td",{parentName:"tr",align:null},"Bitwise OR"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"BitOr"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("code",null,"|","=")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("code",null,"var ","|","= expr")),(0,r.kt)("td",{parentName:"tr",align:null},"Bitwise OR and assignment"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"BitOrAssign"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("code",null,"|","|")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("code",null,"expr ","|","|"," expr")),(0,r.kt)("td",{parentName:"tr",align:null},"Short-circuiting logical OR"),(0,r.kt)("td",{parentName:"tr",align:null})),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"?")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"expr?")),(0,r.kt)("td",{parentName:"tr",align:null},"Error propagation"),(0,r.kt)("td",{parentName:"tr",align:null})))),(0,r.kt)("h2",{id:"non-operator-symbols"},"Non-operator Symbols"),(0,r.kt)("p",null,"The following list contains all symbols that don\u2019t function as operators; that\nis, they don\u2019t behave like a function or method call."),(0,r.kt)("p",null,"Table B-2 shows symbols that appear on their own and are valid in a variety of\nlocations."),(0,r.kt)("h3",{id:"table-b-2-stand-alone-syntax"},"Table B-2: Stand-Alone Syntax"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Symbol"),(0,r.kt)("th",{parentName:"tr",align:null},"Explanation"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"'ident")),(0,r.kt)("td",{parentName:"tr",align:null},"Named lifetime or loop label")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"...u8"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"...i32"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"...f64"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"...usize"),", etc."),(0,r.kt)("td",{parentName:"tr",align:null},"Numeric literal of specific type")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'"..."')),(0,r.kt)("td",{parentName:"tr",align:null},"String literal")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'r"..."'),", ",(0,r.kt)("inlineCode",{parentName:"td"},'r#"..."#'),", ",(0,r.kt)("inlineCode",{parentName:"td"},'r##"..."##'),", etc."),(0,r.kt)("td",{parentName:"tr",align:null},"Raw string literal, escape characters not processed")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'b"..."')),(0,r.kt)("td",{parentName:"tr",align:null},"Byte string literal; constructs an array of bytes instead of a string")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'br"..."'),", ",(0,r.kt)("inlineCode",{parentName:"td"},'br#"..."#'),", ",(0,r.kt)("inlineCode",{parentName:"td"},'br##"..."##'),", etc."),(0,r.kt)("td",{parentName:"tr",align:null},"Raw byte string literal, combination of raw and byte string literal")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"'...'")),(0,r.kt)("td",{parentName:"tr",align:null},"Character literal")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"b'...'")),(0,r.kt)("td",{parentName:"tr",align:null},"ASCII byte literal")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("code",null,"|","...","|"," expr")),(0,r.kt)("td",{parentName:"tr",align:null},"Closure")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"!")),(0,r.kt)("td",{parentName:"tr",align:null},"Always empty bottom type for diverging functions")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"_")),(0,r.kt)("td",{parentName:"tr",align:null},'"Ignored" pattern binding; also used to make integer literals readable')))),(0,r.kt)("p",null,"Table B-3 shows symbols that appear in the context of a path through the module\nhierarchy to an item."),(0,r.kt)("h3",{id:"table-b-3-path-related-syntax"},"Table B-3: Path-Related Syntax"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Symbol"),(0,r.kt)("th",{parentName:"tr",align:null},"Explanation"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"ident::ident")),(0,r.kt)("td",{parentName:"tr",align:null},"Namespace path")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"::path")),(0,r.kt)("td",{parentName:"tr",align:null},"Path relative to the crate root (i.e., an explicitly absolute path)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"self::path")),(0,r.kt)("td",{parentName:"tr",align:null},"Path relative to the current module (i.e., an explicitly relative path).")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"super::path")),(0,r.kt)("td",{parentName:"tr",align:null},"Path relative to the parent of the current module")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"type::ident"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"<type as trait>::ident")),(0,r.kt)("td",{parentName:"tr",align:null},"Associated constants, functions, and types")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"<type>::...")),(0,r.kt)("td",{parentName:"tr",align:null},"Associated item for a type that cannot be directly named (e.g., ",(0,r.kt)("inlineCode",{parentName:"td"},"<&T>::..."),", ",(0,r.kt)("inlineCode",{parentName:"td"},"<[T]>::..."),", etc.)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"trait::method(...)")),(0,r.kt)("td",{parentName:"tr",align:null},"Disambiguating a method call by naming the trait that defines it")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"type::method(...)")),(0,r.kt)("td",{parentName:"tr",align:null},"Disambiguating a method call by naming the type for which it\u2019s defined")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"<type as trait>::method(...)")),(0,r.kt)("td",{parentName:"tr",align:null},"Disambiguating a method call by naming the trait and type")))),(0,r.kt)("p",null,"Table B-4 shows symbols that appear in the context of using generic type\nparameters."),(0,r.kt)("h3",{id:"table-b-4-generics"},"Table B-4: Generics"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Symbol"),(0,r.kt)("th",{parentName:"tr",align:null},"Explanation"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"path<...>")),(0,r.kt)("td",{parentName:"tr",align:null},"Specifies parameters to generic type in a type (e.g., ",(0,r.kt)("inlineCode",{parentName:"td"},"Vec<u8>"),")")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"path::<...>"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"method::<...>")),(0,r.kt)("td",{parentName:"tr",align:null},"Specifies parameters to generic type, function, or method in an expression; often referred to as turbofish (e.g., ",(0,r.kt)("inlineCode",{parentName:"td"},'"42".parse::<i32>()'),")")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"fn ident<...> ...")),(0,r.kt)("td",{parentName:"tr",align:null},"Define generic function")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"struct ident<...> ...")),(0,r.kt)("td",{parentName:"tr",align:null},"Define generic structure")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"enum ident<...> ...")),(0,r.kt)("td",{parentName:"tr",align:null},"Define generic enumeration")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"impl<...> ...")),(0,r.kt)("td",{parentName:"tr",align:null},"Define generic implementation")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"for<...> type")),(0,r.kt)("td",{parentName:"tr",align:null},"Higher-ranked lifetime bounds")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"type<ident=type>")),(0,r.kt)("td",{parentName:"tr",align:null},"A generic type where one or more associated types have specific assignments (e.g., ",(0,r.kt)("inlineCode",{parentName:"td"},"Iterator<Item=T>"),")")))),(0,r.kt)("p",null,"Table B-5 shows symbols that appear in the context of constraining generic type\nparameters with trait bounds."),(0,r.kt)("h3",{id:"table-b-5-trait-bound-constraints"},"Table B-5: Trait Bound Constraints"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Symbol"),(0,r.kt)("th",{parentName:"tr",align:null},"Explanation"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T: U")),(0,r.kt)("td",{parentName:"tr",align:null},"Generic parameter ",(0,r.kt)("inlineCode",{parentName:"td"},"T")," constrained to types that implement ",(0,r.kt)("inlineCode",{parentName:"td"},"U"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T: 'a")),(0,r.kt)("td",{parentName:"tr",align:null},"Generic type ",(0,r.kt)("inlineCode",{parentName:"td"},"T")," must outlive lifetime ",(0,r.kt)("inlineCode",{parentName:"td"},"'a")," (meaning the type cannot transitively contain any references with lifetimes shorter than ",(0,r.kt)("inlineCode",{parentName:"td"},"'a"),")")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T: 'static")),(0,r.kt)("td",{parentName:"tr",align:null},"Generic type ",(0,r.kt)("inlineCode",{parentName:"td"},"T")," contains no borrowed references other than ",(0,r.kt)("inlineCode",{parentName:"td"},"'static")," ones")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"'b: 'a")),(0,r.kt)("td",{parentName:"tr",align:null},"Generic lifetime ",(0,r.kt)("inlineCode",{parentName:"td"},"'b")," must outlive lifetime ",(0,r.kt)("inlineCode",{parentName:"td"},"'a"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"T: ?Sized")),(0,r.kt)("td",{parentName:"tr",align:null},"Allow generic type parameter to be a dynamically sized type")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"'a + trait"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"trait + trait")),(0,r.kt)("td",{parentName:"tr",align:null},"Compound type constraint")))),(0,r.kt)("p",null,"Table B-6 shows symbols that appear in the context of calling or defining\nmacros and specifying attributes on an item."),(0,r.kt)("h3",{id:"table-b-6-macros-and-attributes"},"Table B-6: Macros and Attributes"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Symbol"),(0,r.kt)("th",{parentName:"tr",align:null},"Explanation"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"#[meta]")),(0,r.kt)("td",{parentName:"tr",align:null},"Outer attribute")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"#![meta]")),(0,r.kt)("td",{parentName:"tr",align:null},"Inner attribute")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"$ident")),(0,r.kt)("td",{parentName:"tr",align:null},"Macro substitution")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"$ident:kind")),(0,r.kt)("td",{parentName:"tr",align:null},"Macro capture")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"$(\u2026)\u2026")),(0,r.kt)("td",{parentName:"tr",align:null},"Macro repetition")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"ident!(...)"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"ident!{...}"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"ident![...]")),(0,r.kt)("td",{parentName:"tr",align:null},"Macro invocation")))),(0,r.kt)("p",null,"Table B-7 shows symbols that create comments."),(0,r.kt)("h3",{id:"table-b-7-comments"},"Table B-7: Comments"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Symbol"),(0,r.kt)("th",{parentName:"tr",align:null},"Explanation"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"//")),(0,r.kt)("td",{parentName:"tr",align:null},"Line comment")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"//!")),(0,r.kt)("td",{parentName:"tr",align:null},"Inner line doc comment")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"///")),(0,r.kt)("td",{parentName:"tr",align:null},"Outer line doc comment")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"/*...*/")),(0,r.kt)("td",{parentName:"tr",align:null},"Block comment")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"/*!...*/")),(0,r.kt)("td",{parentName:"tr",align:null},"Inner block doc comment")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"/**...*/")),(0,r.kt)("td",{parentName:"tr",align:null},"Outer block doc comment")))),(0,r.kt)("p",null,"Table B-8 shows symbols that appear in the context of using tuples."),(0,r.kt)("h3",{id:"table-b-8-tuples"},"Table B-8: Tuples"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Symbol"),(0,r.kt)("th",{parentName:"tr",align:null},"Explanation"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"()")),(0,r.kt)("td",{parentName:"tr",align:null},"Empty tuple (aka unit), both literal and type")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(expr)")),(0,r.kt)("td",{parentName:"tr",align:null},"Parenthesized expression")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(expr,)")),(0,r.kt)("td",{parentName:"tr",align:null},"Single-element tuple expression")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(type,)")),(0,r.kt)("td",{parentName:"tr",align:null},"Single-element tuple type")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(expr, ...)")),(0,r.kt)("td",{parentName:"tr",align:null},"Tuple expression")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(type, ...)")),(0,r.kt)("td",{parentName:"tr",align:null},"Tuple type")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"expr(expr, ...)")),(0,r.kt)("td",{parentName:"tr",align:null},"Function call expression; also used to initialize tuple ",(0,r.kt)("inlineCode",{parentName:"td"},"struct"),"s and tuple ",(0,r.kt)("inlineCode",{parentName:"td"},"enum")," variants")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"expr.0"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"expr.1"),", etc."),(0,r.kt)("td",{parentName:"tr",align:null},"Tuple indexing")))),(0,r.kt)("p",null,"Table B-9 shows the contexts in which curly braces are used."),(0,r.kt)("h3",{id:"table-b-9-curly-brackets"},"Table B-9: Curly Brackets"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Context"),(0,r.kt)("th",{parentName:"tr",align:null},"Explanation"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"{...}")),(0,r.kt)("td",{parentName:"tr",align:null},"Block expression")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"Type {...}")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"struct")," literal")))),(0,r.kt)("p",null,"Table B-10 shows the contexts in which square brackets are used."),(0,r.kt)("h3",{id:"table-b-10-square-brackets"},"Table B-10: Square Brackets"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Context"),(0,r.kt)("th",{parentName:"tr",align:null},"Explanation"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"[...]")),(0,r.kt)("td",{parentName:"tr",align:null},"Array literal")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"[expr; len]")),(0,r.kt)("td",{parentName:"tr",align:null},"Array literal containing ",(0,r.kt)("inlineCode",{parentName:"td"},"len")," copies of ",(0,r.kt)("inlineCode",{parentName:"td"},"expr"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"[type; len]")),(0,r.kt)("td",{parentName:"tr",align:null},"Array type containing ",(0,r.kt)("inlineCode",{parentName:"td"},"len")," instances of ",(0,r.kt)("inlineCode",{parentName:"td"},"type"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"expr[expr]")),(0,r.kt)("td",{parentName:"tr",align:null},"Collection indexing. Overloadable (",(0,r.kt)("inlineCode",{parentName:"td"},"Index"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"IndexMut"),")")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"expr[..]"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"expr[a..]"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"expr[..b]"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"expr[a..b]")),(0,r.kt)("td",{parentName:"tr",align:null},"Collection indexing pretending to be collection slicing, using ",(0,r.kt)("inlineCode",{parentName:"td"},"Range"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"RangeFrom"),", ",(0,r.kt)("inlineCode",{parentName:"td"},"RangeTo"),", or ",(0,r.kt)("inlineCode",{parentName:"td"},"RangeFull"),' as the "index"')))))}N.isMDXComponent=!0}}]);