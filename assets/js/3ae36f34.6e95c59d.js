"use strict";(self.webpackChunkrust_book_abridged=self.webpackChunkrust_book_abridged||[]).push([[164],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>u});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},h="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),h=p(n),m=o,u=h["".concat(l,".").concat(m)]||h[m]||c[m]||i;return n?a.createElement(u,r(r({ref:t},d),{},{components:n})):a.createElement(u,r({ref:t},d))}));function u(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[h]="string"==typeof e?e:o,r[1]=s;for(var p=2;p<i;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},3067:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var a=n(7462),o=(n(7294),n(3905));const i={},r="17 - Object Oriented Features of Rust",s={unversionedId:"ch17-object-oriented-features",id:"ch17-object-oriented-features",title:"17 - Object Oriented Features of Rust",description:"17.1 - Characteristics of Object Oriented Languages",source:"@site/docs/ch17-object-oriented-features.md",sourceDirName:".",slug:"/ch17-object-oriented-features",permalink:"/rust-book-abridged/ch17-object-oriented-features",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ch17-object-oriented-features.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"16 - Fearless Concurrency",permalink:"/rust-book-abridged/ch16-fearless-concurrency"},next:{title:"18 - Patterns and Matching",permalink:"/rust-book-abridged/ch18-patterns-and-matching"}},l={},p=[{value:"17.1 - Characteristics of Object Oriented Languages",id:"171---characteristics-of-object-oriented-languages",level:2},{value:"17.2 - Using Trait Objects That Allow for Values of Different Types",id:"172---using-trait-objects-that-allow-for-values-of-different-types",level:2},{value:"Defining a Trait for Common Behavior",id:"defining-a-trait-for-common-behavior",level:3},{value:"Trait Objects Perform Dynamic Dispatch",id:"trait-objects-perform-dynamic-dispatch",level:3},{value:"17.3 - Implementing an Object-Oriented Design Pattern",id:"173---implementing-an-object-oriented-design-pattern",level:2},{value:"Trade-offs of the State Pattern",id:"trade-offs-of-the-state-pattern",level:3},{value:"Encoding States and Behavior as Types",id:"encoding-states-and-behavior-as-types",level:3}],d={toc:p},h="wrapper";function c(e){let{components:t,...n}=e;return(0,o.kt)(h,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"17---object-oriented-features-of-rust"},"17 - Object Oriented Features of Rust"),(0,o.kt)("h2",{id:"171---characteristics-of-object-oriented-languages"},"17.1 - Characteristics of Object Oriented Languages"),(0,o.kt)("p",null,"What makes an Object Oriented language? There are many different definitions, but generally an OO language has the following concepts:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"objects")," package code (methods) together with data."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"encapsulation")," means that some of the methods and data on an object are private, and some are public. The internal implementation of an object can change without the public API or any users of that object changing."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"inheritance")," allows one object to inherit data and methods from a parent object or class."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("em",{parentName:"li"},"polymorphism")," allows two objects with the same public API to be used in place of each other.")),(0,o.kt)("p",null,"It's easy to see how Rust borrows from these concepts and can be used as an OO language. ",(0,o.kt)("inlineCode",{parentName:"p"},"struct"),"s in Rust have data and can have methods defined on them and so are similar to objects. Members and methods of a ",(0,o.kt)("inlineCode",{parentName:"p"},"struct")," can be ",(0,o.kt)("inlineCode",{parentName:"p"},"pub")," or private (privacy in Rust is a little different than in other OO languages, but that's something that can be said of many OO languages)."),(0,o.kt)("p",null,"Rust doesn't really have inheritance. But inheritance has fallen out of style in modern software design, often being replaced with composition instead, and traits allow us to provide default implementations for methods which allows a lot of the same sort of code reuse that inheritance traditionally gives us."),(0,o.kt)("p",null,"Using traits we can easily implement polymorphism in Rust, and we've already seen some examples of this; the ",(0,o.kt)("inlineCode",{parentName:"p"},"Iterator")," trait allows us to pass any number of different types of objects to a ",(0,o.kt)("inlineCode",{parentName:"p"},"for")," loop, for example. ",(0,o.kt)("em",{parentName:"p"},"Trait objects")," let us take this a step further."),(0,o.kt)("h2",{id:"172---using-trait-objects-that-allow-for-values-of-different-types"},"17.2 - Using Trait Objects That Allow for Values of Different Types"),(0,o.kt)("p",null,"In ",(0,o.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch08-common-collections",title:"Chapter 8: Common Collections"},"chapter 8")," we mentioned that a vector can only hold one type. We showed a workaround where we stored a ",(0,o.kt)("inlineCode",{parentName:"p"},"SpreadsheetCell"),' enum in a vector, and then used different variants of the enum to store different types. But let\'s suppose we were implementing a GUI library. We might want a vector of "components" we need to draw on the screen - buttons, select boxes, links, etc... We could use the ',(0,o.kt)("inlineCode",{parentName:"p"},"enum")," trick here to represent all these different component types, but a common feature of GUI libraries is letting users define their own custom components. We can't possibly know all the custom component types ahead of time, so here an enum is going to let us down."),(0,o.kt)("p",null,"To do this in a class based language we might define a ",(0,o.kt)("inlineCode",{parentName:"p"},"Component")," abstract class with a ",(0,o.kt)("inlineCode",{parentName:"p"},"draw")," method, and then various subclasses of ",(0,o.kt)("inlineCode",{parentName:"p"},"Component")," could implement ",(0,o.kt)("inlineCode",{parentName:"p"},"draw")," differently. In Rust we don't have inheritance, so to do this we'll have to use traits."),(0,o.kt)("h3",{id:"defining-a-trait-for-common-behavior"},"Defining a Trait for Common Behavior"),(0,o.kt)("p",null,"At runtime, a trait object will be a pair of pointers in memory - one to the instance of a specific type that implements our trait, and another to a table of methods defined on the trait to call at runtime (similar to a v-table in C++). We create a trait object by specifying a pointer (this could be a simple reference or a smart pointer like a ",(0,o.kt)("inlineCode",{parentName:"p"},"Box<T>"),") and the ",(0,o.kt)("inlineCode",{parentName:"p"},"dyn"),' keyword (for "dynamic"). In ',(0,o.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch19/ch19-01-unsafe",title:"Chapter 19: Advanced Features"},"chapter 19")," we'll talk about the ",(0,o.kt)("inlineCode",{parentName:"p"},"Sized")," trait, and why a pointer is required here."),(0,o.kt)("p",null,"Fo our GUI library, we'll create a ",(0,o.kt)("inlineCode",{parentName:"p"},"Draw")," trait, with a single method called ",(0,o.kt)("inlineCode",{parentName:"p"},"draw"),". Instead of storing a vector of buttons or a vector of dialogs, we'll store a vector of ",(0,o.kt)("em",{parentName:"p"},"trait objects"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/lib.rs"',title:'"src/lib.rs"'},"pub trait Draw {\n    fn draw(&self);\n}\n\npub struct Screen {\n    pub components: Vec<Box<dyn Draw>>,\n}\n\nimpl Screen {\n    pub fn run(&self) {\n        for component in self.components.iter() {\n            component.draw();\n        }\n    }\n}\n\npub struct Button {\n    pub width: u32,\n    pub height: u32,\n    pub label: String,\n}\n\nimpl Draw for Button {\n    fn draw(&self) {\n        // code to actually draw a button\n    }\n}\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Draw")," trait should look familiar - if you skipped ahead in this book and this syntax looks unfamiliar, then see ",(0,o.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch10/ch10-01-generic-data-types",title:"Chapter 10: Generic Types, Traits, and Lifetimes"},"chapter 10"),"."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Screen")," struct has a ",(0,o.kt)("inlineCode",{parentName:"p"},"components")," which has some new syntax: it is a vector of ",(0,o.kt)("inlineCode",{parentName:"p"},"Box<dyn Draw>"),", or in other words a vector of trait objects that implement the ",(0,o.kt)("inlineCode",{parentName:"p"},"Draw")," trait. ",(0,o.kt)("inlineCode",{parentName:"p"},"Box<dyn Draw>")," is a stand-in for any type inside a ",(0,o.kt)("inlineCode",{parentName:"p"},"Box")," that implements ",(0,o.kt)("inlineCode",{parentName:"p"},"Draw"),". ",(0,o.kt)("inlineCode",{parentName:"p"},"Screen")," also has a ",(0,o.kt)("inlineCode",{parentName:"p"},"run")," method which calls the draw method on each member of ",(0,o.kt)("inlineCode",{parentName:"p"},"components"),"."),(0,o.kt)("p",null,"It's important to note that a trait object is very different from a trait bound. If we'd implemented Screen as a generic type with a trait bound:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"// Generic version with trait bounds won't work.\npub struct Screen<T: Draw> {\n    pub components: Vec<T>,\n}\n\nimpl<T> Screen<T>\nwhere\n    T: Draw,\n{\n    pub fn run(&self) {\n        for component in self.components.iter() {\n            component.draw();\n        }\n    }\n}\n")),(0,o.kt)("p",null,"then we could create a ",(0,o.kt)("inlineCode",{parentName:"p"},"Screen<Button>")," or a ",(0,o.kt)("inlineCode",{parentName:"p"},"Screen<SelectBox>"),", but any such screen would only be allowed to draw a single type. A screen that is only allowed to show buttons is not a very useful screen! By using a trait object here, we can have a collection of different types, and we don't have to know all the possible implementations at compile time. (Although, note that if you need a collection all of the same type, then this solution would be preferable as we can work out how to call ",(0,o.kt)("inlineCode",{parentName:"p"},"draw")," on a concrete type at compile time instead of having to do this at runtime.)"),(0,o.kt)("p",null,"We also added a ",(0,o.kt)("inlineCode",{parentName:"p"},"Button")," type to our library that implements the ",(0,o.kt)("inlineCode",{parentName:"p"},"Draw")," trait. If this were a real library it would probably implement more than just a Button, but that's enough for this example."),(0,o.kt)("p",null,"Let's look at a crate that uses this library in ",(0,o.kt)("em",{parentName:"p"},"src/main.rs"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},'use gui::{Button, Screen};\n\n// Define a custom SelectBox component, not\n// in the gui library.\nstruct SelectBox {\n    width: u32,\n    height: u32,\n    options: Vec<String>,\n}\n\nimpl Draw for SelectBox {\n    fn draw(&self) {\n        // code to actually draw a select box\n    }\n}\n\nfn main() {\n    let screen = Screen {\n        components: vec![\n            Box::new(SelectBox {\n                width: 75,\n                height: 10,\n                options: vec![\n                    String::from("Yes"),\n                    String::from("Maybe"),\n                    String::from("No"),\n                ],\n            }),\n            Box::new(Button {\n                width: 50,\n                height: 10,\n                label: String::from("OK"),\n            }),\n        ],\n    };\n\n    screen.run();\n}\n')),(0,o.kt)("p",null,"The user of our library has defined their own custom ",(0,o.kt)("inlineCode",{parentName:"p"},"SelectBox")," component, and created a ",(0,o.kt)("inlineCode",{parentName:"p"},"Screen")," with a ",(0,o.kt)("inlineCode",{parentName:"p"},"SelectBox")," and a ",(0,o.kt)("inlineCode",{parentName:"p"},"Button"),"."),(0,o.kt)("h3",{id:"trait-objects-perform-dynamic-dispatch"},"Trait Objects Perform Dynamic Dispatch"),(0,o.kt)("p",null,"When we call into ",(0,o.kt)("inlineCode",{parentName:"p"},"component.draw()")," in ",(0,o.kt)("inlineCode",{parentName:"p"},"Screen"),", what actually happens at runtime is called ",(0,o.kt)("em",{parentName:"p"},"dynamic dispatch"),". We have a pointer to the memory for the struct, and a pointer to a table of methods (in this case, just ",(0,o.kt)("inlineCode",{parentName:"p"},"draw"),"). For each trait object in the ",(0,o.kt)("inlineCode",{parentName:"p"},"components")," list, we're going to use that table to figure out the correct ",(0,o.kt)("inlineCode",{parentName:"p"},"draw")," function to call at runtime, which will depend on the underlying concrete type."),(0,o.kt)("p",null,"It's important to realize that this is very different from this example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'let button = Button {\n    width: 50,\n    height: 10,\n    label: String::from("OK"),\n};\n\nbutton.draw();\n')),(0,o.kt)("p",null,"Here, the compiler knows that ",(0,o.kt)("inlineCode",{parentName:"p"},"button")," is of type ",(0,o.kt)("inlineCode",{parentName:"p"},"Button"),", and can work out which ",(0,o.kt)("inlineCode",{parentName:"p"},"draw")," function to call at compile time. This is called ",(0,o.kt)("em",{parentName:"p"},"static dispatch"),"."),(0,o.kt)("p",null,"There's a small performance impact to dynamic dispatch, since we have this extra pointer to follow at runtime. Also, in the static dispatch case we can do performance optimizations like inlining which are not available in the dynamic dispatch case."),(0,o.kt)("h2",{id:"173---implementing-an-object-oriented-design-pattern"},"17.3 - Implementing an Object-Oriented Design Pattern"),(0,o.kt)("p",null,'In this section we\'re going to implement a simple blogging server. A post on the server can be in one of three states: when first created a post will be a "draft". Once the user is done creating the draft, they can ask for a review which will move the post to the "review" state. Finally once reviewed, the post will move to the "published" state. We want to make sure the text for a post isn\'t published to our blog site until the post is in the published state.'),(0,o.kt)("p",null,"This is a pretty simple example, and I'm sure you could easily imagine implementing this with a state enum and some methods on the Post, but since this is a chapter about OO design, we'll represent the state of the post using the ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/State_pattern"},"state pattern"),", one of the original twenty-three design patterns documented by the ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Design_Patterns"},"Gang of Four"),". (We're going to actually implement this twice - once using the OO pattern, and once in a way that's a bit more natural for Rust.) You can find the finished code for this example in ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/jwalton/rust-book-abridged/tree/master/examples/ch17-post-state-pattern"},"this book's github repo"),"."),(0,o.kt)("p",null,"As ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/State_pattern"},"Wikipedia")," puts it:"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"The state pattern is set to solve two main problems:"),(0,o.kt)("ul",{parentName:"blockquote"},(0,o.kt)("li",{parentName:"ul"},"An object should change its behavior when its internal state changes."),(0,o.kt)("li",{parentName:"ul"},"State-specific behavior should be defined independently. That is, adding new states should not affect the behavior of existing states."))),(0,o.kt)("p",null,"In ",(0,o.kt)("em",{parentName:"p"},"src/lib.rs"),", let's write a quick unit test to walk through what our API and workflow will look like:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/lib.rs"',title:'"src/lib.rs"'},'#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn post_workflow() {\n        let mut post = Post::new();\n\n        post.add_text("I ate a salad for lunch today");\n        assert_eq!("", post.content());\n\n        post.request_review();\n        assert_eq!("", post.content());\n\n        post.approve();\n        assert_eq!("I ate a salad for lunch today", post.content());\n    }\n}\n')),(0,o.kt)("p",null,"Notice that our public API doesn't know anything about our state pattern. The idea here will be that ",(0,o.kt)("inlineCode",{parentName:"p"},"Post")," has a ",(0,o.kt)("inlineCode",{parentName:"p"},"state")," which will be a state object. There will be a ",(0,o.kt)("inlineCode",{parentName:"p"},"Draft")," struct, a ",(0,o.kt)("inlineCode",{parentName:"p"},"PendingReview")," struct, and a ",(0,o.kt)("inlineCode",{parentName:"p"},"Published")," struct that represent our different states and all are going to implement the ",(0,o.kt)("inlineCode",{parentName:"p"},"State")," trait. When you call into a method on ",(0,o.kt)("inlineCode",{parentName:"p"},"Post")," like ",(0,o.kt)("inlineCode",{parentName:"p"},"post.request_review()"),", this method will delegate to the current state by doing roughly the equivalent of ",(0,o.kt)("inlineCode",{parentName:"p"},"this.state = this.state.request_review()"),", so the state can control what the next state will be."),(0,o.kt)("p",null,"Here's the implementation of ",(0,o.kt)("inlineCode",{parentName:"p"},"Post"),", also in ",(0,o.kt)("em",{parentName:"p"},"src/lib.rs"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/lib.rs"',title:'"src/lib.rs"'},"pub struct Post {\n    state: Option<Box<dyn State>>,\n    content: String,\n}\n\ntrait State {\n    fn request_review(self: Box<Self>) -> Box<dyn State>;\n    fn approve(self: Box<Self>) -> Box<dyn State>;\n    fn content<'a>(&self, _post: &'a Post) -> &'a str {\n        \"\"\n    }\n}\n\nimpl Post {\n    pub fn new() -> Post {\n        Post {\n            state: Some(Box::new(Draft {})),\n            content: String::new(),\n        }\n    }\n\n    pub fn add_text(&mut self, text: &str) {\n        self.content.push_str(text);\n    }\n\n    pub fn request_review(&mut self) {\n        if let Some(s) = self.state.take() {\n            self.state = Some(s.request_review())\n        }\n    }\n\n    pub fn approve(&mut self) {\n        if let Some(s) = self.state.take() {\n            self.state = Some(s.approve())\n        }\n    }\n\n    pub fn content(&self) -> &str {\n        self.state.as_ref().unwrap().content(self)\n    }\n}\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"State")," trait has ",(0,o.kt)("inlineCode",{parentName:"p"},"request_review"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"approve"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"content")," methods. State has a default implementation of ",(0,o.kt)("inlineCode",{parentName:"p"},"content"),", so not all the implementors have to reimplement it, but the other methods will need to be implemented by each ",(0,o.kt)("inlineCode",{parentName:"p"},"State")," individually. The ",(0,o.kt)("inlineCode",{parentName:"p"},"request_review")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"approve")," methods on ",(0,o.kt)("inlineCode",{parentName:"p"},"State")," take a ",(0,o.kt)("inlineCode",{parentName:"p"},"self: Box<Self>")," as their first parameter. This means this method will only be available on a ",(0,o.kt)("inlineCode",{parentName:"p"},"Box<T>")," holding the type. This also takes ownership of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Box"),", effectively invalidating the previous state."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Post")," has some state and some content, both of which are private. We could have made ",(0,o.kt)("inlineCode",{parentName:"p"},"content")," public, but we want to make the content of a ",(0,o.kt)("inlineCode",{parentName:"p"},"Post")," hidden until the post is in the published state, so we created a ",(0,o.kt)("inlineCode",{parentName:"p"},"content")," getter method which delegates to the current state."),(0,o.kt)("p",null,"Post's constructor creates a new ",(0,o.kt)("inlineCode",{parentName:"p"},"Draft")," state, since this is the state we want to start out in. Since the ",(0,o.kt)("inlineCode",{parentName:"p"},"state")," field is private, we can't create a Post in any other state. Post's state is an optional trait object of type ",(0,o.kt)("inlineCode",{parentName:"p"},"Option<Box<dyn State>>"),". We'll talk about why it's an ",(0,o.kt)("inlineCode",{parentName:"p"},"Option")," in just a second."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"add_text")," method takes a mutable reference to self, since it modifies the content of the post. Notice it doesn't interact with the state at all, because no matter what state a post is in, we want to be able to add text. All the other methods on ",(0,o.kt)("inlineCode",{parentName:"p"},"Post")," delegate to the current state. The ",(0,o.kt)("inlineCode",{parentName:"p"},"request_review")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"approve")," methods look very similar - they call into the current state to get the new state, and set self.state. But... they're also a little wordy:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    pub fn request_review(&mut self) {\n        if let Some(s) = self.state.take() {\n            self.state = Some(s.request_review())\n        }\n    }\n")),(0,o.kt)("p",null,"Why not just ",(0,o.kt)("inlineCode",{parentName:"p"},"self.state = self.state.request_review()")," here? The problem here is that ",(0,o.kt)("inlineCode",{parentName:"p"},"self.state.request_review()")," would try to take ownership of ",(0,o.kt)("inlineCode",{parentName:"p"},"self.state"),", but you can't take ownership of a ",(0,o.kt)("em",{parentName:"p"},"part")," of a struct (at least, not without invalidating the struct). To get around this we make ",(0,o.kt)("inlineCode",{parentName:"p"},"self.state")," an ",(0,o.kt)("inlineCode",{parentName:"p"},"Option"),", and then ",(0,o.kt)("inlineCode",{parentName:"p"},"self.state.take()")," will take ownership of the value in the ",(0,o.kt)("inlineCode",{parentName:"p"},"Option")," and replace it with ",(0,o.kt)("inlineCode",{parentName:"p"},"None")," temporarily. Since after the ",(0,o.kt)("inlineCode",{parentName:"p"},"take")," we immediately reassign it, it's never ",(0,o.kt)("inlineCode",{parentName:"p"},"None")," for more than an instant."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"content")," method also needs to deal with the fact that ",(0,o.kt)("inlineCode",{parentName:"p"},"self.state")," is an ",(0,o.kt)("inlineCode",{parentName:"p"},"Option"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"    pub fn content(&self) -> &str {\n        self.state.as_ref().unwrap().content(self)\n    }\n")),(0,o.kt)("p",null,"We call ",(0,o.kt)("inlineCode",{parentName:"p"},"as_ref")," on the Option to convert the owned value into a ref, because we don't want to take ownership of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Box<dyn state>")," in the ",(0,o.kt)("inlineCode",{parentName:"p"},"Option"),". (",(0,o.kt)("inlineCode",{parentName:"p"},"self.state")," is an immutable reference, so we can't take ownership of the value inside the ",(0,o.kt)("inlineCode",{parentName:"p"},"Option")," even if we wanted to, since ",(0,o.kt)("inlineCode",{parentName:"p"},"self"),", and by extension ",(0,o.kt)("inlineCode",{parentName:"p"},"self.option")," are both immutable in this context.) We call ",(0,o.kt)("inlineCode",{parentName:"p"},"unwrap()")," because we know that ",(0,o.kt)("inlineCode",{parentName:"p"},"self.state")," will always contain a value. This is one of those examples of us knowing more than the compiler - we know ",(0,o.kt)("inlineCode",{parentName:"p"},"self.state")," wil never be ",(0,o.kt)("inlineCode",{parentName:"p"},"None")," here, so we can just panic instead of trying to deal with the case where it's ",(0,o.kt)("inlineCode",{parentName:"p"},"None"),". After the ",(0,o.kt)("inlineCode",{parentName:"p"},"unwrap")," we have a ",(0,o.kt)("inlineCode",{parentName:"p"},"&Box<dyn State>"),", so deref coercion will take place until we ultimately call ",(0,o.kt)("inlineCode",{parentName:"p"},"content")," on the current State's implementation."),(0,o.kt)("p",null,"Let's have a look at the ",(0,o.kt)("inlineCode",{parentName:"p"},"Draft")," state:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/lib.rs"',title:'"src/lib.rs"'},"struct Draft {}\n\nimpl State for Draft {\n    fn request_review(self: Box<Self>) -> Box<dyn State> {\n        Box::new(PendingReview {})\n    }\n\n    fn approve(self: Box<Self>) -> Box<dyn State> {\n        self\n    }\n}\n")),(0,o.kt)("p",null,"Calling ",(0,o.kt)("inlineCode",{parentName:"p"},"request_review")," returns a new ",(0,o.kt)("inlineCode",{parentName:"p"},"PendingReview")," state, effectively advancing us to some new state. Calling ",(0,o.kt)("inlineCode",{parentName:"p"},"approve")," just returns ",(0,o.kt)("inlineCode",{parentName:"p"},"self"),". No one should be trying to approve a ",(0,o.kt)("inlineCode",{parentName:"p"},"Post")," in the ",(0,o.kt)("inlineCode",{parentName:"p"},"Draft")," state, but if they do we want to just leave ourselves in the ",(0,o.kt)("inlineCode",{parentName:"p"},"Draft")," state."),(0,o.kt)("p",null,"Here are our final two states:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/lib.rs"',title:'"src/lib.rs"'},"struct PendingReview {}\n\nimpl State for PendingReview {\n    fn request_review(self: Box<Self>) -> Box<dyn State> {\n        self\n    }\n\n    fn approve(self: Box<Self>) -> Box<dyn State> {\n        Box::new(Published {})\n    }\n}\n\nstruct Published {}\n\nimpl State for Published {\n    fn request_review(self: Box<Self>) -> Box<dyn State> {\n        self\n    }\n\n    fn approve(self: Box<Self>) -> Box<dyn State> {\n        self\n    }\n\n    fn content<'a>(&self, post: &'a Post) -> &'a str {\n        &post.content\n    }\n}\n")),(0,o.kt)("p",null,"The only thing interesting here is that ",(0,o.kt)("inlineCode",{parentName:"p"},"Published")," overrides the default implementation of the ",(0,o.kt)("inlineCode",{parentName:"p"},"content")," method. We need lifetime annotations on this method, since the returned reference will only be valid as long as the passed in ",(0,o.kt)("inlineCode",{parentName:"p"},"Post"),"."),(0,o.kt)("h3",{id:"trade-offs-of-the-state-pattern"},"Trade-offs of the State Pattern"),(0,o.kt)("p",null,"This program certainly met the conditions we set out when attempting to use the state pattern. Behavior is controlled by each state, and we could add a new state without modifying the ",(0,o.kt)("inlineCode",{parentName:"p"},"Post")," object at all. States are dependant on each other - the ",(0,o.kt)("inlineCode",{parentName:"p"},"PendingReview")," state creates a ",(0,o.kt)("inlineCode",{parentName:"p"},"Published")," state, for example - but this isn't terrible."),(0,o.kt)("p",null,"If we were to implement this instead with an ",(0,o.kt)("inlineCode",{parentName:"p"},"enum")," for state and match statements in each of the methods on ",(0,o.kt)("inlineCode",{parentName:"p"},"Post"),', it would be quite manageable for this small example with only three states, but it does mean we\'d have to look in many different places to understand what being in the "published" state actually means, and adding a new state would involve updating potentially many different match expressions.'),(0,o.kt)("p",null,'Here are a few exercises that were suggested from the original "The Rust Programming Language":'),(0,o.kt)("blockquote",null,(0,o.kt)("ul",{parentName:"blockquote"},(0,o.kt)("li",{parentName:"ul"},"Add a reject method that changes the post's state from PendingReview back to Draft."),(0,o.kt)("li",{parentName:"ul"},"Require two calls to approve before the state can be changed to Published."),(0,o.kt)("li",{parentName:"ul"},"Allow users to add text content only when a post is in the Draft state. Hint: have the state object responsible for what might change about the content but not responsible for modifying the Post."))),(0,o.kt)("p",null,"One downside here is that we have a lot of duplicated logic. The ",(0,o.kt)("inlineCode",{parentName:"p"},"request_review")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"approve")," methods on ",(0,o.kt)("inlineCode",{parentName:"p"},"post")," look almost identical to each other. These methods on the ",(0,o.kt)("inlineCode",{parentName:"p"},"State")," implementors often just return ",(0,o.kt)("inlineCode",{parentName:"p"},"self"),", and it would be nice to add default methods for these to the trait, but unfortunately we can't because the return value of a method needs to know the size of what it is returning, and in the trait we don't know what size the concrete implementation of ",(0,o.kt)("inlineCode",{parentName:"p"},"State")," will be. Once solution here might be to define a macro (see ",(0,o.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch19/ch19-01-unsafe",title:"Chapter 19: Advanced Features"},"chapter 19"),") to reduce the code repetition here."),(0,o.kt)("p",null,"The fact that ",(0,o.kt)("inlineCode",{parentName:"p"},"Post.state")," needs to be wrapped in an ",(0,o.kt)("inlineCode",{parentName:"p"},"Option")," makes parts of this implementation feel clumsy and unergonomic."),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"One way you might think to try to improve this code is to change the signature of the ",(0,o.kt)("inlineCode",{parentName:"p"},"request_review")," method in the State trait to accept a mutable reference to ",(0,o.kt)("inlineCode",{parentName:"p"},"Post"),":"),(0,o.kt)("pre",{parentName:"admonition"},(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"trait State {\n    fn request_review(&self, _post: &mut Post) {}\n    fn approve(&self, _post: &mut Post) {}\n    fn content<'a>(&self, _post: &'a Post) -> &'a str {\n        \"\"\n    }\n}\n")),(0,o.kt)("p",{parentName:"admonition"},"We can just assign ",(0,o.kt)("inlineCode",{parentName:"p"},"post.self")," inside ",(0,o.kt)("inlineCode",{parentName:"p"},"approve")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"request_review")," on the ",(0,o.kt)("inlineCode",{parentName:"p"},"State")," objects. Then we could convert ",(0,o.kt)("inlineCode",{parentName:"p"},"Post.state")," into a ",(0,o.kt)("inlineCode",{parentName:"p"},"Box<dyn State>")," and get rid of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Option")," which should simplify this a lot."),(0,o.kt)("p",{parentName:"admonition"},"I encourage you to give this a try, but you may find ownership rules will make this more complicated than you think it will be.")),(0,o.kt)("h3",{id:"encoding-states-and-behavior-as-types"},"Encoding States and Behavior as Types"),(0,o.kt)("p",null,"Let's take a look at another way of implementing the same behavior, but we're not going to implement it in exactly the same way we would in a traditional OO language. We're going to instead try to encode our state and associated behavior as explicit types. You can find the finished code for this example in ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/jwalton/rust-book-abridged/tree/master/examples/ch17-post-state-types"},"this book's github repo"),". First let's create a ",(0,o.kt)("inlineCode",{parentName:"p"},"Post")," and a ",(0,o.kt)("inlineCode",{parentName:"p"},"DraftPost"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/lib.rs"',title:'"src/lib.rs"'},"pub struct Post {\n    content: String,\n}\n\npub struct DraftPost {\n    content: String,\n}\n\nimpl Post {\n    pub fn new() -> DraftPost {\n        DraftPost {\n            content: String::new(),\n        }\n    }\n\n    pub fn content(&self) -> &str {\n        &self.content\n    }\n}\n\nimpl DraftPost {\n    pub fn add_text(&mut self, text: &str) {\n        self.content.push_str(text);\n    }\n}\n")),(0,o.kt)("p",null,"We can still call ",(0,o.kt)("inlineCode",{parentName:"p"},"Post::new"),", but this now returns a new ",(0,o.kt)("inlineCode",{parentName:"p"},"DraftPost")," type. ",(0,o.kt)("inlineCode",{parentName:"p"},"DraftPost")," doesn't even implement ",(0,o.kt)("inlineCode",{parentName:"p"},"content"),", so we can't even ask for the content of a ",(0,o.kt)("inlineCode",{parentName:"p"},"DraftPost")," without generating a compile time error. This is an example of \"making invalid state unrepresentable\" - we don't want to let you get the content of a draft post, and now it's impossible to even write the code that would do such a thing. We want to be able to request a review on our ",(0,o.kt)("inlineCode",{parentName:"p"},"DraftPost"),", so let's add a method for that:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/lib.rs"',title:'"src/lib.rs"'},"// --snip--\n\nimpl DraftPost {\n    // --snip--\n\n    pub fn request_review(self) -> PendingReviewPost {\n        PendingReviewPost {\n            content: self.content,\n        }\n    }\n}\n\npub struct PendingReviewPost {\n    content: String,\n}\n\nimpl PendingReviewPost {\n    pub fn approve(self) -> Post {\n        Post {\n            content: self.content,\n        }\n    }\n}\n")),(0,o.kt)("p",null,"Now we have our three states - ",(0,o.kt)("inlineCode",{parentName:"p"},"DraftPost"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"PendingReviewPost"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"Post")," - encoded as types. The ",(0,o.kt)("inlineCode",{parentName:"p"},"request_review")," method on ",(0,o.kt)("inlineCode",{parentName:"p"},"DraftPost")," takes ownership of ",(0,o.kt)("inlineCode",{parentName:"p"},"self"),". After calling it, the ",(0,o.kt)("inlineCode",{parentName:"p"},"DraftPost")," will be dropped. This means this method converts a ",(0,o.kt)("inlineCode",{parentName:"p"},"DraftPost")," into a ",(0,o.kt)("inlineCode",{parentName:"p"},"PendingReviewPost"),", and there's no way for us to have any lingering ",(0,o.kt)("inlineCode",{parentName:"p"},"DraftPost")," left over. Importantly this means there's no way to accidentally request two reviews for the same draft post without getting a compiler error. Also, the only way to get the content of a post is to have the full ",(0,o.kt)("inlineCode",{parentName:"p"},"Post")," object, and the only way to get such an object is to call ",(0,o.kt)("inlineCode",{parentName:"p"},"approve")," on a ",(0,o.kt)("inlineCode",{parentName:"p"},"PendingReviewPost"),", so we know we can never get access to the content of a post if it hasn't been approved. All of our behavior is encoded into these types."),(0,o.kt)("p",null,"We can write a test case to see this in action:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/lib.rs"',title:'"src/lib.rs"'},'#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn post_workflow() {\n        let mut post = Post::new();\n\n        post.add_text("I ate a salad for lunch today");\n\n        let post = post.request_review();\n\n        let post = post.approve();\n        assert_eq!("I ate a salad for lunch today", post.content());\n    }\n}\n')),(0,o.kt)("p",null,"This isn't better in every way than the previous example, rather there are trade offs here that are different. In this test case, you can see that whenever a post changes state, we have used variable shadowing to create a new variable with a new type. If we change our internal implementation so that ",(0,o.kt)("inlineCode",{parentName:"p"},"add_text"),' transitioned to a new state, then the caller here would break, so our implementation is not nearly as encapsulated as it was before. It\'s also a little more challenging in this model to create a vector of "posts" - we\'d have to wrap these different post states in an enum or in some common trait and use a trait object to store them in a vector together, and both of those would "undo" some of the benefits we\'ve just outlined in different ways.'),(0,o.kt)("p",null,"Which of these tradeoffs you make are going to depend heavily on what you're trying to implement, but hopefully this chapter has given you some new tools to use to approach different problems."),(0,o.kt)("p",null,"Continue to ",(0,o.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch18-patterns-and-matching",title:"Chapter 18: Patterns and Matching"},"chapter 18"),"."))}c.isMDXComponent=!0}}]);