"use strict";(self.webpackChunkrust_book_abridged=self.webpackChunkrust_book_abridged||[]).push([[957],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),m=p(n),d=r,h=m["".concat(l,".").concat(d)]||m[d]||c[d]||o;return n?a.createElement(h,i(i({ref:t},u),{},{components:n})):a.createElement(h,i({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[m]="string"==typeof e?e:r,i[1]=s;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},4821:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const o={},i="21 - Async Programming",s={unversionedId:"ch21-async",id:"ch21-async",title:"21 - Async Programming",description:"In this section we're going to re-implement our web server from chapter 20 using async functions. We're just going to give you enough here to get your feet wet. For further reading, check out Asynchronous Programming in Rust, and the Tokio Tutorial. As usual, if you're looking for the full source for this project, it's in the GitHub repo.",source:"@site/docs/ch21-async.md",sourceDirName:".",slug:"/ch21-async",permalink:"/rust-book-abridged/ch21-async",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ch21-async.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"20.3 - Graceful Shutdown and Cleanup",permalink:"/rust-book-abridged/ch20/ch20-03-graceful-shutdown"},next:{title:"Appendix",permalink:"/rust-book-abridged/category/appendix"}},l={},p=[{value:"JavaScript",id:"javascript",level:2},{value:"The Runtime",id:"the-runtime",level:2},{value:"An <code>async</code> Web Server",id:"an-async-web-server",level:2}],u={toc:p},m="wrapper";function c(e){let{components:t,...n}=e;return(0,r.kt)(m,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"21---async-programming"},"21 - Async Programming"),(0,r.kt)("p",null,"In this section we're going to re-implement our web server from ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch20/ch20-01-single-threaded-web-server",title:"Chapter 20: Multithreaded Web Server"},"chapter 20")," using async functions. We're just going to give you enough here to get your feet wet. For further reading, check out ",(0,r.kt)("a",{parentName:"p",href:"https://rust-lang.github.io/async-book/"},"Asynchronous Programming in Rust"),", and the ",(0,r.kt)("a",{parentName:"p",href:"https://tokio.rs/tokio/tutorial"},"Tokio Tutorial"),". As usual, if you're looking for the full source for this project, it's ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/jwalton/rust-book-abridged/tree/master/examples/ch21-async-web-server"},"in the GitHub repo"),"."),(0,r.kt)("h2",{id:"javascript"},"JavaScript"),(0,r.kt)("p",null,"Wait... Isn't this supposed to be a book about Rust? It is, but we're going to start this chapter off talking about JavaScript. Love it or hate it, JavaScript is the most popular language in the world, and it is probably where most people were first exposed to the idea of async programming."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="user.js"',title:'"user.js"'},'// JavaScript Code\nimport * as fs from "fs/promises";\n\nasync function getUserName() {\n  const username = await fs.readFile("./username.txt", { encoding: "utf-8" });\n  console.log(`Hello ${username}`);\n}\n')),(0,r.kt)("p",null,"Even if you don't know JavaScript, hopefully this example is simple enough that you can follow along. We're calling ",(0,r.kt)("inlineCode",{parentName:"p"},"fs.readFile")," to read in a file. In JavaScript this is going to return a ",(0,r.kt)("inlineCode",{parentName:"p"},"Promise<string>"),". A ",(0,r.kt)("inlineCode",{parentName:"p"},"Promise")," in JavaScript is the result of some calculation we don't know yet (similar to a ",(0,r.kt)("inlineCode",{parentName:"p"},"Future")," in Java, or as we'll see in a moment a ",(0,r.kt)("inlineCode",{parentName:"p"},"Future")," in Rust). The magic in this function happens at the ",(0,r.kt)("inlineCode",{parentName:"p"},"await")," keyword. When we ",(0,r.kt)("inlineCode",{parentName:"p"},"await")," a promise, the current function stops executing, allowing other functions to run. At some future point in time when the promise resolves, this function will continue from where it left off."),(0,r.kt)("p",null,"In JavaScript, the above is actually more or less syntactic sugar for:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="user.js"',title:'"user.js"'},"// JavaScript Code\nimport * as fs from 'fs/promises';\n\nfunction getUserName() {\n    return fs.readFile(\"./username.txt\", { encoding: 'utf-8' })\n        .then(username => console.log(`Hello ${username}`));\n")),(0,r.kt)("p",null,"Here it's a little easier to understand how the execution of the function can be suspended. ",(0,r.kt)("inlineCode",{parentName:"p"},"getUserName")," calls into ",(0,r.kt)("inlineCode",{parentName:"p"},"readFile")," which creates a promise, and then ",(0,r.kt)("inlineCode",{parentName:"p"},"getUserName")," returns. At some future point in time, when the promise resolves, someone will call into the closure we're passing to ",(0,r.kt)("inlineCode",{parentName:"p"},"then"),'. Running this closure is how we "continue" this function in JavaScript.'),(0,r.kt)("p",null,"In Rust, we could rewrite the above example as something like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'use std::{error::Error};\nuse tokio::fs;\n\nasync fn get_user_name() -> Result<(), Box<dyn Error>> {\n    let username = fs::read_to_string("./username.txt").await?;\n    println!("Hello {username}");\n\n    Ok(())\n}\n\n')),(0,r.kt)("p",null,"This is very similar to the JavaScript example in many ways. Here ",(0,r.kt)("inlineCode",{parentName:"p"},"fs::read_to_string")," returns a type that implements the ",(0,r.kt)("inlineCode",{parentName:"p"},"Future")," trait (specifically ",(0,r.kt)("inlineCode",{parentName:"p"},"Future<Output = Result<String, Error>>"),"). When we call ",(0,r.kt)("inlineCode",{parentName:"p"},"await")," on the future, execution of this function is suspended, and at some future point someone will resume execution and the result of the ",(0,r.kt)("inlineCode",{parentName:"p"},"await")," will be a ",(0,r.kt)("inlineCode",{parentName:"p"},"Result<String, Error>"),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"?")," operator turns the ",(0,r.kt)("inlineCode",{parentName:"p"},"Result")," into a ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),"."),(0,r.kt)("p",null,"The important things to know here are that - in JavaScript or in Rust - you can only use ",(0,r.kt)("inlineCode",{parentName:"p"},"await")," inside a function that's declared ",(0,r.kt)("inlineCode",{parentName:"p"},"async"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"await")," will temporarily suspend execution of this function."),(0,r.kt)("h2",{id:"the-runtime"},"The Runtime"),(0,r.kt)("p",null,"In our JavaScript example, we glossed over one important detail. Someone calls calls into the closure we're passing to ",(0,r.kt)("inlineCode",{parentName:"p"},"then"),", but who is this mysterious someone? In JavaScript, everything runs in an event loop which is part of the JavaScript runtime. When the promise eventually resolves, it will queue a task and the event loop will pick it up and call into the closure. In our Rust example, we have the same problem; who takes care of restarting ",(0,r.kt)("inlineCode",{parentName:"p"},"get_user_name")," when the ",(0,r.kt)("inlineCode",{parentName:"p"},"Future")," from ",(0,r.kt)("inlineCode",{parentName:"p"},"fs::read_to_string")," completes? Here again, it's the runtime."),(0,r.kt)("p",null,"Except of course that Rust doesn't have a runtime. In Rust, the only code that runs in your application is code you write or code you bring in from a crate, so you need to either write your own runtime or pull one in from a crate! The most popular at the moment is ",(0,r.kt)("a",{parentName:"p",href:"https://tokio.rs/"},"Tokio"),", but there are other options. Also, unlike in JavaScript where everything is single threaded on the event loop, in Rust our async runtime could be implemented on a single thread or could be multithreaded (Tokio supports both)."),(0,r.kt)("p",null,"Tokio provides us with a lot more than just a runtime. If you look at our Rust example above, you'll notice we're calling ",(0,r.kt)("inlineCode",{parentName:"p"},"tokio::fs::read_to_string")," instead of ",(0,r.kt)("inlineCode",{parentName:"p"},"std::io::read_to_string"),". The standard library version does the same thing, but it doesn't return a ",(0,r.kt)("inlineCode",{parentName:"p"},"Future"),", it blocks until the file is read. If we were to use ",(0,r.kt)("inlineCode",{parentName:"p"},"std::io::read_to_string")," here, it would block this thread for a while, potentially stopping other async code from running. Tokio provides async versions of many standard library functions in this way, and because of this, refactoring non-async code to async is usually not trivial."),(0,r.kt)("h2",{id:"an-async-web-server"},"An ",(0,r.kt)("inlineCode",{parentName:"h2"},"async")," Web Server"),(0,r.kt)("p",null,"Let's write an async web server:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"$ cargo new hello-async\n$ cd hello-async\n")),(0,r.kt)("p",null,"Update our ",(0,r.kt)("em",{parentName:"p"},"Cargo.toml")," to include Tokio:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-toml",metastring:'title="Cargo.toml"',title:'"Cargo.toml"'},'[package]\nname = "hello-async"\nversion = "0.1.0"\nedition = "2021"\n\n[dependencies]\ntokio = { version = "1", features = ["full"] }\n')),(0,r.kt)("p",null,"Notice the ",(0,r.kt)("inlineCode",{parentName:"p"},'features = ["full"]'),". Features allow us to conditionally compile only the parts of Tokio we need. Tokio provides duplicates of most of the standard library, and if you don't need parts of it you can remove them here to make your binary smaller. Here's the code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},'use std::{error::Error, time::Duration};\nuse tokio::{\n    fs,\n    io::{AsyncBufReadExt, AsyncWriteExt, BufReader},\n    net::{TcpListener, TcpStream},\n};\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn Error>> {\n    let port = 7878u16;\n    let listen_address = format!("127.0.0.1:{port}");\n    let listener = TcpListener::bind(listen_address).await.unwrap();\n    println!("Listening on port {}", port);\n\n    loop {\n        let (stream, _) = listener.accept().await.unwrap();\n        handle_connection(stream).await;\n    }\n}\n\nasync fn handle_connection(mut stream: TcpStream) {\n    let buf_reader = BufReader::new(&mut stream);\n\n    let mut lines = buf_reader.lines();\n    let request_line = lines.next_line().await.unwrap().unwrap();\n\n    println!("Incoming request for {}", request_line);\n\n    match &request_line[..] {\n        "GET / HTTP/1.1" => send_response(stream, 200, "OK", "hello.html").await,\n        "GET /sleep HTTP/1.1" => {\n            tokio::time::sleep(Duration::from_secs(5)).await;\n            send_response(stream, 200, "OK", "hello.html").await;\n        }\n        _ => send_response(stream, 404, "NOT FOUND", "404.html").await,\n    }\n}\n\nasync fn send_response(mut stream: TcpStream, code: u16, reason: &str, filename: &str) {\n    let contents = fs::read_to_string(filename).await.unwrap();\n    let length = contents.len();\n    let response =\n        format!("HTTP/1.1 {code} {reason}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}");\n\n    stream.write_all(response.as_bytes()).await.unwrap();\n}\n')),(0,r.kt)("p",null,"If you want to run this, you'll need the ",(0,r.kt)("inlineCode",{parentName:"p"},"hello.html")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"404.html")," files from ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch20/ch20-01-single-threaded-web-server",title:"Chapter 20: Multithreaded Web Server"},"chapter 20"),"."),(0,r.kt)("p",null,"This looks very similar to our previous single and multithreaded web servers. We have to ",(0,r.kt)("inlineCode",{parentName:"p"},"use tokio::io::AsyncBufReadExt")," to be able to call ",(0,r.kt)("inlineCode",{parentName:"p"},"buf_reader.lines")," in ",(0,r.kt)("inlineCode",{parentName:"p"},"handle_connection"),", because in Tokio ",(0,r.kt)("inlineCode",{parentName:"p"},"lines")," is defined on the ",(0,r.kt)("inlineCode",{parentName:"p"},"AsyncBufReadExt")," trait, and similar for ",(0,r.kt)("inlineCode",{parentName:"p"},"tokio::io::AsyncWriteExt")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"stream.write_all")," in ",(0,r.kt)("inlineCode",{parentName:"p"},"send_response"),". We've also replaced some ",(0,r.kt)("inlineCode",{parentName:"p"},"for")," loops as Rust doesn't (yet) support async for loops. (We also simplified the code for parsing the request, since we weren't actually using any of the headers in our previous examples so we don't bother reading them here.)"),(0,r.kt)("p",null,"This is also very similar to our single threaded version because if you try reloading the \"/sleep\" route a few times, you'll see that this is only handling a single request at once. Isn't async supposed to fix that for us? The problem is that in our main loop, we're ",(0,r.kt)("inlineCode",{parentName:"p"},"await"),"ing ",(0,r.kt)("inlineCode",{parentName:"p"},"handle_connection"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"    loop {\n        let (stream, _) = listener.accept().await.unwrap();\n        handle_connection(stream).await;\n    }\n")),(0,r.kt)("p",null,"That ",(0,r.kt)("inlineCode",{parentName:"p"},"await")," will cause the main loop to suspend until ",(0,r.kt)("inlineCode",{parentName:"p"},"handle_connection")," completes. If you're an experienced JavaScript programmer, you might think you can just remove the ",(0,r.kt)("inlineCode",{parentName:"p"},"await"),". This would work in JavaScript, but not in Rust. Rust futures are ",(0,r.kt)("em",{parentName:"p"},"lazy"),", meaning they won't make any progress if no one is ",(0,r.kt)("inlineCode",{parentName:"p"},"await"),"ing them."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"If you have a look at the definition of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Future")," trait, you'll see that ",(0,r.kt)("inlineCode",{parentName:"p"},"Future")," has only one method:"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;\n")),(0,r.kt)("p",{parentName:"admonition"},"When we ",(0,r.kt)("inlineCode",{parentName:"p"},"await")," a future, what's happening under the covers is that the runtime will call into ",(0,r.kt)("inlineCode",{parentName:"p"},"poll")," to get the future to make progress. If the future completes, it will return the ",(0,r.kt)("inlineCode",{parentName:"p"},"Poll::Ready<Output>")," value. If not, it will return a ",(0,r.kt)("inlineCode",{parentName:"p"},"Poll::Pending"),". When the Future is ready to make progress again, it will call into the ",(0,r.kt)("inlineCode",{parentName:"p"},"Waker")," stored in the ",(0,r.kt)("inlineCode",{parentName:"p"},"Context")," to let the runtime know it should be polled again."),(0,r.kt)("p",{parentName:"admonition"},"If you're interested in the internals of ",(0,r.kt)("inlineCode",{parentName:"p"},"async")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Future"),"s in Rust, this is all covered in much greater detail in ",(0,r.kt)("a",{parentName:"p",href:"https://rust-lang.github.io/async-book/"},"Asynchronous Programming in Rust"),".")),(0,r.kt)("p",null,"In order to fix this problem, we have to create this future, then let Tokio know we'd like it to be polled. Tokio's answer to this is something called a ",(0,r.kt)("inlineCode",{parentName:"p"},"Task"),". We can spawn a task with ",(0,r.kt)("inlineCode",{parentName:"p"},"tokio::spawn"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"    loop {\n        let (stream, _) = listener.accept().await.unwrap();\n        tokio::spawn(async move {\n            handle_connection(stream).await;\n        });\n    }\n")),(0,r.kt)("p",null,"You might have expected ",(0,r.kt)("inlineCode",{parentName:"p"},"spawn")," to take a closure, but it actually takes a future! Here we're using an ",(0,r.kt)("inlineCode",{parentName:"p"},"async")," block to create a future, and the ",(0,r.kt)("inlineCode",{parentName:"p"},"move")," keyword to move ownership of the ",(0,r.kt)("inlineCode",{parentName:"p"},"stream")," into that block. We could also have rewritten this as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"    loop {\n        let (stream, _) = listener.accept().await.unwrap();\n        let f = handle_connection(stream);\n        tokio::spawn(f);\n    }\n")),(0,r.kt)("p",null,"But the async block is more idiomatic. ",(0,r.kt)("inlineCode",{parentName:"p"},"spawn")," returns a ",(0,r.kt)("inlineCode",{parentName:"p"},"tokio::task::JoinHandle<T>")," similar to the ",(0,r.kt)("inlineCode",{parentName:"p"},"JoinHandle")," we get when you spawn a thread. You can ",(0,r.kt)("inlineCode",{parentName:"p"},"await")," on this handle to wait for the underlying Future to complete."),(0,r.kt)("p",null,'Tasks are a form of "green thread". Spawning a task is very lightweight, involving only a single allocation and 64 bytes of memory, so you can easily spawn thousands or millions of tasks (which would be ill-advised if we were talking about OS threads).'),(0,r.kt)("p",null,"If you've read this far, you've made it to the end of the book. If you enjoyed it, please ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/jwalton/rust-book-abridged"},"star the book on GitHub"),", or ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/sponsors/jwalton"},"buy me a coffee"),".  Happy Rusting!"))}c.isMDXComponent=!0}}]);