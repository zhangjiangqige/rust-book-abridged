"use strict";(self.webpackChunkrust_book_abridged=self.webpackChunkrust_book_abridged||[]).push([[899],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>h});var r=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},o=Object.keys(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var c=r.createContext({}),s=function(e){var t=r.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},m=function(e){var t=s(e.components);return r.createElement(c.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,o=e.originalType,c=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),p=s(a),d=n,h=p["".concat(c,".").concat(d)]||p[d]||u[d]||o;return a?r.createElement(h,i(i({ref:t},m),{},{components:a})):r.createElement(h,i({ref:t},m))}));function h(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=a.length,i=new Array(o);i[0]=d;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l[p]="string"==typeof e?e:n,i[1]=l;for(var s=2;s<o;s++)i[s]=a[s];return r.createElement.apply(null,i)}return r.createElement.apply(null,a)}d.displayName="MDXCreateElement"},3517:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>s});var r=a(7462),n=(a(7294),a(3905));const o={},i="19.5 - Macros",l={unversionedId:"ch19/ch19-05-macros",id:"ch19/ch19-05-macros",title:"19.5 - Macros",description:"If you're coming to Rust from C or C++, then you're no doubt already familiar with macros. We're going to give a quick introduction to macros here, but if you want to read more you should check out The Little Book of Rust Macros.",source:"@site/docs/ch19/ch19-05-macros.md",sourceDirName:"ch19",slug:"/ch19/ch19-05-macros",permalink:"/rust-book-abridged/ch19/ch19-05-macros",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ch19/ch19-05-macros.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"19.4 - Advanced Functions and Closures",permalink:"/rust-book-abridged/ch19/ch19-04-advanced-functions-and-closures"},next:{title:"20 - Multithreaded Web Server",permalink:"/rust-book-abridged/category/20---multithreaded-web-server"}},c={},s=[{value:"Declarative Macros with <code>macro_rules!</code> for General Metaprogramming",id:"declarative-macros-with-macro_rules-for-general-metaprogramming",level:2},{value:"Procedural Macros for Generating Code from Attributes",id:"procedural-macros-for-generating-code-from-attributes",level:2},{value:"How to Write a Custom <code>derive</code> Macro",id:"how-to-write-a-custom-derive-macro",level:3},{value:"Attribute-like macros",id:"attribute-like-macros",level:3},{value:"Function-like macros",id:"function-like-macros",level:3}],m={toc:s},p="wrapper";function u(e){let{components:t,...a}=e;return(0,n.kt)(p,(0,r.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"195---macros"},"19.5 - Macros"),(0,n.kt)("p",null,"If you're coming to Rust from C or C++, then you're no doubt already familiar with macros. We're going to give a quick introduction to macros here, but if you want to read more you should check out ",(0,n.kt)("a",{parentName:"p",href:"https://veykril.github.io/tlborm/introduction.html"},"The Little Book of Rust Macros"),"."),(0,n.kt)("p",null,'Macros are a kind of "metaprogramming". When we write a Macro, we\'re actually writing Rust code that generates more Rust code.'),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Macros run at compile time, so they have no runtime performance impact (although they can generate code that runs at runtime, which might)."),(0,n.kt)("li",{parentName:"ul"},"Macros can take a variable number of parameters (such as the ",(0,n.kt)("inlineCode",{parentName:"li"},"println!")," marco does) which normal Rust functions cannot."),(0,n.kt)("li",{parentName:"ul"},"Macros must be brought into scope or defined locally before they are called.")),(0,n.kt)("h2",{id:"declarative-macros-with-macro_rules-for-general-metaprogramming"},"Declarative Macros with ",(0,n.kt)("inlineCode",{parentName:"h2"},"macro_rules!")," for General Metaprogramming"),(0,n.kt)("p",null,(0,n.kt)("em",{parentName:"p"},"Declarative macros"),' are sometimes called "macros by example" or just "macros" (because these are the most common kind of macro you\'re going to encounter). Here is a very simple macro:'),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-rust"},'macro_rules! four {\n    () => {\n        1 + 3\n    };\n}\n\nfn main() {\n    let x = four!();\n    println!("{x}");\n}\n\n')),(0,n.kt)("p",null,"The ",(0,n.kt)("inlineCode",{parentName:"p"},"macro_rules! four")," says we're going to declare a macro named ",(0,n.kt)("inlineCode",{parentName:"p"},"four!"),". Inside the ",(0,n.kt)("inlineCode",{parentName:"p"},"{}"),", the rest of this macro is similar to a ",(0,n.kt)("inlineCode",{parentName:"p"},"match")," expression (in this example we only have one arm). Each rule in a ",(0,n.kt)("inlineCode",{parentName:"p"},"macro_rules!")," is of the format ",(0,n.kt)("inlineCode",{parentName:"p"},"(MATCHER) => {EXPANSION};"),". When we call a macro, we don't actually pass in parameters like ",(0,n.kt)("inlineCode",{parentName:"p"},"i32"),"s or ",(0,n.kt)("inlineCode",{parentName:"p"},"&str"),"s, instead we're passing in a snippet of Rust code. When the macro runs, it will try to match the passed in token tree to each matcher in turn. Once it finds a match, we'll replace the whole macro with whatever is in the expansion part."),(0,n.kt)("p",null,'In the case of our macro above, we just have a single "empty matcher". If you were to try calling ',(0,n.kt)("inlineCode",{parentName:"p"},'let x = four!("hello");'),", you'd get an error telling you ",(0,n.kt)("inlineCode",{parentName:"p"},'no rules expected the token `"hello"`'),"."),(0,n.kt)("p",null,"A matcher can contain ",(0,n.kt)("em",{parentName:"p"},"captures")," which let us capture some tokens to a ",(0,n.kt)("em",{parentName:"p"},"metavariable"),". Metavariables start with ",(0,n.kt)("inlineCode",{parentName:"p"},"$"),":"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-rust"},"macro_rules! add_one {\n    ($e:expr) => { $e + 1 };\n}\n")),(0,n.kt)("p",null,"Here if you called ",(0,n.kt)("inlineCode",{parentName:"p"},"add_one!(2)")," would be replaced with ",(0,n.kt)("inlineCode",{parentName:"p"},"2 + 1"),". Let's have a look at the ",(0,n.kt)("inlineCode",{parentName:"p"},"vec!")," macro, which is a bit more exciting:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-rust"},"#[macro_export]\nmacro_rules! vec {\n    ( $( $x:expr ),* ) => {\n        {\n            let mut temp_vec = Vec::new();\n            $(\n                temp_vec.push($x);\n            )*\n            temp_vec\n        }\n    };\n}\n")),(0,n.kt)("admonition",{type:"info"},(0,n.kt)("p",{parentName:"admonition"},"This is actually a slightly simplified version of ",(0,n.kt)("inlineCode",{parentName:"p"},"vec!"),". The original tries to preallocate the correct amount of data in the new vector.")),(0,n.kt)("p",null,"First, notice we've added the ",(0,n.kt)("inlineCode",{parentName:"p"},"#[macro_export]")," annotation. Without this annotation, this macro can't be used outside of the crate it is defined in."),(0,n.kt)("p",null,"The ",(0,n.kt)("inlineCode",{parentName:"p"},"$(),*")," part of the matcher here is called a ",(0,n.kt)("em",{parentName:"p"},"repetition"),". These have the form ",(0,n.kt)("inlineCode",{parentName:"p"},"$ (...) sep rep"),", where ",(0,n.kt)("inlineCode",{parentName:"p"},"( ... )")," is the part that's being repeated, ",(0,n.kt)("inlineCode",{parentName:"p"},"sep")," is an optional separator token, and ",(0,n.kt)("inlineCode",{parentName:"p"},"rep")," defines how many times the pattern can repeat - ",(0,n.kt)("inlineCode",{parentName:"p"},"?")," for zero or one, ",(0,n.kt)("inlineCode",{parentName:"p"},"*")," for zero or more, and ",(0,n.kt)("inlineCode",{parentName:"p"},"+")," for one or more (like in a regular expression). So ",(0,n.kt)("inlineCode",{parentName:"p"},"( $( $x:expr ),* )")," matches zero or more expressions, separated by commas, and each time through the repetition we assign the matched part to the ",(0,n.kt)("inlineCode",{parentName:"p"},"$x")," metavariable."),(0,n.kt)("p",null,"On the right hand side of the ",(0,n.kt)("inlineCode",{parentName:"p"},"=>")," we have the code we're going to expand this to. Inside the ",(0,n.kt)("inlineCode",{parentName:"p"},"$()")," is the repetition part - this code will be inserted once for each time the repetition matches on the matcher side."),(0,n.kt)("p",null,"So if we were to write ",(0,n.kt)("inlineCode",{parentName:"p"},"vec![1, 2, 3]"),", at compile time this would get replaced with:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-rust"},"{\n    let mut temp_vec = Vec::new();\n    temp_vec.push(1);\n    temp_vec.push(2);\n    temp_vec.push(3);\n    temp_vec\n}\n")),(0,n.kt)("h2",{id:"procedural-macros-for-generating-code-from-attributes"},"Procedural Macros for Generating Code from Attributes"),(0,n.kt)("p",null,"A ",(0,n.kt)("em",{parentName:"p"},"procedural macro")," is a Rust function that takes in a ",(0,n.kt)("inlineCode",{parentName:"p"},"TokenStream")," of some input source code and produces a ",(0,n.kt)("inlineCode",{parentName:"p"},"TokenStream")," of some generated code. There are three kinds of procedural macros: custom derive, attribute-like, and function-like. When we ",(0,n.kt)("inlineCode",{parentName:"p"},"#[derive()]")," a trait, it's going through a custom-derive macro. Procedural macros need to be defined in their own special crate for technical reasons we're going to hand wave away for this book, although this will likely change in the future."),(0,n.kt)("h3",{id:"how-to-write-a-custom-derive-macro"},"How to Write a Custom ",(0,n.kt)("inlineCode",{parentName:"h3"},"derive")," Macro"),(0,n.kt)("p",null,"Let's create some new projects:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-sh"},"mkdir projects\ncd projects\ncargo new hello_macro --lib\ncd hello_macro\ncargo new hello_macro_derive --lib\n")),(0,n.kt)("p",null,"We created two projects, one inside the other. The outer project will contain our trait, and the inner wil going to contain our custom derive macro. We create these two projects one-inside-the-other because they are tightly related; if the code in the outer project changes, odds are the code in the inner project will too. Unfortunately we'll need to publish the two crates to ",(0,n.kt)("a",{parentName:"p",href:"https://crates.io"},"crates.io")," separately."),(0,n.kt)("p",null,"In the outer project, we're going to create a trait:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="hello_macro/src/lib.rs"',title:'"hello_macro/src/lib.rs"'},"pub trait HelloMacro {\n    fn hello_macro();\n}\n")),(0,n.kt)("p",null,"The idea here is that a when a consumer of our library implements this trait, we want to give them a derive macro that will implement the ",(0,n.kt)("inlineCode",{parentName:"p"},"hello_macro"),' method for them. Let\'s create one more project in the "projects" folder:'),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-sh"},"cd ..\ncargo new pancakes\n")),(0,n.kt)("p",null,"And then write a file that uses our derive macro:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="pancakes/src/main.rs"',title:'"pancakes/src/main.rs"'},'use hello_macro::HelloMacro;\nuse hello_macro_derive::HelloMacro;\n\n// This derive attribute will run our derive macro.\n#[derive(HelloMacro)]\nstruct Pancakes;\n\nfn main() {\n    // This will print "Hello, Macro! My name is Pancakes!"\n    Pancakes::hello_macro();\n}\n')),(0,n.kt)("p",null,"In our inner project, we're going to add some dependencies to ",(0,n.kt)("em",{parentName:"p"},"Cargo.toml"),":"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-toml",metastring:'title="hello_macro/hello_macro_derive/Cargo.toml"',title:'"hello_macro/hello_macro_derive/Cargo.toml"'},'[lib]\nproc-macro = true\n\n[dependencies]\nsyn = "1.0"\nquote = "1.0"\n')),(0,n.kt)("p",null,"The ",(0,n.kt)("inlineCode",{parentName:"p"},"proc-macro = true")," line ",(0,n.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/cargo/reference/cargo-targets.html#configuring-a-target"},"tells Cargo")," that this is a special library that contains procedural macros. This also gives us access to the ",(0,n.kt)("inlineCode",{parentName:"p"},"proc_macro")," crate, which is where ",(0,n.kt)("inlineCode",{parentName:"p"},"TokenStream")," comes from. ",(0,n.kt)("inlineCode",{parentName:"p"},"syn")," is a crate for parsing Rust code into an ",(0,n.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Abstract_syntax_tree"},"abstract syntax tree")," or ",(0,n.kt)("em",{parentName:"p"},"AST"),", and ",(0,n.kt)("inlineCode",{parentName:"p"},"quote")," is a crate for turning a syntax tree back into Rust code. ",(0,n.kt)("inlineCode",{parentName:"p"},"syn")," is going to take our ",(0,n.kt)("inlineCode",{parentName:"p"},"Pancakes")," data structure above and turn it into something like:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-rust"},'DeriveInput {\n    // --snip--\n    ident: Ident {\n        ident: "Pancakes",\n        span: #0 bytes(95..103)\n    },\n    data: Struct(\n        DataStruct {\n            struct_token: Struct,\n            fields: Unit,\n            semi_token: Some(\n                Semi\n            )\n        }\n    )\n}\n')),(0,n.kt)("p",null,"The field we care about for our implementation is the ",(0,n.kt)("inlineCode",{parentName:"p"},"ident"),' or "identifier" for our struct. You can see what else will be passed to our macro in the ',(0,n.kt)("a",{parentName:"p",href:"https://docs.rs/syn/1.0.109/syn/struct.DeriveInput.html"},(0,n.kt)("inlineCode",{parentName:"a"},"syn::DeriveInput")," documentation"),"."),(0,n.kt)("p",null,"Here's the code for our macro:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="hello_macro/hello_macro_derive/src/lib.rs"',title:'"hello_macro/hello_macro_derive/src/lib.rs"'},'use proc_macro::TokenStream;\nuse quote::quote;\nuse syn;\n\n// This line tells Rust that this is the macro\n// to call when someone does `#[derive(HelloMacro)]`.\n#[proc_macro_derive(HelloMacro)]\npub fn hello_macro_derive(input: TokenStream) -> TokenStream {\n    // Construct a representation of Rust code as a syntax tree\n    // that we can manipulate\n    let ast = syn::parse(input).unwrap();\n\n    // Build the trait implementation\n    impl_hello_macro(&ast)\n}\n\n// It\'s very common to split the derive macro into one function\n// that parses the input (`hello_macro_derive`) and one that\n// generates the code (`impl_hello_macro`).\nfn impl_hello_macro(ast: &syn::DeriveInput) -> TokenStream {\n    let name = &ast.ident;\n\n    // `#name` will be replaced with `Pancakes` here.\n    let gen = quote! {\n        impl HelloMacro for #name {\n            fn hello_macro() {\n                println!("Hello, Macro! My name is {}!", stringify!(#name));\n            }\n        }\n    };\n\n    // Convert `gen` into a `TokenStream`.\n    gen.into()\n}\n')),(0,n.kt)("p",null,"The ",(0,n.kt)("inlineCode",{parentName:"p"},"quote!")," macro here helps us define the code we want to generate. Note the ",(0,n.kt)("inlineCode",{parentName:"p"},"#name")," template inside of ",(0,n.kt)("inlineCode",{parentName:"p"},"quote!"),". ",(0,n.kt)("inlineCode",{parentName:"p"},"quote!")," has other cool template tricks, so be sure to ",(0,n.kt)("a",{parentName:"p",href:"https://docs.rs/quote/latest/quote/"},"check out its documentation"),". The ",(0,n.kt)("inlineCode",{parentName:"p"},"stringify!")," macro is built into rust and turns an expression like ",(0,n.kt)("inlineCode",{parentName:"p"},"1 + 2")," into a string like ",(0,n.kt)("inlineCode",{parentName:"p"},'"1 + 2"'),", or here ",(0,n.kt)("inlineCode",{parentName:"p"},"Pancakes")," into ",(0,n.kt)("inlineCode",{parentName:"p"},'"Pancakes"'),"."),(0,n.kt)("p",null,"If you want to run this, there's just one thing left to do. In our ",(0,n.kt)("em",{parentName:"p"},"pancakes")," project, we need to add dependencies to ",(0,n.kt)("em",{parentName:"p"},"Cargo.toml")," so it can find our trait and macro:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-toml",metastring:'title="pancakes/Cargo.toml"',title:'"pancakes/Cargo.toml"'},'[dependencies]\nhello_macro = { path = "../hello_macro" }\nhello_macro_derive = { path = "../hello_macro/hello_macro_derive" }\n')),(0,n.kt)("p",null,"Now you should be able to ",(0,n.kt)("inlineCode",{parentName:"p"},"cargo run")," from the ",(0,n.kt)("em",{parentName:"p"},"pancakes")," folder. If you run into trouble, the full source is ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/jwalton/rust-book-abridged/tree/master/examples/ch19-hello-macro"},"available on GitHub"),"."),(0,n.kt)("h3",{id:"attribute-like-macros"},"Attribute-like macros"),(0,n.kt)("p",null,(0,n.kt)("em",{parentName:"p"},"Attribute-like")," macros are another kind of procedural macros. They let you define custom attributes, for example:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-rust"},'#[route(GET, "/")]\nfn index() {\n')),(0,n.kt)("p",null,"Unlike a custom derive macro (which can only be applied to structs and enums), these can be applied to any Rust code. To define this macro, you'd create a ",(0,n.kt)("inlineCode",{parentName:"p"},"macro")," function like this:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-rust"},"#[proc_macro_attribute]\npub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {\n    // --snip--\n}\n")),(0,n.kt)("p",null,"The implementation would be just like the derive macro, except that there are two ",(0,n.kt)("inlineCode",{parentName:"p"},"TokenStream"),"s - one for the item we are adding this attribute to, and one for the parameters passed to the macro. Like the derive macro, this needs to be in a special crate by itself (or with other procedural macros)."),(0,n.kt)("h3",{id:"function-like-macros"},"Function-like macros"),(0,n.kt)("p",null,"The last kind of procedural macro is the ",(0,n.kt)("em",{parentName:"p"},"function-like")," macro. The name comes from the fact that we can call them like a function, similar to ",(0,n.kt)("inlineCode",{parentName:"p"},"macro_rules!")," macros:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-rust"},"let sql = sql!(SELECT * FROM posts WHERE id=1);\n")),(0,n.kt)("p",null,"This macro would be defined as:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-rust"},"#[proc_macro]\npub fn sql(input: TokenStream) -> TokenStream {\n    // --snip--\n}\n")))}u.isMDXComponent=!0}}]);