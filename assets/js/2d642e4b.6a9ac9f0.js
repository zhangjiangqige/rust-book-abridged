"use strict";(self.webpackChunkrust_book_abridged=self.webpackChunkrust_book_abridged||[]).push([[257],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),c=p(n),h=i,d=c["".concat(s,".").concat(h)]||c[h]||m[h]||o;return n?a.createElement(d,r(r({ref:t},u),{},{components:n})):a.createElement(d,r({ref:t},u))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[c]="string"==typeof e?e:i,r[1]=l;for(var p=2;p<o;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},7936:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=n(7462),i=(n(7294),n(3905));const o={},r="6 - Enums and Pattern Matching",l={unversionedId:"ch06-enums-and-pattern-matching",id:"ch06-enums-and-pattern-matching",title:"6 - Enums and Pattern Matching",description:"6.1 - Defining an Enum",source:"@site/docs/ch06-enums-and-pattern-matching.md",sourceDirName:".",slug:"/ch06-enums-and-pattern-matching",permalink:"/rust-book-abridged/ch06-enums-and-pattern-matching",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ch06-enums-and-pattern-matching.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"5 - Using Structs to Structure Related Data",permalink:"/rust-book-abridged/ch05-structs"},next:{title:"7 - Managing Growing Projects with Packages, Crates, and Modules",permalink:"/rust-book-abridged/ch07-packages-crates-modules"}},s={},p=[{value:"6.1 - Defining an Enum",id:"61---defining-an-enum",level:2},{value:"The <code>Option</code> Enum and Its Advantages Over Null Values",id:"the-option-enum-and-its-advantages-over-null-values",level:3},{value:"6.2 The <code>match</code> Control Flow Construct",id:"62-the-match-control-flow-construct",level:2},{value:"Patterns That Bind to Values",id:"patterns-that-bind-to-values",level:3},{value:"Catch-all Patterns and the _ Placeholder",id:"catch-all-patterns-and-the-_-placeholder",level:3},{value:"6.3 - Concise Control Flow with <code>if let</code>",id:"63---concise-control-flow-with-if-let",level:2}],u={toc:p},c="wrapper";function m(e){let{components:t,...n}=e;return(0,i.kt)(c,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"6---enums-and-pattern-matching"},"6 - Enums and Pattern Matching"),(0,i.kt)("h2",{id:"61---defining-an-enum"},"6.1 - Defining an Enum"),(0,i.kt)("p",null,"An ",(0,i.kt)("em",{parentName:"p"},"enum")," allows you to define a type by enumerating its possible ",(0,i.kt)("em",{parentName:"p"},"variants"),". If you're coming from some other language, you probably think of an enum as basically a fancy way to assign names to a set of numbers. A Rust enum goes beyond this, as each variant of an enum can have some data associated with it, much like a struct."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"// Define an enum.\nenum IpAddrKind {\n    V4,\n    V6,\n}\n\n// Use one of the variants from the enum.\nlet ip_address_kind = IpAddrKind::V4;\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"IpAddrKind::V4")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"IpAddrKind::V6")," are both of type IpAddrKind."),(0,i.kt)("p",null,"We can also attach data to an enum:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'enum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(u8, u8, u8),\n}\n\nfn main() {\n    let m1 = Message::Quit;\n    let m2 = Message::Move { x: 7, y: 9 };\n    let m3 = Message::Write(String::from("Hello"));\n    let m4 = Message::ChangeColor(0, 255, 255);\n}\n')),(0,i.kt)("p",null,"Note that the different variants can take different types of associated data, and the data can either have named values like a struct or a set of values like a name tuple. Importantly though, all are of type ",(0,i.kt)("inlineCode",{parentName:"p"},"Message"),"."),(0,i.kt)("p",null,"We can also defined methods on an enum:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'impl Message {\n    fn call(&self) {\n        // method body would be defined here\n    }\n}\n\nlet m = Message::Write(String::from("hello"));\nm.call();\n')),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"call")," function here might use a match statement to perform different actions based on the variant of the Message enum."),(0,i.kt)("h3",{id:"the-option-enum-and-its-advantages-over-null-values"},"The ",(0,i.kt)("inlineCode",{parentName:"h3"},"Option")," Enum and Its Advantages Over Null Values"),(0,i.kt)("p",null,"As mentioned earlier in this book, Rust has no ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," value. In most languages, you can dereference a null pointer, and it will cause your program to crash at runtime. Rust has a strong focus on safety and makes the conscious decision to not allow null pointers to exist in the first place."),(0,i.kt)("p",null,'However, sometimes we have a value that might not be defined. For example we might have a "middle_name" field on a User, but some users might not have a middle name. Rust handles this with the ',(0,i.kt)("inlineCode",{parentName:"p"},"Option")," enum, defined by the standard library. ",(0,i.kt)("inlineCode",{parentName:"p"},"Option")," is used frequently in Rust - so frequently that both ",(0,i.kt)("inlineCode",{parentName:"p"},"Option")," and it's two variants are in the prelude, so you don't have to ",(0,i.kt)("inlineCode",{parentName:"p"},"use")," it to bring it into scope."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Option")," is defined as:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"enum Option<T> {\n    None,\n    Some(T),\n}\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"<T>")," means this is a generic enum - it can hold a value of any type. We'll talk more about generics in ",(0,i.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch10/ch10-01-generic-data-types",title:"Chapter 10: Generic Types, Traits, and Lifetimes"},"chapter 10"),", but this is very similar to generics and template classes in other languages. When we use an ",(0,i.kt)("inlineCode",{parentName:"p"},"Option"),", we have to specify a concrete type for ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," which defines a new type. For example, an ",(0,i.kt)("inlineCode",{parentName:"p"},"Option<i32>")," can be ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),", or it can be ",(0,i.kt)("inlineCode",{parentName:"p"},"Some(i32)"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'// No need for `std::Options::Some`, or even `Option::Some`,\n// because these are in the prelude.\nlet some_number = Some(5);\nlet some_str = Some("Hello");\n\n// Need to explicitly annotate type here, since Rust\n// can\'t automatically infer what type to use for\n// `T` from `None`.\nlet absent_number: Option<i32> = None;\n')),(0,i.kt)("p",null,"In this example ",(0,i.kt)("inlineCode",{parentName:"p"},"some_number")," will be of type ",(0,i.kt)("inlineCode",{parentName:"p"},"Option<i32>"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"some_str")," will similarly be ",(0,i.kt)("inlineCode",{parentName:"p"},"Option<&str>"),". The ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," case here is a bit like null in a traditional language. ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," serves as a marker that a value isn't present. We're not going to be able to use use an ",(0,i.kt)("inlineCode",{parentName:"p"},"Option<i32>")," in place of a regular ",(0,i.kt)("inlineCode",{parentName:"p"},"i32")," though:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"let x = 7;\nlet y = Some(8);\n\n// This will fail, since x and y are mismatched types\nlet z = x + y;\n")),(0,i.kt)("p",null,"The difference between ",(0,i.kt)("inlineCode",{parentName:"p"},"Option")," in Rust and null in other languages is that we can't just use an ",(0,i.kt)("inlineCode",{parentName:"p"},"Option"),", we have to explicitly handle the case where the value might not be there. What we need is a way to convert an ",(0,i.kt)("inlineCode",{parentName:"p"},"Option<T>")," into a ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),". If you have a look at ",(0,i.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/std/option/"},"Option in the Rust Reference")," you'll see that it has many methods defined on it that provide different ways to extract the underlying value from an Option, each with different ways of handling the case where the value is None."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'let x = Some(8);\n\n// If x is Some then use the value, otherwise panic.\nlet must_exist = x.expect("x should never be undefined here");\n\n// Same as expect, but uses a generic message.\nlet must_exist_2 = x.unwrap();\n\n// If x is Some use the value, otherwise\n// if x is None use 9.\nlet with_default = x.unwrap_or(9);\n\n// If x is Some use the value + 1, otherwise use 0.\n// We\'ll talk about match more in the next section!\nlet from_match = match x {\n    Some(v) => v + 1,\n    None => 0\n};\n')),(0,i.kt)("h2",{id:"62-the-match-control-flow-construct"},"6.2 The ",(0,i.kt)("inlineCode",{parentName:"h2"},"match")," Control Flow Construct"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"match"),' is a bit like a switch/case statement on steroids. Formally, a match consists of an expression, and then one or more "arms" with patterns that try to match the expression. The pattern for each arm is evaluated in order, and the code associated with the first arm that matches will be executed. The pattern side is quite a bit more flexible than a switch/case statement (see ',(0,i.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch18-patterns-and-matching",title:"Chapter 18: Patterns and Matching"},"chapter 18"),"). One thing to note about a match expression is that the patterns must cover every possible value - they must be ",(0,i.kt)("em",{parentName:"p"},"exhaustive"),". If there are any possibly-unhandled-values, the compiler will error."),(0,i.kt)("p",null,"Here's an example of a match expression, taken directly from the original Rust Book:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"enum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter,\n}\n\nfn value_in_cents(coin: Coin) -> u8 {\n    match coin {\n        Coin::Penny => 1,\n        Coin::Nickel => 5,\n        Coin::Dime => 10,\n        Coin::Quarter => 25,\n    }\n}\n")),(0,i.kt)("h3",{id:"patterns-that-bind-to-values"},"Patterns That Bind to Values"),(0,i.kt)("p",null,"A match expression can bind to parts of values that match the pattern. This can be used to extract one or more values out of an enum. We saw a quick example of this when handling ",(0,i.kt)("inlineCode",{parentName:"p"},"Option"),"s in the previous section:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"let x = Some(7);\n\nlet from_match = match x {\n    Some(v) => v + 1,\n    None => 0\n};\n")),(0,i.kt)("p",null,"Here ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," gets bound to the contents of ",(0,i.kt)("inlineCode",{parentName:"p"},"Some"),". Let's see this in action with our coin example from before. Let's change the Quarter variant of the Coin enum so it tells us which Canadian province this quarter is from:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(Debug)] // so we can inspect the state in a minute\nenum Province {\n    Alberta,\n    BritishColumbia,\n    // --snip--\n}\n\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter(Province),\n    Loonie,\n    Toonie,\n}\n\nfn value_in_cents(coin: Coin) -> u8 {\n    match coin {\n        Coin::Penny => 1,\n        Coin::Nickel => 5,\n        Coin::Dime => 10,\n        Coin::Quarter(province) => {\n            println!("Quarter from {:?}!", province);\n            25\n        }\n        Loonie => 100,\n        Toonie => 200,\n    }\n}\n')),(0,i.kt)("p",null,"Each arm of the match can have a simple expression, or a block of code. As with functions, if the block ends with an expression this will be used as the value for that arm. If we were to call this with a ",(0,i.kt)("inlineCode",{parentName:"p"},"Coin::Quarter(Province::Ontario)"),", then in the Quarter arm of the match, ",(0,i.kt)("inlineCode",{parentName:"p"},"province")," would be bound to ",(0,i.kt)("inlineCode",{parentName:"p"},"Province::Ontario"),"."),(0,i.kt)("p",null,"Let's take a moment here to reflect on ownership implications. In this case, the Province enum implements the Copy trait, so we don't have to worry about ownership as the Province enum is going to be allocated on the stack. If we change the Coin enum so it is ",(0,i.kt)("inlineCode",{parentName:"p"},"Quarter(String)")," however, then binding ",(0,i.kt)("inlineCode",{parentName:"p"},"province")," inside the match would move ownership of the String out of the coin and we wouldn't be able to use it again outside the match! We could fix this by borrowing the value instead, either by changing the match expression to ",(0,i.kt)("inlineCode",{parentName:"p"},"match &coin")," or to make ",(0,i.kt)("inlineCode",{parentName:"p"},"value_in_cents")," take a reference to the Coin as a parameter instead of the Coin itself."),(0,i.kt)("h3",{id:"catch-all-patterns-and-the-_-placeholder"},"Catch-all Patterns and the ","_"," Placeholder"),(0,i.kt)("p",null,"A match expression must be exhaustive - it has to cover all possible cases. Sometimes we have a number of cases we want to treat the same way, or enumerating all cases would be impractical. If we wrote a match and passed in an ",(0,i.kt)("inlineCode",{parentName:"p"},"i32")," as the expression, we certainly wouldn't want to write out all 4 billion possible values the i32 could be! The catch-all pattern lets us create a default arm (similar to ",(0,i.kt)("inlineCode",{parentName:"p"},"default")," in a switch/case statement in many languages)."),(0,i.kt)("p",null,"The example used by the original Rust Book is that you're building a board game where a player rolls a dice. On a roll of a 3, the place gets a hat. On a 7, the player loses their hat. On any other dice roll, they move that many spaces:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"let dice_roll = 9;\nmatch dice_roll {\n    3 => add_fancy_hat(),\n    7 => remove_fancy_hat(),\n    other => move_player(other),\n}\n")),(0,i.kt)("p",null,"Here we have explicit arms for the 3 and 7 case, and then we have a catch-all pattern that binds the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"dice_roll")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"other"),". If we didn't actually want to ",(0,i.kt)("em",{parentName:"p"},"use")," the value in the catch-all case, we wouldn't want to bind the value to a variable, since we'd get a warning from the compiler about an unused variable. In this case, we can replace ",(0,i.kt)("inlineCode",{parentName:"p"},"other")," with ",(0,i.kt)("inlineCode",{parentName:"p"},"_"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"match dice_roll {\n    3 => add_fancy_hat(),\n    7 => remove_fancy_hat(),\n    _ => (),\n}\n")),(0,i.kt)("p",null,"Here we're making this arm evaluate to the empty unit tuple, explicitly telling Rust that we don't want to do anything in this case. (Note that unlike ",(0,i.kt)("inlineCode",{parentName:"p"},"other"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"_")," also doesn't bind the variable, which has ownership implications! See ",(0,i.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch18-patterns-and-matching#ignoring-an-unused-variable-by-starting-its-name-with-_"},"chapter 18"),"."),(0,i.kt)("h2",{id:"63---concise-control-flow-with-if-let"},"6.3 - Concise Control Flow with ",(0,i.kt)("inlineCode",{parentName:"h2"},"if let")),(0,i.kt)("p",null,"On other languages you can convert a switch/case statement into a series of if/else statements. You can do the same in Rust. You could write:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'    let config_max = Some(3u8);\n    match config_max {\n        Some(max) => println!("The maximum is configured to be {}", max),\n        _ => (),\n    }\n')),(0,i.kt)("p",null,"But this is a bit verbose, considering the default arm does nothing. We can rewrite this as an if statement with ",(0,i.kt)("inlineCode",{parentName:"p"},"if let"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'let config_max = Some(3u8);\nif let Some(max) = config_max {\n    println!("The maximum is configured to be {}", max);\n}\n')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"if let")," takes a pattern and an expression, separated by an equals sign, and works exactly like the arm of a switch. The downside to ",(0,i.kt)("inlineCode",{parentName:"p"},"if let")," over a ",(0,i.kt)("inlineCode",{parentName:"p"},"match")," statement is that the compiler does not force you to exhaustively handle every possible scenario."),(0,i.kt)("p",null,"Continue to ",(0,i.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch07-packages-crates-modules",title:"Chapter 7: Managing Growing Projects with Packages, Crates, and Modules"},"chapter 7"),"."))}m.isMDXComponent=!0}}]);