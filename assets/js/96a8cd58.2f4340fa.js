"use strict";(self.webpackChunkrust_book_abridged=self.webpackChunkrust_book_abridged||[]).push([[256],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),p=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return r.createElement(s.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=p(n),h=a,m=d["".concat(s,".").concat(h)]||d[h]||u[h]||o;return n?r.createElement(m,i(i({ref:t},c),{},{components:n})):r.createElement(m,i({ref:t},c))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:a,i[1]=l;for(var p=2;p<o;p++)i[p]=n[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},2200:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var r=n(7462),a=(n(7294),n(3905));const o={},i="20.1 - Building a Single-Threaded Web Server",l={unversionedId:"ch20/ch20-01-single-threaded-web-server",id:"ch20/ch20-01-single-threaded-web-server",title:"20.1 - Building a Single-Threaded Web Server",description:"In this chapter we're going to build a simple HTTP server to put together a number of things we've learned so far. As usual, the code for this project is available in the GitHub repo.",source:"@site/docs/ch20/ch20-01-single-threaded-web-server.md",sourceDirName:"ch20",slug:"/ch20/ch20-01-single-threaded-web-server",permalink:"/rust-book-abridged/ch20/ch20-01-single-threaded-web-server",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ch20/ch20-01-single-threaded-web-server.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"20 - Multithreaded Web Server",permalink:"/rust-book-abridged/category/20---multithreaded-web-server"},next:{title:"20.2 - Turning Our Single-Threaded Server into a Multithreaded Server",permalink:"/rust-book-abridged/ch20/ch20-02-multi-threaded-web-server"}},s={},p=[{value:"HTTP Requests",id:"http-requests",level:2},{value:"Some HTML to Serve",id:"some-html-to-serve",level:2},{value:"Listening to the TCP Connection",id:"listening-to-the-tcp-connection",level:2},{value:"Parsing the Request",id:"parsing-the-request",level:2}],c={toc:p},d="wrapper";function u(e){let{components:t,...n}=e;return(0,a.kt)(d,(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"201---building-a-single-threaded-web-server"},"20.1 - Building a Single-Threaded Web Server"),(0,a.kt)("p",null,"In this chapter we're going to build a simple HTTP server to put together a number of things we've learned so far. As usual, the code for this project is ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/jwalton/rust-book-abridged/tree/master/examples/ch20-single-threaded-web-server"},"available in the GitHub repo"),"."),(0,a.kt)("h2",{id:"http-requests"},"HTTP Requests"),(0,a.kt)("p",null,"An HTTP GET request looks something like:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-txt"},"GET /index.html HTTP/1.1\nHost: example.com\nAccept-Language: en-us\nAccept-Encoding: gzip, deflate\nConnection: Keep-Alive\n\n")),(0,a.kt)("p",null,"Each newline here is actually a CRLF or a ",(0,a.kt)("inlineCode",{parentName:"p"},"\\r\\n"),". The first line is of the format ",(0,a.kt)("inlineCode",{parentName:"p"},"Method Request-URI HTTP-Version CRLF"),". This is followed by one or more ",(0,a.kt)("em",{parentName:"p"},"headers"),", followed by a blank line, and then optionally a body. (For our server, we'll assume only a maniac would send a GET with a body.)"),(0,a.kt)("p",null,"The response looks very similar:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-txt"},"HTTP/1.1 200 OK\nContent-Type: text\nContent-Length: 26\n\n<html>Hello, World!</html>\n")),(0,a.kt)("p",null,"The first line is ",(0,a.kt)("inlineCode",{parentName:"p"},"HTTP-Version Status-Code Reason-Phrase CRLF"),", and this is followed by headers, a blank line, and then the response body."),(0,a.kt)("h2",{id:"some-html-to-serve"},"Some HTML to Serve"),(0,a.kt)("p",null,"Let's create a project:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sh"},"$ cargo new hello\n$ cd hello\n")),(0,a.kt)("p",null,"In order to create a server, first we need something to serve, so we'll create a couple of HTML file:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-html",metastring:'title="hello.html"',title:'"hello.html"'},'<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <title>Hello!</title>\n  </head>\n  <body>\n    <h1>Hello!</h1>\n    <p>Hi from Rust</p>\n  </body>\n</html>\n')),(0,a.kt)("p",null,"and:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-html",metastring:'title="404.html"',title:'"404.html"'},'<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <title>Hello!</title>\n  </head>\n  <body>\n    <h1>Oops!</h1>\n    <p>Sorry, I don\'t know what you\'re asking for.</p>\n  </body>\n</html>\n')),(0,a.kt)("p",null,"And then here is the code for our server:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},'use std::{\n    fs,\n    io::{prelude::*, BufReader},\n    net::{TcpListener, TcpStream},\n};\n\nfn main() {\n    let port = 7878u16;\n    let listen_address = format!("127.0.0.1:{port}");\n    let listener = TcpListener::bind(listen_address).unwrap();\n\n    println!("Listening on port {}", port);\n\n    for stream in listener.incoming() {\n        let stream = stream.unwrap();\n\n        handle_connection(stream);\n    }\n}\n\nfn handle_connection(mut stream: TcpStream) {\n    let buf_reader = BufReader::new(&mut stream);\n\n    // A line could be an error if it contains invalid\n    // UTF-8, or if there\'s a problem reading from the\n    // underlying stream.  We ignore these errors here.\n    let http_request: Vec<_> = buf_reader\n        .lines()\n        .map(|result| result.unwrap())\n        .take_while(|line| !line.is_empty()) // Blank line is end of headers.\n        .collect();\n\n    let request_line = &http_request[0];\n\n    println!("Incoming request for {}", request_line);\n\n    if request_line == "GET / HTTP/1.1" {\n        send_response(stream, 200, "OK", "hello.html");\n    } else {\n        send_response(stream, 404, "NOT FOUND", "404.html");\n    }\n}\n\nfn send_response(mut stream: TcpStream, code: u16, reason: &str, filename: &str) {\n    let contents = fs::read_to_string(filename).unwrap();\n    let length = contents.len();\n    let response =\n        format!("HTTP/1.1 {code} {reason}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}");\n\n    stream.write_all(response.as_bytes()).unwrap();\n}\n')),(0,a.kt)("p",null,"If we ",(0,a.kt)("inlineCode",{parentName:"p"},"cargo run")," this and point a browser at ",(0,a.kt)("a",{parentName:"p",href:"http://localhost:7878/"},"http://localhost:7878/"),", we should see our web page!"),(0,a.kt)("h2",{id:"listening-to-the-tcp-connection"},"Listening to the TCP Connection"),(0,a.kt)("p",null,"Let's start with the ",(0,a.kt)("inlineCode",{parentName:"p"},"main")," function. We call ",(0,a.kt)("inlineCode",{parentName:"p"},"TcpListener::bind")," to start listening on a port. This returns a ",(0,a.kt)("inlineCode",{parentName:"p"},"TcpListener")," instance, so it's basically a constructor for ",(0,a.kt)("inlineCode",{parentName:"p"},"TcpListener"),'. Note that we\'re binding to "127.0.0.1", so you\'ll only be able to access this web server from the same machine you\'re running it on. We could bind to "0.0.0.0" - the ',(0,a.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/std/net/struct.Ipv4Addr.html#method.is_unspecified"},"unspecified address")," - to bind to all local interfaces. ",(0,a.kt)("inlineCode",{parentName:"p"},"bind")," can fail for a variety of reasons. For example, if we tried to bind to port 80 and we weren't root, this would fail because we don't have sufficient permissions, or some other process might have already bound the port. We're glossing over all the error handling with a call to ",(0,a.kt)("inlineCode",{parentName:"p"},"unwrap"),"."),(0,a.kt)("p",null,"Once we have out ",(0,a.kt)("inlineCode",{parentName:"p"},"TcpListener")," we call ",(0,a.kt)("inlineCode",{parentName:"p"},"incoming")," on it, which returns an iterator of ",(0,a.kt)("inlineCode",{parentName:"p"},"Result<TcpStream, Error>"),". We'll get an item from this iterator every time a client tries to connect. Note this iterator will never return ",(0,a.kt)("inlineCode",{parentName:"p"},"None"),"! This loop is going to go on forever (or at least until we hit CTRL-C to terminate this program). A connection attempt can fail for a variety of reasons. In a production web server we'd want to handle these, but here we're once again just calling ",(0,a.kt)("inlineCode",{parentName:"p"},"unwrap"),". Finally we hand of the connection to ",(0,a.kt)("inlineCode",{parentName:"p"},"handle_connection"),"."),(0,a.kt)("h2",{id:"parsing-the-request"},"Parsing the Request"),(0,a.kt)("p",null,"Our ",(0,a.kt)("inlineCode",{parentName:"p"},"handle_connection")," function creates a new buffered reader to read the incoming bytes from the stream. We user our reader to read in the request, split it into lines, then collect lines into a vector until we reach an empty line. As we've seen before, calling ",(0,a.kt)("inlineCode",{parentName:"p"},"collect")," requires us to annotate the type of ",(0,a.kt)("inlineCode",{parentName:"p"},"http_request")," so ",(0,a.kt)("inlineCode",{parentName:"p"},"collect")," will know what kind of collection to return."),(0,a.kt)("p",null,"Once we have our request, we call into ",(0,a.kt)("inlineCode",{parentName:"p"},"send_response")," to generate an appropriate response back to the client."),(0,a.kt)("p",null,"And that's all there is too it! Our server only runs in a single thread, so it can only handle a single request at a time. In the next section, we'll upgrade this server to run ",(0,a.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch20/ch20-02-multi-threaded-web-server"},"in multiple threads"),"."))}u.isMDXComponent=!0}}]);