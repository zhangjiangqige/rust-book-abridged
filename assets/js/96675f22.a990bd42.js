"use strict";(self.webpackChunkrust_book_abridged=self.webpackChunkrust_book_abridged||[]).push([[233],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>c});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),u=p(n),d=i,c=u["".concat(s,".").concat(d)]||u[d]||h[d]||r;return n?a.createElement(c,o(o({ref:t},m),{},{components:n})):a.createElement(c,o({ref:t},m))}));function c(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:i,o[1]=l;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},6688:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var a=n(7462),i=(n(7294),n(3905));const r={},o="10.2 - Traits: Defining Shared Behavior",l={unversionedId:"ch10/ch10-02-traits",id:"ch10/ch10-02-traits",title:"10.2 - Traits: Defining Shared Behavior",description:"A trait in Rust is very similar to what most other languages call an interface. A trait defines some set of behavior, and every struct that implements the trait needs to implement that behavior.",source:"@site/docs/ch10/ch10-02-traits.md",sourceDirName:"ch10",slug:"/ch10/ch10-02-traits",permalink:"/rust-book-abridged/ch10/ch10-02-traits",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ch10/ch10-02-traits.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"10.1 - Generic Data Types",permalink:"/rust-book-abridged/ch10/ch10-01-generic-data-types"},next:{title:"10.3 - Validating References with Lifetimes",permalink:"/rust-book-abridged/ch10/ch10-03-lifetimes"}},s={},p=[{value:"Defining a Trait",id:"defining-a-trait",level:2},{value:"Implementing a Trait on a Type",id:"implementing-a-trait-on-a-type",level:2},{value:"Default Implementations",id:"default-implementations",level:2},{value:"Traits as Parameters",id:"traits-as-parameters",level:2},{value:"Returning Types that Implement Traits",id:"returning-types-that-implement-traits",level:2},{value:"Using Trait Bounds to Conditionally Implement Methods",id:"using-trait-bounds-to-conditionally-implement-methods",level:2},{value:"<code>From</code> and <code>Into</code>",id:"from-and-into",level:2}],m={toc:p},u="wrapper";function h(e){let{components:t,...n}=e;return(0,i.kt)(u,(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"102---traits-defining-shared-behavior"},"10.2 - Traits: Defining Shared Behavior"),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"trait")," in Rust is very similar to what most other languages call an interface. A trait defines some set of behavior, and every struct that implements the trait needs to implement that behavior."),(0,i.kt)("h2",{id:"defining-a-trait"},"Defining a Trait"),(0,i.kt)("p",null,"Let's suppose we have two types, ",(0,i.kt)("inlineCode",{parentName:"p"},"Tweet")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"NewsArticle"),". We might want to be able to get a summary of tweet, and we might want to be able to get a summary of a news article, so it would make sense for both of these to implement a ",(0,i.kt)("inlineCode",{parentName:"p"},"summarize()")," function. We can define a trait called ",(0,i.kt)("inlineCode",{parentName:"p"},"Summary")," that defines the method signature that these types will need to implement:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"pub trait Summary {\n    fn summarize(&self) -> String;\n}\n")),(0,i.kt)("p",null,"Note that the trait only defines the method signatures - the contract, if you will - that the types need to implement. Each type is free to implement this function differently."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"When we name structs, we typically use a noun to name a struct. Functions are typically verbs. Traits in Rust are less consistently named."),(0,i.kt)("p",{parentName:"admonition"},'You might think from the name "trait" that these should be named after adjectives. Or perhaps since traits fill the same role as interfaces in other languages, a noun would be appropriate.  But the trait for a type that implements the ',(0,i.kt)("inlineCode",{parentName:"p"},"read"),' method is neither "Readable" nor "Reader", but ',(0,i.kt)("inlineCode",{parentName:"p"},"Read"),".  A type that can be copied has the ",(0,i.kt)("inlineCode",{parentName:"p"},"Copy"),' marker trait, not the "Copyable" trait.'),(0,i.kt)("p",{parentName:"admonition"},"From these examples - ",(0,i.kt)("inlineCode",{parentName:"p"},"Read")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Copy")," - clearly traits in Rust should be named after verbs! But there are plenty of examples in the standard library that seem to defy this such as ",(0,i.kt)("inlineCode",{parentName:"p"},"Iterator"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Hasher"),", or ",(0,i.kt)("inlineCode",{parentName:"p"},"Sized"),", and the example in ",(0,i.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/rust-by-example/trait.html"},"Rust by Example")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"Animal"),"."),(0,i.kt)("p",{parentName:"admonition"},"This ambiguous naming comes at least in part from the fact that traits are inspired in part by Haskell's typeclasses, which have similar naming weirdness. The best rule of thumb I've seen is that if a trait has a single well defined method (such as ",(0,i.kt)("inlineCode",{parentName:"p"},"write")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"read"),") the the trait should be named after the method. Otherwise, the trait name should be a noun.")),(0,i.kt)("h2",{id:"implementing-a-trait-on-a-type"},"Implementing a Trait on a Type"),(0,i.kt)("p",null,'In languages like TypeScript and Go, if we have an interface, and we have a type that defines all the same methods that the interface declares, then the type implements that interface. There\'s no need to explicitly mark that the type implements the interface. This is called "duck typing", because, as the saying goes, "if it walks like a duck, and it quacks like a duck, then it must be a duck."'),(0,i.kt)("p",null,"Not so in Rust. Here we must explicitly declare that a type implements a trait. The syntax is ",(0,i.kt)("inlineCode",{parentName:"p"},"impl [TRAIT] for [STRUCT] {}"),", and inside the curly braces we place all the methods we need to implement:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'pub struct NewsArticle {\n    pub headline: String,\n    pub location: String,\n    pub author: String,\n    pub content: String,\n}\n\nimpl Summary for NewsArticle {\n    fn summarize(&self) -> String {\n        format!("{}, by {} ({})", self.headline, self.author, self.location)\n    }\n}\n\npub struct Tweet {\n    pub username: String,\n    pub content: String,\n    pub reply: bool,\n    pub retweet: bool,\n}\n\nimpl Summary for Tweet {\n    fn summarize(&self) -> String {\n        format!("{}: {}", self.username, self.content)\n    }\n}\n')),(0,i.kt)("p",null,"This is very similar to defining a method on the struct directly, but the method is actually defined on the trait. If we want to call the ",(0,i.kt)("inlineCode",{parentName:"p"},"summarize")," function, we need to make sure the trait is in scope. In this example we have to ",(0,i.kt)("inlineCode",{parentName:"p"},"use")," both ",(0,i.kt)("inlineCode",{parentName:"p"},"Summary")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Tweet"),", even though ",(0,i.kt)("inlineCode",{parentName:"p"},"Summary")," never appears in the code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'use aggregator::{Summary, Tweet};\n\nfn main() {\n    let tweet = Tweet {\n        username: String::from("horse_ebooks"),\n        content: String::from(\n            "of course, as you probably already know, people",\n        ),\n        reply: false,\n        retweet: false,\n    };\n\n    println!("1 new tweet: {}", tweet.summarize());\n}\n')),(0,i.kt)("p",null,"Other crates can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"Summary")," trait and implement it on their own types, just like you can implement traits from the standard library on your own types. One thing to note is that if you want to implement a trait on a type, then either the trait or the type (or both) must be local to your crate. You can't use a trait from one external crate, a type from another, and then implement the external trait on the external type in your crate."),(0,i.kt)("p",null,"This restriction is in place because of something called the ",(0,i.kt)("em",{parentName:"p"},"orphan rule"),". Let's suppose there's a ",(0,i.kt)("inlineCode",{parentName:"p"},"color")," crate out there. You implement a library crate that uses ",(0,i.kt)("inlineCode",{parentName:"p"},"color"),", but you notice one of the types in ",(0,i.kt)("inlineCode",{parentName:"p"},"color")," doesn't implement the ",(0,i.kt)("inlineCode",{parentName:"p"},"Display")," trait and you want to ",(0,i.kt)("inlineCode",{parentName:"p"},"println!")," a color, so you implement the ",(0,i.kt)("inlineCode",{parentName:"p"},"Display")," trait on that type. Now suppose I'm writing a separate library crate, and I do the same thing. Now suppose someone adds your crate and my crate to their application. At this point, the Rust compiler has two competing implementations for ",(0,i.kt)("inlineCode",{parentName:"p"},"Display"),' on this type, so which one does it use? Since Rust has no way to know which is the "correct" one, Rust just stops this from ever happening by forcing the crate to own at least one of the type or trait.'),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"The orphan rule is actually ",(0,i.kt)("a",{parentName:"p",href:"https://rust-lang.github.io/rfcs/2451-re-rebalancing-coherence.html#concrete-orphan-rules"},"slightly more complicated")," than mentioned above. Once generics start getting involved, it's possible to use a foreign trait and foreign type, given that one of the generic types is local. See the above link for full details.")),(0,i.kt)("h2",{id:"default-implementations"},"Default Implementations"),(0,i.kt)("p",null,"Remember how we said a trait just had signatures and no implementations? Well, we lied a little. Sometimes it's handy to be able to define default behavior for a method:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'pub trait Summary {\n    fn summarize(&self) -> String {\n        String::from("(Read more...)")\n    }\n}\n\n// We can implement this trait with an empty\n// impl block, taking the default function\n// definitions.\nimpl Summary for NewsArticle {}\n')),(0,i.kt)("p",null,"Default implementations are allowed to call other methods on the same trait. This allows a trait to provide a lot of functionality while only requiring implementers to implement part of the trait:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'pub trait Summary {\n    fn summarize_author(&self) -> String;\n\n    fn summarize(&self) -> String {\n        format!("(Read more from {}...)", self.summarize_author())\n    }\n}\n')),(0,i.kt)("p",null,"Some implementations might only implement ",(0,i.kt)("inlineCode",{parentName:"p"},"summarize_author()"),", while some might implement both methods."),(0,i.kt)("h2",{id:"traits-as-parameters"},"Traits as Parameters"),(0,i.kt)("p",null,"When we define a generic function, we can limit what kinds of concrete types are allowed to be used in place of the generic type using a ",(0,i.kt)("em",{parentName:"p"},"trait bound"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'pub fn notify<T: Summary>(item: &T) {\n    println!("Breaking news! {}", item.summarize());\n}\n')),(0,i.kt)("p",null,"Here we're declaring a generic function, but we're setting bounds on the type of T. Whatever you pass in for T has to satisfy the ",(0,i.kt)("inlineCode",{parentName:"p"},"Summary")," trait. This is a common thing to do, so there's a shortcut to specify this using the ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," keyword:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'// This is syntactic sugar for the example above.\npub fn notify(item: &impl Summary) {\n    println!("Breaking news! {}", item.summarize());\n}\n')),(0,i.kt)("p",null,"We can specify more than one trait bound:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"// Using a trait bound:\npub fn notify<T: Summary + Display>(item: &T) {...}\n\n// Using the `impl` syntax:\npub fn notify(item: &(impl Summary + Display)) {...}\n")),(0,i.kt)("p",null,"Here whatever we pass in for ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," must satisfy both our own ",(0,i.kt)("inlineCode",{parentName:"p"},"Summary")," trait and the ",(0,i.kt)("inlineCode",{parentName:"p"},"Display")," trait from the standard library (so we can use ",(0,i.kt)("inlineCode",{parentName:"p"},"{}")," to display the item with ",(0,i.kt)("inlineCode",{parentName:"p"},"println!")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"format!"),")."),(0,i.kt)("p",null,"This can get a bit hard to read if you have a lot of traits bounds. There ends up being a lot of clutter between the name of the function and the parameters. Borrowing a page from SQL, we can also write trait bounds using a ",(0,i.kt)("inlineCode",{parentName:"p"},"where")," clause. These two examples are equivalent:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {...}\n\nfn some_function<T, U>(t: &T, u: &U) -> i32\nwhere\n    T: Display + Clone,\n    U: Clone + Debug,\n{...}\n")),(0,i.kt)("h2",{id:"returning-types-that-implement-traits"},"Returning Types that Implement Traits"),(0,i.kt)("p",null,"We can hide the concrete type returned by a function using an ",(0,i.kt)("a",{parentName:"p",href:"https://rustc-dev-guide.rust-lang.org/opaque-types-type-alias-impl-trait.html"},(0,i.kt)("em",{parentName:"a"},"opaque type")),". This lets us hide the concrete type from the caller (and allows you to change the concrete type later without affecting callers):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'fn returns_summarizable() -> impl Summary {\n    Tweet {\n        username: String::from("horse_ebooks"),\n        content: String::from(\n            "of course, as you probably already know, people",\n        ),\n        reply: false,\n        retweet: false,\n    }\n}\n')),(0,i.kt)("p",null,"Note that even though this ",(0,i.kt)("inlineCode",{parentName:"p"},"impl")," syntax looks similar to the shortcut we used to specify a trait bound above, this is not at all the same. This function is not generic. There is still a single concrete type being returned by this function (in this case ",(0,i.kt)("inlineCode",{parentName:"p"},"Tweet"),"), but callers are limited to only using the interface provided by the trait (in this case ",(0,i.kt)("inlineCode",{parentName:"p"},"Summary"),")."),(0,i.kt)("p",null,"The concrete type here is inferred by the compiler, but it's important to realize there is still one. If you were to add an ",(0,i.kt)("inlineCode",{parentName:"p"},"if")," statement to this function, you would not be able to return a ",(0,i.kt)("inlineCode",{parentName:"p"},"Tweet")," in one branch and a ",(0,i.kt)("inlineCode",{parentName:"p"},"NewsArticle")," in the other. (We'll see how to overcome this with trait objects and dynamic dispatch in ",(0,i.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch17-object-oriented-features#172---using-trait-objects-that-allow-for-values-of-different-types"},"chapter 17"),".)"),(0,i.kt)("p",null,"This syntax is useful if we want to return something that has a concrete type that can't be written down, like a closure:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'fn thing_returning_closure() -> impl Fn(i32) -> bool {\n    println!("here\'s a closure for you!");\n    |x: i32| x % 3 == 0\n}\n')),(0,i.kt)("p",null,"We haven't talked about iterators yet, but sometimes when using an iterator, the type inferred by the compiler can be quite long, and writing the full type out by hand would be a lot of work without much benefit. Being able to supply an opaque type here is much more concise."),(0,i.kt)("h2",{id:"using-trait-bounds-to-conditionally-implement-methods"},"Using Trait Bounds to Conditionally Implement Methods"),(0,i.kt)("p",null,"As we saw ",(0,i.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch10/ch10-01-generic-data-types#in-method-definitions"},"earlier"),", we can specify an implementation for a method on specific types of a generic type. We can similarly implement a method on specific trait bounds:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'use std::fmt::Display;\n\nstruct Pair<T> {\n    x: T,\n    y: T,\n}\n\nimpl<T> Pair<T> {\n    fn new(x: T, y: T) -> Self {\n        Self { x, y }\n    }\n}\n\nimpl<T: Display + PartialOrd> Pair<T> {\n    fn cmp_display(&self) {\n        if self.x >= self.y {\n            println!("The largest member is x = {}", self.x);\n        } else {\n            println!("The largest member is y = {}", self.y);\n        }\n    }\n}\n')),(0,i.kt)("p",null,"Here the ",(0,i.kt)("inlineCode",{parentName:"p"},"new()")," associated function is implemented on all generic types, but ",(0,i.kt)("inlineCode",{parentName:"p"},"cmp_display()")," is only defined on a ",(0,i.kt)("inlineCode",{parentName:"p"},"Pair<T>")," if the inner type used for T implements both the ",(0,i.kt)("inlineCode",{parentName:"p"},"Display")," and the ",(0,i.kt)("inlineCode",{parentName:"p"},"PartialOrd")," traits."),(0,i.kt)("p",null,"We can also conditionally implement a trait for any type that implements some other trait! These are called ",(0,i.kt)("em",{parentName:"p"},"blanket implementations"),". This example comes from the standard library:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"impl<T: Display> ToString for T {\n    // --snip--\n}\n")),(0,i.kt)("p",null,"The implements the ",(0,i.kt)("inlineCode",{parentName:"p"},"ToString")," trait on any type that implements the ",(0,i.kt)("inlineCode",{parentName:"p"},"Display")," trait. Because of this, we can call ",(0,i.kt)("inlineCode",{parentName:"p"},"to_string()")," on any type that implements ",(0,i.kt)("inlineCode",{parentName:"p"},"Display"),"."),(0,i.kt)("h2",{id:"from-and-into"},(0,i.kt)("inlineCode",{parentName:"h2"},"From")," and ",(0,i.kt)("inlineCode",{parentName:"h2"},"Into")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"From")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Into")," are two related traits in rust. These are used to convert a type from one type to another. If you implement ",(0,i.kt)("inlineCode",{parentName:"p"},"From"),", you get ",(0,i.kt)("inlineCode",{parentName:"p"},"Into")," for free. We already mentioned ",(0,i.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch09-error-handling#propagating-errors"},"using the ",(0,i.kt)("inlineCode",{parentName:"a"},"From")," trait to convert Errors")," from one type to another. Let's see another example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'struct Millimeters(u32);\nstruct Meters(u32);\n\nimpl From<Meters> for Millimeters {\n    fn from(value: Meters) -> Self {\n        return Millimeters(value.0 * 1000);\n    }\n}\n\nimpl From<Millimeters> for Meters {\n    fn from(value: Millimeters) -> Self {\n        return Meters(value.0 / 1000);\n    }\n}\n\nfn main() {\n    let one_meter = Meters(1);\n    let millis = Millimeters::from(one_meter);\n    println!("1 meter is {} millimeters", millis.0);\n\n    let one_meter = Meters(1);\n    let into_millis: Millimeters = one_meter.into();\n    println!("1 meter is {} millimeters", into_millis.0);\n}\n')),(0,i.kt)("p",null,"Here ",(0,i.kt)("inlineCode",{parentName:"p"},"Millimeters::from(one_meter)")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"one_meter.into()")," both convert meters into millimeters. When we call ",(0,i.kt)("inlineCode",{parentName:"p"},"into")," the type the meter is converted to is inferred from the annotation on ",(0,i.kt)("inlineCode",{parentName:"p"},"into_millis"),"."),(0,i.kt)("p",null,"Continue to ",(0,i.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch10/ch10-03-lifetimes"},"10.3 - Lifetimes"),"."))}h.isMDXComponent=!0}}]);