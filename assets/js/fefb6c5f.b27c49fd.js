"use strict";(self.webpackChunkrust_book_abridged=self.webpackChunkrust_book_abridged||[]).push([[915],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=p(n),u=i,h=m["".concat(s,".").concat(u)]||m[u]||d[u]||r;return n?a.createElement(h,o(o({ref:t},c),{},{components:n})):a.createElement(h,o({ref:t},c))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[m]="string"==typeof e?e:i,o[1]=l;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},6983:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var a=n(7462),i=(n(7294),n(3905));const r={},o="15 - Smart Pointers",l={unversionedId:"ch15-smart-pointers",id:"ch15-smart-pointers",title:"15 - Smart Pointers",description:"In C++, whenever we want to store an object on the heap, we new that object to allocate some memory. At some later point in time, we have to delete that memory. This is much like malloc and free in standard C.",source:"@site/docs/ch15-smart-pointers.md",sourceDirName:".",slug:"/ch15-smart-pointers",permalink:"/rust-book-abridged/ch15-smart-pointers",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ch15-smart-pointers.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"14 - More about Cargo and Crates",permalink:"/rust-book-abridged/ch14-more-about-cargo"},next:{title:"16 - Fearless Concurrency",permalink:"/rust-book-abridged/ch16-fearless-concurrency"}},s={},p=[{value:"15.1 - Using <code>Box&lt;T&gt;</code> to Point to Data on the Heap",id:"151---using-boxt-to-point-to-data-on-the-heap",level:2},{value:"Enabling Recursive Types with Boxes",id:"enabling-recursive-types-with-boxes",level:3},{value:"15.2 Treating Smart Pointers Like Regular References with the <code>Deref</code> Trait",id:"152-treating-smart-pointers-like-regular-references-with-the-deref-trait",level:2},{value:"Following the Pointer to the Value",id:"following-the-pointer-to-the-value",level:3},{value:"Using <code>Box&lt;T&gt;</code> Like a Reference",id:"using-boxt-like-a-reference",level:3},{value:"Defining Our Own Smart Pointer",id:"defining-our-own-smart-pointer",level:3},{value:"Implicit Deref Coercions with Functions and Methods",id:"implicit-deref-coercions-with-functions-and-methods",level:3},{value:"How Deref Coercion Interacts with Mutability",id:"how-deref-coercion-interacts-with-mutability",level:3},{value:"15.3 - Running Code on Cleanup with the <code>Drop</code> trait",id:"153---running-code-on-cleanup-with-the-drop-trait",level:2},{value:"Dropping a Value Early with <code>std::mem::drop</code>",id:"dropping-a-value-early-with-stdmemdrop",level:3},{value:"15.4 - <code>Rc&lt;T&gt;</code>, the Reference Counted Smart Pointer",id:"154---rct-the-reference-counted-smart-pointer",level:2},{value:"Using <code>Rc&lt;T&gt;</code> to Share Data",id:"using-rct-to-share-data",level:3},{value:"15.5 - <code>RefCell&lt;T&gt;</code> and the Interior Mutability Pattern",id:"155---refcellt-and-the-interior-mutability-pattern",level:2},{value:"A Use Case for Interior Mutability: Mock Objects",id:"a-use-case-for-interior-mutability-mock-objects",level:3},{value:"Having Multiple Owners of Mutable Data by Combining <code>Rc&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code>",id:"having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt",level:3},{value:"15.6 - Reference Cycles Can Leak Memory",id:"156---reference-cycles-can-leak-memory",level:2},{value:"Creating a Reference Cycle",id:"creating-a-reference-cycle",level:3},{value:"Preventing Reference Cycles: Turning an <code>Rc&lt;T&gt;</code> into a <code>Weak&lt;T&gt;</code>",id:"preventing-reference-cycles-turning-an-rct-into-a-weakt",level:3}],c={toc:p},m="wrapper";function d(e){let{components:t,...r}=e;return(0,i.kt)(m,(0,a.Z)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"15---smart-pointers"},"15 - Smart Pointers"),(0,i.kt)("p",null,"In C++, whenever we want to store an object on the heap, we ",(0,i.kt)("inlineCode",{parentName:"p"},"new")," that object to allocate some memory. At some later point in time, we have to ",(0,i.kt)("inlineCode",{parentName:"p"},"delete")," that memory. This is much like ",(0,i.kt)("inlineCode",{parentName:"p"},"malloc")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"free")," in standard C."),(0,i.kt)("p",null,'C++ has a few different "smart pointers" that will delete that memory for you at the appropriate time. The most commonly used is probably ',(0,i.kt)("inlineCode",{parentName:"p"},"shared_ptr"),", which keeps a ",(0,i.kt)("em",{parentName:"p"},"reference count")," on the heap. Every time your clone a ",(0,i.kt)("inlineCode",{parentName:"p"},"shared_ptr")," it increments the reference count (which is shared between all the clones), and every time one is destroyed it decrements the count. Once the count reaches 0, ",(0,i.kt)("inlineCode",{parentName:"p"},"shared_ptr")," knows there are no more references to the underlying memory so it is safe to be freed."),(0,i.kt)("p",null,"Rust has a variety of smart pointer objects as well, which allow us to store values on the heap, including ",(0,i.kt)("inlineCode",{parentName:"p"},"Rc<T>")," which works much like C++'s ",(0,i.kt)("inlineCode",{parentName:"p"},"shared_ptr")," and allows us to effectively share ownership of a value across multiple variables in code. This chapter will explore a few of the different smart pointer implementations in Rust and where you might want to use them."),(0,i.kt)("p",null,"Smart pointers in Rust generally implement the ",(0,i.kt)("inlineCode",{parentName:"p"},"Drop")," trait (so they can run some custom code when they are dropped, like decrementing a reference count) and the ",(0,i.kt)("inlineCode",{parentName:"p"},"Deref")," trait (which lets a smart pointer be used in place of a reference to the underlying value)."),(0,i.kt)("h2",{id:"151---using-boxt-to-point-to-data-on-the-heap"},"15.1 - Using ",(0,i.kt)("inlineCode",{parentName:"h2"},"Box<T>")," to Point to Data on the Heap"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Box<T>"),' is perhaps the "least smart" of the smart pointers. ',(0,i.kt)("inlineCode",{parentName:"p"},"Box<T>")," lets us store a single piece of data on the heap instead of on the stack:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},'fn main() {\n    let b = Box::new(5);\n    println!("b = {}", b);\n}\n')),(0,i.kt)("p",null,'Here "5" gets stored as four bytes on the heap instead of as four bytes on the stack. Notice that we can use ',(0,i.kt)("inlineCode",{parentName:"p"},"b")," exactly like a ",(0,i.kt)("inlineCode",{parentName:"p"},"&i32")," when we pass it to ",(0,i.kt)("inlineCode",{parentName:"p"},"println!"),"."),(0,i.kt)("p",null,"Why would we want to do this? When we're passing data around on the stack, Rust has to know the size of that data at compile time. When we pass an ",(0,i.kt)("inlineCode",{parentName:"p"},"i32")," as a parameter, for example, Rust knows that it's going to need 4 bytes on the stack to hold that parameter. But sometimes we don't know the size of a value ahead of time, and this is where ",(0,i.kt)("inlineCode",{parentName:"p"},"Box<T>")," is useful - examples would be recursive data structures (which can be \"infinitely\" large since they can contain more of themselves) and trait objects, where we want to claim that a parameter implements a specific trait but we don't care what concrete type the parameter is (we'll talk more about these in ",(0,i.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch17-object-oriented-features#172---using-trait-objects-that-allow-for-values-of-different-types"},"chapter 17"),")."),(0,i.kt)("p",null,"In these cases, instead of passing the value directly on the stack, we pass the ",(0,i.kt)("inlineCode",{parentName:"p"},"Box<T>")," on the stack and put the unknown-sized value on the heap. The size of ",(0,i.kt)("inlineCode",{parentName:"p"},"Box<T>")," is known at compile time, so the compiler can do it's thing."),(0,i.kt)("p",null,"Another example where ",(0,i.kt)("inlineCode",{parentName:"p"},"Box<T>")," would be useful is where you have some particularly large piece of data that you want to pass around. Values passed on the stack are pass-by-copy, and copying large amounts of data can be inefficient. Storing the data on the heap lets us pass around copies of the relatively small ",(0,i.kt)("inlineCode",{parentName:"p"},"Box<T>")," instead."),(0,i.kt)("h3",{id:"enabling-recursive-types-with-boxes"},"Enabling Recursive Types with Boxes"),(0,i.kt)("p",null,"This is a data structure called the ",(0,i.kt)("em",{parentName:"p"},"cons list")," which we're going to borrow from lisp:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"enum List {\n    Cons(i32, List),\n    Nil,\n}\n")),(0,i.kt)("p",null,'This is sort of a "linked list", where each item is either an ',(0,i.kt)("inlineCode",{parentName:"p"},"i32"),' and a "next item on the list", or else is ',(0,i.kt)("inlineCode",{parentName:"p"},"Nil")," (to signify the end of the list). We could use this like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"use List::{Cons, Nil}\n\nfn main() {\n    let list = Cons(1, Cons(2, Cons(3, Nil)));\n}\n")),(0,i.kt)("p",null,"This is probably not a data structure you'd actually want to use in Rust, but it's a recursive data structure that's convenient for this example. If you try to compile the above, it will fail, because Rust can't work out the size of the ",(0,i.kt)("inlineCode",{parentName:"p"},"list")," variable to store it on the stack."),(0,i.kt)("p",null,"For an enum, Rust will allocate enough memory to store the largest of the enum's variants. Here the largest is going to be ",(0,i.kt)("inlineCode",{parentName:"p"},"Cons"),", which can hold an ",(0,i.kt)("inlineCode",{parentName:"p"},"i32")," and a ",(0,i.kt)("inlineCode",{parentName:"p"},"List"),", so it's four bytes long plus the size of a ",(0,i.kt)("inlineCode",{parentName:"p"},"List"),". But this is a recursive definition - ",(0,i.kt)("inlineCode",{parentName:"p"},"sizeof(List) = 4 + sizeof(List)"),". This makes ",(0,i.kt)("inlineCode",{parentName:"p"},"rustc")," an unhappy compiler."),(0,i.kt)("p",null,"The solution is to move this to the heap:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},"use List::{Cons, Nil}\n\nenum List {\n    Cons(i32, Box<List>),\n    Nil,\n}\n\nfn main() {\n    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));\n}\n")),(0,i.kt)("p",null,"Now ",(0,i.kt)("inlineCode",{parentName:"p"},"sizeof(Cons) = 4 + sizeof(Box<List>)"),", and the size of ",(0,i.kt)("inlineCode",{parentName:"p"},"Box<List>")," doesn't depend on the size of ",(0,i.kt)("inlineCode",{parentName:"p"},"<List>")," (since that part is stored on the heap), so the size of the ",(0,i.kt)("inlineCode",{parentName:"p"},"list")," variable is known at compile time."),(0,i.kt)("h2",{id:"152-treating-smart-pointers-like-regular-references-with-the-deref-trait"},"15.2 Treating Smart Pointers Like Regular References with the ",(0,i.kt)("inlineCode",{parentName:"h2"},"Deref")," Trait"),(0,i.kt)("p",null,"In this section we're going to implement our own smart pointer called ",(0,i.kt)("inlineCode",{parentName:"p"},"MyBox"),". Our smart pointer won't actually store anything on the heap, it will just store things on the stack. It will be even less smart than a regular ",(0,i.kt)("inlineCode",{parentName:"p"},"Box<T>"),", but it will give us a chance to explore the ",(0,i.kt)("inlineCode",{parentName:"p"},"Deref")," trait."),(0,i.kt)("h3",{id:"following-the-pointer-to-the-value"},"Following the Pointer to the Value"),(0,i.kt)("p",null,"Before we talk about ",(0,i.kt)("inlineCode",{parentName:"p"},"Deref"),", let's talk about what we mean by dereferencing."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},"fn main() {\n    let x = 5;\n    let y = &x;\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y);\n}\n")),(0,i.kt)("p",null,"Here ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," is of type ",(0,i.kt)("inlineCode",{parentName:"p"},"i32"),", but ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," is of type ",(0,i.kt)("inlineCode",{parentName:"p"},"&i32"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," is essentially a pointer to ",(0,i.kt)("inlineCode",{parentName:"p"},"x"),". We can assert that x is equal to 5, but in order to get to the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," we have to ",(0,i.kt)("em",{parentName:"p"},"dereference")," it to get to the value that ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," points to. Rust will automatically dereference a value for you in many places, so the ",(0,i.kt)("inlineCode",{parentName:"p"},"*")," operator doesn't get much use in Rust, but there are places (like in this example) where it is required."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"If you're coming from a language like C or Go, this is probably second nature to you. If you're coming from JavaScript, this might be a new concept. Because ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," here points to the memory that stores the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," value, you can think about ",(0,i.kt)("inlineCode",{parentName:"p"},"*y")," as basically an alias for ",(0,i.kt)("inlineCode",{parentName:"p"},"x"),". If ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," were mutable and we declared ",(0,i.kt)("inlineCode",{parentName:"p"},"y")," as ",(0,i.kt)("inlineCode",{parentName:"p"},"&mut"),", we could use ",(0,i.kt)("inlineCode",{parentName:"p"},"*y")," to change x because it points to the memory where ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," is stored:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},"fn main() {\n    let mut x = 5;\n    let y = &mut x;\n    *y = 10;\n    assert_eq!(10, x);\n}\n")),(0,i.kt)("p",{parentName:"admonition"},"Another way to think about this is that a reference in Rust is a little bit like a ",(0,i.kt)("inlineCode",{parentName:"p"},"Ref")," from React that points to an object:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="typescript.ts"',title:'"typescript.ts"'},"interface Num {\n  value: number;\n}\n\ninterface Ref<T> {\n  current: T;\n}\n\nfunction main() {\n  const x: Num = { value: 5 };\n  const y: Ref<Num> = { current: x };\n\n  assert.equal(x.value, 5);\n  assert.equal(y.current.value, 5);\n}\n")),(0,i.kt)("p",{parentName:"admonition"},"In our Rust example, the ",(0,i.kt)("inlineCode",{parentName:"p"},"*y")," is basically doing the same thing as ",(0,i.kt)("inlineCode",{parentName:"p"},"y.current")," in our TypeScript example.")),(0,i.kt)("h3",{id:"using-boxt-like-a-reference"},"Using ",(0,i.kt)("inlineCode",{parentName:"h3"},"Box<T>")," Like a Reference"),(0,i.kt)("p",null,"Because ",(0,i.kt)("inlineCode",{parentName:"p"},"Box<T>")," implements ",(0,i.kt)("inlineCode",{parentName:"p"},"Deref"),", we can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"*")," operator on it, and treat it just like a reference. This (combined with a Rust feature called ",(0,i.kt)("em",{parentName:"p"},"deref coercion"),") means that any function that takes a ",(0,i.kt)("inlineCode",{parentName:"p"},"&i32")," can also take a ",(0,i.kt)("inlineCode",{parentName:"p"},"&Box<i32>"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},'fn show_value(v: &i32) {\n    println!("{v}");\n}\n\nfn main() {\n    let x = 5;\n    let y = Box::new(x);\n\n    show_value(&x); // Prints 5\n    show_value(&y); // Prints 5\n}\n')),(0,i.kt)("h3",{id:"defining-our-own-smart-pointer"},"Defining Our Own Smart Pointer"),(0,i.kt)("p",null,"Let's create our own smart pointer so we can implement the ",(0,i.kt)("inlineCode",{parentName:"p"},"Deref"),' trait. To do this we\'ll create a simple "pointer" that stores a value in a generic named tuple:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"struct MyBox<T>(T);\n\nimpl<T> MyBox<T> {\n    fn new(x: T) -> MyBox<T> {\n        MyBox(x)\n    }\n}\n")),(0,i.kt)("p",null,"And then, in order to let us use the ",(0,i.kt)("inlineCode",{parentName:"p"},"*")," operator on ",(0,i.kt)("inlineCode",{parentName:"p"},"MyBox<T>"),", we implement the ",(0,i.kt)("inlineCode",{parentName:"p"},"Deref")," trait. This trait has only one required method for us to implement called ",(0,i.kt)("inlineCode",{parentName:"p"},"deref"),", which borrows self and returns the inner value:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"use std::ops::Deref;\n\nimpl<T> Deref for MyBox<T> {\n    type Target = T;\n\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\n")),(0,i.kt)("p",null,"(Since many other languages don't have tuples, a quick reminder here that in the ",(0,i.kt)("inlineCode",{parentName:"p"},"deref")," method ",(0,i.kt)("inlineCode",{parentName:"p"},"self")," here is a tuple, so ",(0,i.kt)("inlineCode",{parentName:"p"},"self.0")," is the first (and only) element in the tuple, and ",(0,i.kt)("inlineCode",{parentName:"p"},"&self.0")," returns a reference to the first element in the tuple.)"),(0,i.kt)("p",null,"And now we can do:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},"fn main() {\n    let x = 5;\n    let y = MyBox::new(x);\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y);\n}\n")),(0,i.kt)("p",null,"When we write ",(0,i.kt)("inlineCode",{parentName:"p"},"*y")," here (or on any object that implements ",(0,i.kt)("inlineCode",{parentName:"p"},"Deref"),"), what's actually happening is Rust is going to replace this with ",(0,i.kt)("inlineCode",{parentName:"p"},"*(y.deref())"),"."),(0,i.kt)("h3",{id:"implicit-deref-coercions-with-functions-and-methods"},"Implicit Deref Coercions with Functions and Methods"),(0,i.kt)("p",null,"We've noted before that you can pass a ",(0,i.kt)("inlineCode",{parentName:"p"},"&String")," to a function that expects a ",(0,i.kt)("inlineCode",{parentName:"p"},"&str"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},'fn hello(name: &str) {\n    println!("Hello, {name}!");\n}\n\nfn main() {\n    let x = String::from("Rust");\n    hello(&x);\n}\n')),(0,i.kt)("p",null,"The reason this works is because of a feature called ",(0,i.kt)("em",{parentName:"p"},"deref coercion"),". If we call a function that takes a reference to type ",(0,i.kt)("inlineCode",{parentName:"p"},"X"),", but instead we pass a reference to type ",(0,i.kt)("inlineCode",{parentName:"p"},"Y"),", then if ",(0,i.kt)("inlineCode",{parentName:"p"},"Y")," implements ",(0,i.kt)("inlineCode",{parentName:"p"},"Deref")," Rust will call ",(0,i.kt)("inlineCode",{parentName:"p"},"deref")," on the value we passed in (possible more than once!) to convert it into a reference to the correct type. For example, ",(0,i.kt)("inlineCode",{parentName:"p"},"String")," ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/rust-lang/rust/blob/b0884a3528c45a5d575e182f407c759d243fdcba/library/alloc/src/string.rs#L2442-L2450"},"implements the ",(0,i.kt)("inlineCode",{parentName:"a"},"Deref")," trait")," and returns a ",(0,i.kt)("inlineCode",{parentName:"p"},"&str"),", so Rust can automatically convert a ",(0,i.kt)("inlineCode",{parentName:"p"},"&String")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"&str"),"."),(0,i.kt)("p",null,"If we were to pass a ",(0,i.kt)("inlineCode",{parentName:"p"},"&MyBox<String>")," to the ",(0,i.kt)("inlineCode",{parentName:"p"},"hello")," function above, Rust would convert it to a ",(0,i.kt)("inlineCode",{parentName:"p"},"&String")," via ",(0,i.kt)("inlineCode",{parentName:"p"},"MyBox"),"'s ",(0,i.kt)("inlineCode",{parentName:"p"},"deref")," method, and then into a ",(0,i.kt)("inlineCode",{parentName:"p"},"&str")," via ",(0,i.kt)("inlineCode",{parentName:"p"},"String"),"'s ",(0,i.kt)("inlineCode",{parentName:"p"},"deref")," method."),(0,i.kt)("p",null,"If Rust didn't implement deref coercion, we'd have to write something like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},'fn main() {\n    let m = MyBox::new(String::from("Rust"));\n    hello(&(*m)[..]);\n}\n')),(0,i.kt)("p",null,"And no one wants to write that."),(0,i.kt)("h3",{id:"how-deref-coercion-interacts-with-mutability"},"How Deref Coercion Interacts with Mutability"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Deref")," trait only works with immutable references, but there is also a ",(0,i.kt)("inlineCode",{parentName:"p"},"DerefMut")," trait for mutable references. Rust will do deref coercion in three cases:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If you have a ",(0,i.kt)("inlineCode",{parentName:"li"},"&T")," and you want an ",(0,i.kt)("inlineCode",{parentName:"li"},"&U"),", then if ",(0,i.kt)("inlineCode",{parentName:"li"},"T")," implements ",(0,i.kt)("inlineCode",{parentName:"li"},"Deref")," to type ",(0,i.kt)("inlineCode",{parentName:"li"},"&U"),", then rust will take care of this for you, just like we saw above."),(0,i.kt)("li",{parentName:"ul"},"If you have a ",(0,i.kt)("inlineCode",{parentName:"li"},"&mut T")," and want an ",(0,i.kt)("inlineCode",{parentName:"li"},"&mut U"),", this will happen in exactly the same way but here the conversion will happen via the ",(0,i.kt)("inlineCode",{parentName:"li"},"DerefMut")," trait instead."),(0,i.kt)("li",{parentName:"ul"},"If you have a ",(0,i.kt)("inlineCode",{parentName:"li"},"&mut T")," and you want a ",(0,i.kt)("inlineCode",{parentName:"li"},"&U"),", then Rust will use the ",(0,i.kt)("inlineCode",{parentName:"li"},"Deref")," trait on type ",(0,i.kt)("inlineCode",{parentName:"li"},"T")," to convert the mutable ref to an immutable ",(0,i.kt)("inlineCode",{parentName:"li"},"&U"),".")),(0,i.kt)("p",null,"Obviously ownership rules prevent Rust from automatically converting a ",(0,i.kt)("inlineCode",{parentName:"p"},"&T")," to a ",(0,i.kt)("inlineCode",{parentName:"p"},"&mut U"),"."),(0,i.kt)("h2",{id:"153---running-code-on-cleanup-with-the-drop-trait"},"15.3 - Running Code on Cleanup with the ",(0,i.kt)("inlineCode",{parentName:"h2"},"Drop")," trait"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Drop")," trait allows us to specify some code that must be run whenever a struct is dropped (i.e. when it goes out of scope). ",(0,i.kt)("inlineCode",{parentName:"p"},"Box<T>")," implements ",(0,i.kt)("inlineCode",{parentName:"p"},"Drop")," so it can clean up the memory it is using on the heap. The ",(0,i.kt)("inlineCode",{parentName:"p"},"Rc<T>")," type (which will talk about in the ",(0,i.kt)("a",{parentName:"p",href:"#154---rct-the-reference-counted-smart-pointer"},"next section"),") implements ",(0,i.kt)("inlineCode",{parentName:"p"},"Drop")," so it can decrement a reference count."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Drop")," can also be used to clean up other resources. If you have a struct that opens a network connection in its constructor, you can implement the ",(0,i.kt)("inlineCode",{parentName:"p"},"Drop")," trait to ensure the network connection is closed when the struct is dropped, ensuring you won't leak any resources. This is a pattern borrowed from C++ called ",(0,i.kt)("a",{parentName:"p",href:"https://en.cppreference.com/w/cpp/language/raii"},'"Resource Acquisition Is Initialization" or RAII'),"."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Drop")," trait is included in the prelude, and has only one required method named ",(0,i.kt)("inlineCode",{parentName:"p"},"drop"),". Let's see an example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},'struct CustomSmartPointer {\n    data: String,\n}\n\nimpl Drop for CustomSmartPointer {\n    fn drop(&mut self) {\n        println!("Dropping CustomSmartPointer with data `{}`!", self.data);\n    }\n}\n\nfn main() {\n    let c = CustomSmartPointer {\n        data: String::from("my stuff"),\n    };\n    let d = CustomSmartPointer {\n        data: String::from("other stuff"),\n    };\n    println!("CustomSmartPointers created.");\n\n    // `drop` is called automatically on `c`\n    // and `d` here.\n}\n')),(0,i.kt)("p",null,"If you run this, you'll see the ",(0,i.kt)("inlineCode",{parentName:"p"},"drop")," method gets called automatically for ",(0,i.kt)("inlineCode",{parentName:"p"},"c")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"d")," when they get dropped at the end of ",(0,i.kt)("inlineCode",{parentName:"p"},"main"),"."),(0,i.kt)("h3",{id:"dropping-a-value-early-with-stdmemdrop"},"Dropping a Value Early with ",(0,i.kt)("inlineCode",{parentName:"h3"},"std::mem::drop")),(0,i.kt)("p",null,"Sometimes we may want to drop a value earlier than it would normally get dropped at the end of the scope. For example, if we're using the RAII pattern to acquire some resource like a lock or a network connection, we may want to drop that value early to release that resource before we reach the end of the function."),(0,i.kt)("p",null,"We cannot simply call the ",(0,i.kt)("inlineCode",{parentName:"p"},"drop")," method on a type, however, as the Rust compiler is going to call it for us, and we don't want to ",(0,i.kt)("em",{parentName:"p"},"double free")," any memory or resources by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"drop")," twice. Instead we can call ",(0,i.kt)("inlineCode",{parentName:"p"},"std::mem::drop"),", passing in the value we want to drop:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let c = CustomSmartPointer {\n        data: String::from("some data"),\n    };\n    println!("CustomSmartPointer created.");\n    drop(c);\n    println!("CustomSmartPointer dropped before the end of main.");\n}\n')),(0,i.kt)("h2",{id:"154---rct-the-reference-counted-smart-pointer"},"15.4 - ",(0,i.kt)("inlineCode",{parentName:"h2"},"Rc<T>"),", the Reference Counted Smart Pointer"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Rc<T>")," is a ",(0,i.kt)("em",{parentName:"p"},"reference counting")," smart pointer (this is why it's named ",(0,i.kt)("inlineCode",{parentName:"p"},"Rc"),"), conceptually very similar to C++'s ",(0,i.kt)("inlineCode",{parentName:"p"},"shared_ptr"),". Note that ",(0,i.kt)("inlineCode",{parentName:"p"},"Rc<T>")," isn't thread safe - we'll talk about a multithreaded alternative called ",(0,i.kt)("inlineCode",{parentName:"p"},"Arc<T>")," in ",(0,i.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch16-fearless-concurrency",title:"Chapter 16: Fearless Concurrency"},"chapter 16"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"Rc<T>")," is used in the case where we have some data we want to use in multiple places, but we're not sure at compile time who is going to be finished with this data first."),(0,i.kt)("p",null,"If we model a graph as a collection of edges and nodes, then we might decide that an edge owns the nodes it connects to. But, any node could be connected to by multiple edges, and in Rust any piece of data can only have one owner. What we want want is for a node to be dropped once it's no longer attached to any edges, so we want some kind of shared ownership."),(0,i.kt)("p",null,"The idea behind ",(0,i.kt)("inlineCode",{parentName:"p"},"Rc<T>")," is that it allocates some data on the heap and a counter on the heap, and sets that counter to 1. Whenever we make a clone of an ",(0,i.kt)("inlineCode",{parentName:"p"},"Rc<T>"),", the clone points to the same memory and the same counter, and increments the counter by one. Whenever an ",(0,i.kt)("inlineCode",{parentName:"p"},"Rc<T>")," is dropped, it decrements the counter by 1 and if the counter is 0 then it can safely free the memory on the heap. Each instance of ",(0,i.kt)("inlineCode",{parentName:"p"},"Rc<T>")," is only owned by one variable, just like normal Rust ownership rules. ",(0,i.kt)("inlineCode",{parentName:"p"},"Rc<T>")," is quite a small data structure - really just a pointer - so it is quite inexpensive to copy. The end result is something that looks and behaves a lot lie multiple ownership."),(0,i.kt)("h3",{id:"using-rct-to-share-data"},"Using ",(0,i.kt)("inlineCode",{parentName:"h3"},"Rc<T>")," to Share Data"),(0,i.kt)("p",null,"Let's see a concrete example. Lets go back to our cons list, but we'll do something slightly unusual, and join three lists together:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},"enum List {\n    Cons(i32, Box<List>),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\n\nfn main() {\n    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));\n    let b = Cons(3, Box::new(a));\n    let c = Cons(4, Box::new(a)); // This doesn't work!\n}\n")),(0,i.kt)("p",null,"We have list ",(0,i.kt)("inlineCode",{parentName:"p"},"a"),", and then we make this the tail of both list ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," and list ",(0,i.kt)("inlineCode",{parentName:"p"},"c"),". We're essentially trying to create this data structure:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Diagram of Cons list",src:n(511).Z,width:"580",height:"174"})),(0,i.kt)("p",null,"The problem we're going to run into here is that the ",(0,i.kt)("inlineCode",{parentName:"p"},"Box<T>")," type owns the value we put in it, so when we create ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," we move ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," into a ",(0,i.kt)("inlineCode",{parentName:"p"},"Box<T>"),". When we try to create ",(0,i.kt)("inlineCode",{parentName:"p"},"c"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," has already been moved, so we can't move it again."),(0,i.kt)("p",null,"We could fix this particular example with some lifetime references, but that won't work in all situations, so instead we'll fix this with ",(0,i.kt)("inlineCode",{parentName:"p"},"Rc<T>"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},'enum List {\n    Cons(i32, Rc<List>),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\nuse std::rc::Rc;\n\nfn main() {\n    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));\n    let b = Cons(3, Rc::clone(&a));\n    let c = Cons(4, Rc::clone(&a));\n\n    println!("count after creating c = {}", Rc::strong_count(&a));\n}\n')),(0,i.kt)("p",null,"Now instead ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," is an ",(0,i.kt)("inlineCode",{parentName:"p"},"Rc"),", and instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"c")," taking ownership of ",(0,i.kt)("inlineCode",{parentName:"p"},"a"),", they each make a clone of ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," instead. Each clone increments ",(0,i.kt)("inlineCode",{parentName:"p"},"Rc<T>"),"'s internal reference count by one."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"We could have called ",(0,i.kt)("inlineCode",{parentName:"p"},"a.clone()")," instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"Rc::clone(&a)")," here - these do the same thing. We use ",(0,i.kt)("inlineCode",{parentName:"p"},"Rc::clone")," for reasons of convention. For most types, ",(0,i.kt)("inlineCode",{parentName:"p"},"a.clone()")," would perform a deep copy of the value and all of it's data, so a call to ",(0,i.kt)("inlineCode",{parentName:"p"},"a.clone()")," stands out to the experienced Rust programmer as a potential performance problem. Here we use ",(0,i.kt)("inlineCode",{parentName:"p"},"Rc::clone(&a)")," instead to signal to the reader \"This is OK, we're just cloning an ",(0,i.kt)("inlineCode",{parentName:"p"},"Rc<T>"),".")),(0,i.kt)("p",null,"We've also shown here that we can get the reference count out of an ",(0,i.kt)("inlineCode",{parentName:"p"},"Rc<T>"),". Try experimenting with the above code and see what the count is at various points during execution. If you create a scope around ",(0,i.kt)("inlineCode",{parentName:"p"},"c"),", you can see the reference count decrement when ",(0,i.kt)("inlineCode",{parentName:"p"},"c")," is dropped. You may have noticed that we're calling ",(0,i.kt)("inlineCode",{parentName:"p"},"Rc::strong_count")," to get the reference count. If you know what a weak reference is, you'll be unsurprised to learn there's also an ",(0,i.kt)("inlineCode",{parentName:"p"},"Rc::weak_count"),", which we'll hear about more a little ",(0,i.kt)("a",{parentName:"p",href:"#preventing-reference-cycles-turning-an-rct-into-a-weakt"},"later in this chapter"),"."),(0,i.kt)("p",null,"Since there are multiple references to the data held by ",(0,i.kt)("inlineCode",{parentName:"p"},"Rc<T>"),", then by Rust ownership rules, this data is going to be read only - we can't get a mutable reference to it."),(0,i.kt)("h2",{id:"155---refcellt-and-the-interior-mutability-pattern"},"15.5 - ",(0,i.kt)("inlineCode",{parentName:"h2"},"RefCell<T>")," and the Interior Mutability Pattern"),(0,i.kt)("p",null,"Suppose for a moment that you're a Rust developer working on a bug in the Rust standard library. You want to keep track of how many times ",(0,i.kt)("inlineCode",{parentName:"p"},"to_lowercase")," is called on a particular string. No problem, you can add a private field to the ",(0,i.kt)("inlineCode",{parentName:"p"},"String")," struct called ",(0,i.kt)("inlineCode",{parentName:"p"},"to_lowercase_called")," and increment it every time someone calls ",(0,i.kt)("inlineCode",{parentName:"p"},"to_lowercase"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"pub fn to_lowercase(&self) -> String {\n    self.to_lowercase_called += 1; // This won't compile.\n    // --snip--\n")),(0,i.kt)("p",null,"This would work in most languages, but in Rust ",(0,i.kt)("inlineCode",{parentName:"p"},"to_lowercase")," borrows an immutable reference to ",(0,i.kt)("inlineCode",{parentName:"p"},"self"),", so we can't mutate ",(0,i.kt)("inlineCode",{parentName:"p"},"self"),". And obviously we can't change the signature of ",(0,i.kt)("inlineCode",{parentName:"p"},"to_lowercase")," without potentially breaking many places where it is called. The problem here is that Rust's concept of \"immutability\" is getting in the way. You and I know that incrementing a counter like this won't materially affect how this string looks from its outside API, and incrementing this counter won't affect any existing uses of String, but Rust has no way of knowing that."),(0,i.kt)("p",null,"There's a design pattern in Rust called ",(0,i.kt)("em",{parentName:"p"},"interior mutability")," which is designed to overcome this sort of problem. Essentially we have some data structure that as a whole is immutable, but we want to be able to mutate individual parts of it. The primitive that Rust uses to enable this is called ",(0,i.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/core/cell/struct.UnsafeCell.html"},"an ",(0,i.kt)("inlineCode",{parentName:"a"},"UnsafeCell<T>")),' which basically lets us "opt out" of immutability guarantees for references. Using an ',(0,i.kt)("inlineCode",{parentName:"p"},"UnsafeCell<T>")," directly involves writing unsafe code (see ",(0,i.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch19/ch19-01-unsafe"},"chapter 19"),'), but most commonly you\'d use two "safe" wrappers around ',(0,i.kt)("inlineCode",{parentName:"p"},"UnsafeCell"),", which are ",(0,i.kt)("inlineCode",{parentName:"p"},"Cell<T>")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"RefCell<T>"),"."),(0,i.kt)("p",null,"As a concrete example, here's how you might use a ",(0,i.kt)("inlineCode",{parentName:"p"},"Cell<T>")," to implement our counter in ",(0,i.kt)("inlineCode",{parentName:"p"},"to_lowercase"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"pub struct String {\n    to_lowercase_called: RefCell<usize>,\n    // --snip--\n}\n\nimpl String {\n    pub fn to_lowercase(&self) -> String {\n        let old_count = self.to_lowercase_called.get();\n        self.to_lowercase_called.set(old_count + 1);\n        // --snip--\n    }\n}\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Cell<T>")," is a smart pointer, a bit like a ",(0,i.kt)("inlineCode",{parentName:"p"},"Box<T>")," - it stores a single value, and you're allowed to ",(0,i.kt)("inlineCode",{parentName:"p"},"get")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"set")," the value contained inside, even if all you have is an immutable reference to the ",(0,i.kt)("inlineCode",{parentName:"p"},"Cell<T>"),". The problem with ",(0,i.kt)("inlineCode",{parentName:"p"},"Cell<T>")," is that since you don't have Rust's compile time checks ensuring you only have a single mutable reference at a time, it's easy to write code with a ",(0,i.kt)("inlineCode",{parentName:"p"},"Cell<T>")," that has race conditions."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"RefCell<T>")," is similar in concept, but it lets us borrow a reference to the value inside by calling the ",(0,i.kt)("inlineCode",{parentName:"p"},"borrow")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"borrow_mut")," methods.  Those borrows are checked the same way normal borrows are - we can have a single mutable reference to the value inside, or multiple immutable references, but not both at the same time. As is usually the case where ",(0,i.kt)("inlineCode",{parentName:"p"},"unsafe")," code is involved, ",(0,i.kt)("inlineCode",{parentName:"p"},"RefCell<T>")," makes some trade offs that we need to be aware of. The difference between a ",(0,i.kt)("inlineCode",{parentName:"p"},"RefCell<T>")," and normal mutability rules is that ",(0,i.kt)("inlineCode",{parentName:"p"},"RefCell<T>")," enforces these checks at runtime instead of at compile time - if we try to take two mutable references to the value stored in a ",(0,i.kt)("inlineCode",{parentName:"p"},"RefCell<T>"),", it will result in a panic instead of a compiler error."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"RefCell<T>")," is implemented using unsafe code, but it bundles it up behind an easy-to-understand API we can use. We say ",(0,i.kt)("inlineCode",{parentName:"p"},"RefCell<T>")," provides a safe API around unsafe code, which is a common idiom for unsafe code in Rust."),(0,i.kt)("p",null,"One final note about ",(0,i.kt)("inlineCode",{parentName:"p"},"RefCell<T>")," is that, like ",(0,i.kt)("inlineCode",{parentName:"p"},"Rc<T>"),", it is not thread safe."),(0,i.kt)("h3",{id:"a-use-case-for-interior-mutability-mock-objects"},"A Use Case for Interior Mutability: Mock Objects"),(0,i.kt)("p",null,"Let's look at a concrete example. We're writing code for an email server. Users have quotas, and when they get close to that quota, we want to send them a message. The message gets sent via the ",(0,i.kt)("inlineCode",{parentName:"p"},"Messenger")," trait:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"pub trait Messenger {\n    fn send(&self, msg: &str);\n}\n")),(0,i.kt)("p",null,"How it actually gets sent we don't care. An implementation might send an SMS, or maybe it will - in a fit of irony - send an email and fill up their inbox even more. Here's the code that actually checks the quota:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"pub struct LimitTracker<'a, T: Messenger> {\n    messenger: &'a T,\n    value: usize,\n    max: usize,\n}\n\nimpl<'a, T> LimitTracker<'a, T>\nwhere\n    T: Messenger,\n{\n    pub fn new(messenger: &'a T, max: usize) -> LimitTracker<'a, T> {\n        LimitTracker {\n            messenger,\n            value: 0,\n            max,\n        }\n    }\n\n    pub fn set_value(&mut self, value: usize) {\n        self.value = value;\n\n        let percentage_of_max = self.value as f64 / self.max as f64;\n\n        if percentage_of_max >= 1.0 {\n            self.messenger.send(\"Error: You are over your quota!\");\n        } else if percentage_of_max >= 0.9 {\n            self.messenger\n                .send(\"Urgent warning: You've used up over 90% of your quota!\");\n        } else if percentage_of_max >= 0.75 {\n            self.messenger\n                .send(\"Warning: You've used up over 75% of your quota!\");\n        }\n    }\n}\n")),(0,i.kt)("p",null,"We want to write a test case for ",(0,i.kt)("inlineCode",{parentName:"p"},"set_value"),". To do this we'll create a ",(0,i.kt)("inlineCode",{parentName:"p"},"MockMessenger")," that doesn't actually send a message, but just records all the messages it would have sent. We can create a private ",(0,i.kt)("inlineCode",{parentName:"p"},"Vec<String>")," to store all these messages for testing purposes. But just like our ",(0,i.kt)("inlineCode",{parentName:"p"},"to_lowercase")," example above we have a problem: in order to implement the ",(0,i.kt)("inlineCode",{parentName:"p"},"Messenger")," trait, the ",(0,i.kt)("inlineCode",{parentName:"p"},"send")," method on our ",(0,i.kt)("inlineCode",{parentName:"p"},"MockMessenger")," must borrow ",(0,i.kt)("inlineCode",{parentName:"p"},"self")," immutably, which means we can't mutate our vector. We'll use ",(0,i.kt)("inlineCode",{parentName:"p"},"RefCell<T>")," to implement the interior mutability pattern here:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::cell::RefCell;\n\n    struct MockMessenger {\n        sent_messages: RefCell<Vec<String>>,\n    }\n\n    impl MockMessenger {\n        fn new() -> MockMessenger {\n            MockMessenger {\n                sent_messages: RefCell::new(vec![]),\n            }\n        }\n    }\n\n    impl Messenger for MockMessenger {\n        fn send(&self, message: &str) {\n            self.sent_messages.borrow_mut().push(String::from(message));\n        }\n    }\n\n    #[test]\n    fn it_sends_an_over_75_percent_warning_message() {\n        // --snip--\n\n        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);\n    }\n}\n")),(0,i.kt)("p",null,"Here in ",(0,i.kt)("inlineCode",{parentName:"p"},"MockMessenger::send")," we're calling into ",(0,i.kt)("inlineCode",{parentName:"p"},"borrow_mut")," to give us a mutable reference to the vector stored inside the ",(0,i.kt)("inlineCode",{parentName:"p"},"RefCell")," so we can push values onto that vector, even though we only have an immutable reference to the ",(0,i.kt)("inlineCode",{parentName:"p"},"RefCell"),".  In the test case, we call ",(0,i.kt)("inlineCode",{parentName:"p"},"borrow")," to get an immutable reference so we can verify a message was sent."),(0,i.kt)("h3",{id:"having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt"},"Having Multiple Owners of Mutable Data by Combining ",(0,i.kt)("inlineCode",{parentName:"h3"},"Rc<T>")," and ",(0,i.kt)("inlineCode",{parentName:"h3"},"RefCell<T>")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Rc<T>")," lets us have multiple owners, ",(0,i.kt)("inlineCode",{parentName:"p"},"RefCell<T>")," lets us mutate internal state. We can combine these powers together to make something mutable with multiple owners. Looking back to our cons list example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},'#[derive(Debug)]\nenum List {\n    Cons(Rc<RefCell<i32>>, Rc<List>),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nfn main() {\n    let value = Rc::new(RefCell::new(5));\n\n    let a = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil)));\n\n    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&a));\n    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&a));\n\n    // We can modify the value at the end of the list,\n    // even though there are multiple references\n    // to it.\n    *value.borrow_mut() += 10;\n\n    println!("a after = {:?}", a);\n    println!("b after = {:?}", b);\n    println!("c after = {:?}", c);\n}\n')),(0,i.kt)("h2",{id:"156---reference-cycles-can-leak-memory"},"15.6 - Reference Cycles Can Leak Memory"),(0,i.kt)("p",null,"In C it's easy to create a memory leak; just ",(0,i.kt)("inlineCode",{parentName:"p"},"malloc")," some memory and never free it. In a language like Rust it's not so simple, but it can definitely be done. One way to do it is with ",(0,i.kt)("inlineCode",{parentName:"p"},"Rc<T>"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"RefCell<T>"),", and a circular reference. The problem is that ",(0,i.kt)("inlineCode",{parentName:"p"},"Rc<T>")," uses a simple reference count to know when memory is safe to free, but if we have two ",(0,i.kt)("inlineCode",{parentName:"p"},"Rc<T>"),"s that point to each other, then even with no one else referencing them, they'll both have a reference count of 1."),(0,i.kt)("p",null,"In a garbage collected language like Java or JavaScript, this problem is solved using ",(0,i.kt)("em",{parentName:"p"},"reachability"),". The two values are reachable from each other, but neither is reachable from the ",(0,i.kt)("em",{parentName:"p"},"root set"),". We have no garbage collector in Rust, and ",(0,i.kt)("inlineCode",{parentName:"p"},"Rc<T>")," is simply not smart enough to get out of this situation on its own, so we leak memory."),(0,i.kt)("h3",{id:"creating-a-reference-cycle"},"Creating a Reference Cycle"),(0,i.kt)("p",null,"Let's look at a slightly modified version of our cons list example, where the pointer to the next item in the list is mutable via ",(0,i.kt)("inlineCode",{parentName:"p"},"RefCell<T>"),". We then set up two lists elements which each have a next pointing to each other:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},'#[derive(Debug)]\nenum List {\n    Cons(i32, RefCell<Rc<List>>),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nimpl List {\n    fn tail(&self) -> Option<&RefCell<Rc<List>>> {\n        match self {\n            Cons(_, item) => Some(item),\n            Nil => None,\n        }\n    }\n}\n\nfn main() {\n    // Create `a` which represents the list `[5]`.\n    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));\n    // Create `b` which represents the list `[10, 5]`\n    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&a))));\n\n    // Set a\'s `next` to be `b`.  `a` is now the list `[5, 10, 5, 10, 5, 10...]`.\n    if let Some(link) = a.tail() {\n        *link.borrow_mut() = Rc::clone(&b);\n    }\n\n    // These will both be 2, because `a` and `b` are refs to these values,\n    // (which is the first count) and they also point to each other\n    // (which is the second).\n    println!("b rc count after changing a = {}", Rc::strong_count(&b));\n    println!("a rc count after changing a = {}", Rc::strong_count(&a));\n\n    // Uncomment the next line to see that we have a cycle;\n    // it will overflow the stack\n    // println!("a next item = {:?}", a.tail());\n}\n')),(0,i.kt)("p",null,"Have a quick read through that example and you'll see that both ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," end up pointing to each other. Both ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"b")," end up with a ",(0,i.kt)("inlineCode",{parentName:"p"},"strong_count")," of 2. When we hit the end of the ",(0,i.kt)("inlineCode",{parentName:"p"},"main")," function, ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," will be dropped, reducing the ref count for a's ",(0,i.kt)("inlineCode",{parentName:"p"},"Rc<List>")," to 1 (the one from ",(0,i.kt)("inlineCode",{parentName:"p"},"b"),"), and the same will happen to ",(0,i.kt)("inlineCode",{parentName:"p"},"b"),". As a result, even though there are no more ",(0,i.kt)("inlineCode",{parentName:"p"},"Rc")," objects left using this memory, the count is never reduced to zero and the memory will never be freed."),(0,i.kt)("h3",{id:"preventing-reference-cycles-turning-an-rct-into-a-weakt"},"Preventing Reference Cycles: Turning an ",(0,i.kt)("inlineCode",{parentName:"h3"},"Rc<T>")," into a ",(0,i.kt)("inlineCode",{parentName:"h3"},"Weak<T>")),(0,i.kt)("p",null,"One way to solve the problem we presented in the previous section is to make it so some of these pointers confer ownership semantics and some do not. It doesn't lend itself well to the example we just used, so we're going to use a new example here, using a tree data structure. We're going to have ",(0,i.kt)("inlineCode",{parentName:"p"},"Node"),"s that have a mutable list of references to their children, and each child will have a reference to the parent. This structure is full of circular references: a parent node points to each child, and each child points back to the parent."),(0,i.kt)("p",null,"To prevent a possible memory leak, here we'll make the parent references ",(0,i.kt)("em",{parentName:"p"},"strong")," and the child references ",(0,i.kt)("em",{parentName:"p"},"weak"),". In other words, if a child has a reference to a parent, that reference won't count towards the reference count that ",(0,i.kt)("inlineCode",{parentName:"p"},"Rc<T>")," uses:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},'use std::cell::RefCell;\nuse std::rc::{Rc, Weak};\n\n#[derive(Debug)]\nstruct Node {\n    value: i32,\n    parent: RefCell<Weak<Node>>,\n    children: RefCell<Vec<Rc<Node>>>,\n}\n\nfn main() {\n    // Create a leaf node\n    let leaf = Rc::new(Node {\n        value: 3,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(vec![]),\n    });\n\n    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());\n\n    // Create a parent for the leaf node\n    let branch = Rc::new(Node {\n        value: 5,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(vec![Rc::clone(&leaf)]),\n    });\n\n    // Wire up `leaf`\'s parent pointer\n    *leaf.parent.borrow_mut() = Rc::downgrade(&branch);\n\n    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());\n}\n')),(0,i.kt)("p",null,"We already know that calling ",(0,i.kt)("inlineCode",{parentName:"p"},"rc::clone")," will increment the ",(0,i.kt)("inlineCode",{parentName:"p"},"strong_count")," for that ",(0,i.kt)("inlineCode",{parentName:"p"},"Rc")," and return back a new ",(0,i.kt)("inlineCode",{parentName:"p"},"Rc")," that points to the same memory. Here ",(0,i.kt)("inlineCode",{parentName:"p"},"Rc::downgrade")," works the same way, except instead of returning an ",(0,i.kt)("inlineCode",{parentName:"p"},"Rc<Node>")," it returns a ",(0,i.kt)("inlineCode",{parentName:"p"},"Weak<Node>")," and instead of incrementing ",(0,i.kt)("inlineCode",{parentName:"p"},"strong_count")," it increments ",(0,i.kt)("inlineCode",{parentName:"p"},"weak_count"),". When an ",(0,i.kt)("inlineCode",{parentName:"p"},"Rc")," is dropped, if the ",(0,i.kt)("inlineCode",{parentName:"p"},"strong_count")," is decremented to 0 the underlying memory will be freed, even if the ",(0,i.kt)("inlineCode",{parentName:"p"},"weak_count")," is still positive."),(0,i.kt)("p",null,"This means that whenever we want to deference a ",(0,i.kt)("inlineCode",{parentName:"p"},"Weak<Node>"),", we have to check that there's still something in there, and the underlying memory hasn't been freed. We do this by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"Weak::upgrade")," on the ",(0,i.kt)("inlineCode",{parentName:"p"},"Weak<Node>"),", which will return an ",(0,i.kt)("inlineCode",{parentName:"p"},"Option<Rc<Node>>"),". If the underlying memory hasn't been cleaned up yet, then ",(0,i.kt)("inlineCode",{parentName:"p"},"Weak::upgrade")," returns a ",(0,i.kt)("inlineCode",{parentName:"p"},"Some<Rc<Node>>")," (the new ",(0,i.kt)("inlineCode",{parentName:"p"},"Rc<Node>")," increments the ",(0,i.kt)("inlineCode",{parentName:"p"},"strong_count"),", as you might expect) and if not, it returns a ",(0,i.kt)("inlineCode",{parentName:"p"},"None")," to let you know your weak reference isn't valid anymore."),(0,i.kt)("p",null,"Since the relationship from child-to-parent is weak, if we drop a parent, it's ",(0,i.kt)("inlineCode",{parentName:"p"},"strong_count")," will drop to 0, and the entire tree will end up being freed. No more leaks!"),(0,i.kt)("p",null,"Continue to ",(0,i.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch16-fearless-concurrency",title:"Chapter 16: Fearless Concurrency"},"chapter 16"),"."))}d.isMDXComponent=!0},511:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/conslist-ca3b90eb229fc29964b6c9a5db6571be.svg"}}]);