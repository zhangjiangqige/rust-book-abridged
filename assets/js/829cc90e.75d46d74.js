"use strict";(self.webpackChunkrust_book_abridged=self.webpackChunkrust_book_abridged||[]).push([[809],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),m=p(n),c=r,h=m["".concat(s,".").concat(c)]||m[c]||d[c]||i;return n?a.createElement(h,o(o({ref:t},u),{},{components:n})):a.createElement(h,o({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[m]="string"==typeof e?e:r,o[1]=l;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},193:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const i={},o="3 - Common Programming Concepts",l={unversionedId:"ch03-common-programming-concepts",id:"ch03-common-programming-concepts",title:"3 - Common Programming Concepts",description:"In which we learn about variables, basic types, functions, comments, and control flow.",source:"@site/docs/ch03-common-programming-concepts.md",sourceDirName:".",slug:"/ch03-common-programming-concepts",permalink:"/rust-book-abridged/ch03-common-programming-concepts",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ch03-common-programming-concepts.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"2 - Programming a Guessing Game",permalink:"/rust-book-abridged/ch02-guessing-game"},next:{title:"4 - Ownership, References, and Slices",permalink:"/rust-book-abridged/ch04-ownership"}},s={},p=[{value:"3.1 - Variables and Mutability",id:"31---variables-and-mutability",level:2},{value:"Constants",id:"constants",level:3},{value:"Static Variables",id:"static-variables",level:3},{value:"Shadowing",id:"shadowing",level:3},{value:"3.2 - Data Types",id:"32---data-types",level:2},{value:"Integer Types",id:"integer-types",level:3},{value:"Floating-Point Types",id:"floating-point-types",level:3},{value:"Number Operators",id:"number-operators",level:3},{value:"Boolean type",id:"boolean-type",level:3},{value:"Character Type",id:"character-type",level:3},{value:"<code>&amp;str</code> and <code>String</code>",id:"str-and-string",level:3},{value:"Compound Types",id:"compound-types",level:2},{value:"Tuple Type",id:"tuple-type",level:3},{value:"Array Type",id:"array-type",level:3},{value:"<code>struct</code> type",id:"struct-type",level:3},{value:"3.3 - Functions",id:"33---functions",level:2},{value:"3.4 - Comments",id:"34---comments",level:2},{value:"3.5 - Control Flow",id:"35---control-flow",level:2},{value:"if Expression",id:"if-expression",level:3},{value:"Repetition with Loops",id:"repetition-with-loops",level:3}],u={toc:p},m="wrapper";function d(e){let{components:t,...n}=e;return(0,r.kt)(m,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"3---common-programming-concepts"},"3 - Common Programming Concepts"),(0,r.kt)("p",null,"In which we learn about variables, basic types, functions, comments, and control flow."),(0,r.kt)("h2",{id:"31---variables-and-mutability"},"3.1 - Variables and Mutability"),(0,r.kt)("p",null,"Variables are declared with the ",(0,r.kt)("inlineCode",{parentName:"p"},"let")," keyword. By default, variables are immutable unless they are declared ",(0,r.kt)("inlineCode",{parentName:"p"},"mut"),". This program will fail to compile with the error ",(0,r.kt)("inlineCode",{parentName:"p"},"cannot assign twice to immutable variable `x` "),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"fn main() {\n    let x = 5;\n    x = 6; // This will error!\n\n    let mut y = 5;\n    y = 6; // This is okay.\n}\n")),(0,r.kt)("p",null,"Immutability in Rust is similar to ",(0,r.kt)("inlineCode",{parentName:"p"},"const")," in JavaScript, or ",(0,r.kt)("inlineCode",{parentName:"p"},"final")," in Java. The value the reference points to can't be modified (mostly - see the info box below):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let foo = String::from("foo");\n    foo.clear(); // This will error!\n}\n')),(0,r.kt)("p",null,"Here ",(0,r.kt)("inlineCode",{parentName:"p"},"clear")," will try to empty the string, but will fail with the error ",(0,r.kt)("inlineCode",{parentName:"p"},"cannot borrow `foo` as mutable, as it is not declared as mutable"),". If you go look at the source code for the ",(0,r.kt)("inlineCode",{parentName:"p"},"clear")," method it is defined as requiring ",(0,r.kt)("inlineCode",{parentName:"p"},"self")," to be a mutable reference (",(0,r.kt)("inlineCode",{parentName:"p"},"self")," is a bit like ",(0,r.kt)("inlineCode",{parentName:"p"},"this")," in other languages)."),(0,r.kt)("p",null,"Variables cannot be declared at the global scope ",(0,r.kt)("a",{parentName:"p",href:"#static-variables"},"unless they are ",(0,r.kt)("inlineCode",{parentName:"a"},"static")),"."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},'You may have noticed that that "mostly" above when we were talking about immutable variables. Immutability prevents us from directly modifying members of a struct, however in ',(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch15-smart-pointers",title:"Chapter 15: Smart Pointers"},"chapter 15")," we're going to find out that sometimes you can modify individual parts of an immutable struct through a concept call ",(0,r.kt)("em",{parentName:"p"},"interior mutability"),". A mutex is an example of an object that is immutable, but you're allowed to change the value in it if you own the lock.")),(0,r.kt)("h3",{id:"constants"},"Constants"),(0,r.kt)("p",null,"Rust also has the concept of a ",(0,r.kt)("em",{parentName:"p"},"constant")," which at first sounds a lot like an immutable variable:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;\n")),(0,r.kt)("p",null,"Constants are subtly different from immutable variables. They are stored directly in the program binary, so they cannot be ",(0,r.kt)("inlineCode",{parentName:"p"},"mut")," and the value of the constant has to be something that can be determined at compile time. The Rust Reference has a ",(0,r.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/stable/reference/const_eval.html"},"section on constant evaluation")," that lays out all the rules for what operators you're allowed to use and what you're not, but here the compiler can convert ",(0,r.kt)("inlineCode",{parentName:"p"},"60 * 60 * 3")," into ",(0,r.kt)("inlineCode",{parentName:"p"},"10800")," for us and store that in the executable."),(0,r.kt)("p",null,"Constants must always be annotated, and can be declared in the global scope."),(0,r.kt)("h3",{id:"static-variables"},"Static Variables"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Static variables")," or global variables are declared with the static keyword and are named in ",(0,r.kt)("inlineCode",{parentName:"p"},"SCREAMING_SNAKE_CASE"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'static HELLO_WORLD: &str = "Hello, world!";\n\nfn main() {\n    println!("name is: {}", HELLO_WORLD);\n}\n')),(0,r.kt)("p",null,"Static variables can be mutable, but to access or modify them we need to talk about ",(0,r.kt)("inlineCode",{parentName:"p"},"unsafe")," code, ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch19/ch19-01-unsafe#accessing-or-modifying-a-mutable-static-variable"},"which we'll do later"),"."),(0,r.kt)("h3",{id:"shadowing"},"Shadowing"),(0,r.kt)("p",null,"As we saw in ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch02-guessing-game",title:"Chapter 2: Guessing Game"},"chapter 2"),", a variable declaration can shadow another:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let x = 5;\n\n    let x = x + 1;\n\n    {\n        let x = x * 2;\n        println!("The value of x in the inner scope is: {x}");\n    }\n\n    println!("The value of x is: {x}");\n}\n')),(0,r.kt)("p",null,'There are a total of three variables in this function, all named "x". Variables last until the end of the block they were declared in, so this program prints out:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-txt"},"The value of x in the inner scope is: 12\nThe value of x is: 6\n")),(0,r.kt)("p",null,"When shadowing a variable, the new variable does not have to have the same type as the one it is shadowing."),(0,r.kt)("h2",{id:"32---data-types"},"3.2 - Data Types"),(0,r.kt)("p",null,"Keep in mind that Rust is a statically typed language, so the type of every variable (and how much space it will occupy in memory, if it is stored on the stack) must be known at compile time. Rust's type inference is amazing, so frequently we don't have to tell Rust what type a variable is, but sometimes a variable's type is ambiguous in which case we need to ",(0,r.kt)("em",{parentName:"p"},"annotate")," it (e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},"let guess: 32 = ..."),")."),(0,r.kt)("p",null,'A "scalar type" represents a single value. There are four kinds of scalar types in Rust: integers, floating-point numbers, Booleans, and characters.'),(0,r.kt)("h3",{id:"integer-types"},"Integer Types"),(0,r.kt)("p",null,"Integer types:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Length (bits)"),(0,r.kt)("th",{parentName:"tr",align:null},"Signed"),(0,r.kt)("th",{parentName:"tr",align:null},"Unsigned"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"8"),(0,r.kt)("td",{parentName:"tr",align:null},"i8"),(0,r.kt)("td",{parentName:"tr",align:null},"u8")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"16"),(0,r.kt)("td",{parentName:"tr",align:null},"i16"),(0,r.kt)("td",{parentName:"tr",align:null},"u16")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"32"),(0,r.kt)("td",{parentName:"tr",align:null},"i32"),(0,r.kt)("td",{parentName:"tr",align:null},"u32")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"64"),(0,r.kt)("td",{parentName:"tr",align:null},"i64"),(0,r.kt)("td",{parentName:"tr",align:null},"u64")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"128"),(0,r.kt)("td",{parentName:"tr",align:null},"i128"),(0,r.kt)("td",{parentName:"tr",align:null},"u128")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"arch"),(0,r.kt)("td",{parentName:"tr",align:null},"isize"),(0,r.kt)("td",{parentName:"tr",align:null},"usize")))),(0,r.kt)("p",null,"Signed integers are stored using ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Two%27s_complement"},"two's complement"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"isize")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"usize")," depend on your architecture, so they'll be 32 bit numbers on a 32 bit architecture, or 64 bit on a 64 bit architecture."),(0,r.kt)("p",null,"Integer literals can be written using any of the methods below. Integer literals in Rust can use an ",(0,r.kt)("inlineCode",{parentName:"p"},"_"),' as a visual separator (similar to how we might write "1,000" in English, we can write "1_000" in Rust).'),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Number literals"),(0,r.kt)("th",{parentName:"tr",align:null},"Example"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Decimal"),(0,r.kt)("td",{parentName:"tr",align:null},"98_222")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Hex"),(0,r.kt)("td",{parentName:"tr",align:null},"0xff")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Octal"),(0,r.kt)("td",{parentName:"tr",align:null},"Oo77")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Binary"),(0,r.kt)("td",{parentName:"tr",align:null},"0b1111_0000")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Byte (u8)"),(0,r.kt)("td",{parentName:"tr",align:null},"b'A'")))),(0,r.kt)("p",null,"If you try to overflow an integer (e.g. you try to store 256 in a u8), what happens (by default) depends on whether you compiled your program with ",(0,r.kt)("inlineCode",{parentName:"p"},"--release")," or not. In debug mode Rust adds runtime checks to ensure you don't overflow a value, so your program will panic and crash (see ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch09-error-handling",title:"Chapter 9: Error Handling"},"chapter 9")," for more about panics). With the --release flag, the integer will overflow as you would expect it to in another language like C or Java (the largest value a u8 can hold is 255, so 256 wraps to 0)."),(0,r.kt)("p",null,"The standard library has functions that let you explicitly define how you want to handle overflows if you don't want to panic. For example ",(0,r.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/std/intrinsics/fn.wrapping_add.html"},(0,r.kt)("inlineCode",{parentName:"a"},"wrapping_add"))," will add two numbers and let them wrap around. There are ",(0,r.kt)("inlineCode",{parentName:"p"},"wrapping_*"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"checked_*"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"overflowing_*"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"saturating_*")," functions for integer arithmetic."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"We can change how overflows are handled at runtime for development and release through ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch14-more-about-cargo#141---customizing-builds-with-release-profiles"},"release profiles"),".")),(0,r.kt)("h3",{id:"floating-point-types"},"Floating-Point Types"),(0,r.kt)("p",null,"There are two floating point types, ",(0,r.kt)("inlineCode",{parentName:"p"},"f64")," (the default) and ",(0,r.kt)("inlineCode",{parentName:"p"},"f32"),". Floating-point numbers are stored using the IEEE-754 standard."),(0,r.kt)("h3",{id:"number-operators"},"Number Operators"),(0,r.kt)("p",null,"Rust has the operators you'd expect: ",(0,r.kt)("inlineCode",{parentName:"p"},"+"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"-"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"*"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"/"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"%")," for modulus. See ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/zz-appendix/appendix-02-operators"},"the Rust Book Appendix B")," for a complete list of all the operators in Rust."),(0,r.kt)("h3",{id:"boolean-type"},"Boolean type"),(0,r.kt)("p",null,"Booleans are of type ",(0,r.kt)("inlineCode",{parentName:"p"},"bool")," and can be ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"let t = true;\nlet f: bool = false;\n")),(0,r.kt)("h3",{id:"character-type"},"Character Type"),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"char")," in Rust is a four-byte unicode scalar value."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"let c = 'z';\nlet z: char = '\u2124';\nlet heart_eyed_cat = '\ud83d\ude3b';\nlet space_woman_zwj = '\ud83d\udc69\ud83c\udffb\u200d\ud83d\ude80'; // <== This doesn't work!\n")),(0,r.kt)("p",null,"That last example doesn't work. Our female astronaut friend might look like a single character, but she's actually two emoji joined together with a zero-width-joiner (ZWJ). We'll talk a lot more about UTF-8 and Unicode in ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch08-common-collections",title:"Chapter 8: Common Collections"},"chapter 8"),"."),(0,r.kt)("h3",{id:"str-and-string"},(0,r.kt)("inlineCode",{parentName:"h3"},"&str")," and ",(0,r.kt)("inlineCode",{parentName:"h3"},"String")),(0,r.kt)("p",null,"You'll see two different string types in Rust: ",(0,r.kt)("inlineCode",{parentName:"p"},"str")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"String")," is similar to a ",(0,r.kt)("inlineCode",{parentName:"p"},"Vector")," - it's a data type that stores a list of characters in a variable-length chunk of memory on the heap. Any time you accept input from the user or read a string from a file, it's going to end up in a ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),"."),(0,r.kt)("p",null,"The type ",(0,r.kt)("inlineCode",{parentName:"p"},"&str")," (almost always seen in it's borrowed form) is also known as a ",(0,r.kt)("em",{parentName:"p"},"string slice")," (which we'll learn more about in ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch04-ownership",title:"Chapter 4: Ownership, References, and Slices"},"the next chapter"),"), and is both a pointer to the string's data and a length for the string. Any string literal in Rust is a ",(0,r.kt)("inlineCode",{parentName:"p"},"&str"),", since the actual string is stored somewhere in the executable and we just have an immutable reference to it. A string slice can be used as a view into a ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),"."),(0,r.kt)("h2",{id:"compound-types"},"Compound Types"),(0,r.kt)("p",null,"Compound types group multiple values into one type. Rust has two primitive compound types, the ",(0,r.kt)("em",{parentName:"p"},"tuple")," and the ",(0,r.kt)("em",{parentName:"p"},"array"),"."),(0,r.kt)("h3",{id:"tuple-type"},"Tuple Type"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"let tup: (i32, f64, u8) = (800, 6.4, 1);\n\n// Destructuring assignment\nlet (x, y, z) = tup;\n\n// Access individual elements\nlet a = tup.0;\nlet b = tup.1;\nlet c = tup.2;\n")),(0,r.kt)("p",null,"An empty tuple is written ",(0,r.kt)("inlineCode",{parentName:"p"},"()"),' and is called a "unit". This represents an empty value or an empty return type. Functions without a return type implicitly return this.'),(0,r.kt)("h3",{id:"array-type"},"Array Type"),(0,r.kt)("p",null,'Every element in an array must be the same type, and arrays must be fixed length. If you\'re looking for a "variable length" array, you want a vector from the standard library (see ',(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch08-common-collections",title:"Chapter 8: Common Collections"},"Chapter 8"),"). If you declare a variable as an array in a function, then the contents of that variable will end up on the stack, while for a vector contents will end up on the heap. (Although you can put the contents of an array on the heap by using a smart pointer like a ",(0,r.kt)("inlineCode",{parentName:"p"},"Box<T>")," - see ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch15-smart-pointers",title:"Chapter 15: Smart Pointers"},"chapter 15"),")."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"let a = [1, 2, 3, 4, 5];\n\n// Destructuring assignment.  Must use all elements!\nlet [x, y, z, _, _] = a;\n\n// Access individual elements\nlet first = a[0];\nlet second = a[1];\n\n// Create array of type i32, length 5.\nlet b: [i32; 5] = [1, 2, 3, 4, 5];\n\n// Create array of five zeros.\nlet c = [0; 5]\n")),(0,r.kt)("p",null,"Array accesses are checked at runtime. Trying to access an index which is out-of-bounds will cause a panic."),(0,r.kt)("p",null,"If you're coming to Rust from JavaScript, it's worth pointing out that JavaScript \"arrays\" are not quite like arrays in any other programming language. The Rust ",(0,r.kt)("inlineCode",{parentName:"p"},"Vec")," type, or ",(0,r.kt)("em",{parentName:"p"},"vector"),", is much closer to a JavaScript array than a Rust array is. We'll talk about vectors in ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch08-common-collections",title:"Chapter 8: Common Collections"},"chapter 8"),"."),(0,r.kt)("h3",{id:"struct-type"},(0,r.kt)("inlineCode",{parentName:"h3"},"struct")," type"),(0,r.kt)("p",null,"We can define our own compound types using the ",(0,r.kt)("inlineCode",{parentName:"p"},"struct")," keyword:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"struct User {\n    name: String,\n    age: u32,\n}\n")),(0,r.kt)("h2",{id:"33---functions"},"3.3 - Functions"),(0,r.kt)("p",null,"Functions are defined by ",(0,r.kt)("inlineCode",{parentName:"p"},"fn")," keyword. Parameters are required to have a type annotation, and are annotated with ",(0,r.kt)("inlineCode",{parentName:"p"},": type")," just like variables (and just like in Typescript)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'fn another_function(x: i32, y: i32) {\n    println!("The point is at: {x}, {y}");\n}\n')),(0,r.kt)("p",null,"If you end a function with an expression instead of a statement, then the function will return the value of that expression. Return types must be explicitly declared with an arrow (",(0,r.kt)("inlineCode",{parentName:"p"},"->"),")."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// Returns 1\nfn implicit_return() -> i32 {\n    1\n}\n\n// Also returns 1, but using `return` is not\n// idiomatic in Rust unless you want to return\n// from the middle of a function.\nfn explicit_return() -> i32 {\n    return 1;\n}\n\n// The semicolon makes this a statement instead\n// of an expression, so this returns `()`.\nfn no_return() {\n    1;\n}\n")),(0,r.kt)("p",null,"Assignments are always statements (i.e. ",(0,r.kt)("inlineCode",{parentName:"p"},"let x = 6")," does not evaluate to 6), as are function definitions (i.e. you can't do ",(0,r.kt)("inlineCode",{parentName:"p"},"let x = fn foo() {}"),"). Functions can be called before they are defined. In ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch10/ch10-01-generic-data-types",title:"Chapter 10: Generic Types, Traits, and Lifetimes"},"chapter 10")," we'll learn about using generics with functions."),(0,r.kt)("p",null,"Rust also has closures, which are inline functions that can be assigned to variables or passed as parameters. We'll learn about them in detail in ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch13-functional-language-features",title:"Chapter 13: Functional Language Features: Iterators and Closures"},"chapter 13"),", but the syntax is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"let my_closure = |param1, param2| { /* function body goes here */ };\n")),(0,r.kt)("h2",{id:"34---comments"},"3.4 - Comments"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// This is a comment.  Multi-line comments\n// generally are written this way.\n\n/* You can use this style of comment too. */\n\n/// This is a doc comment for the "next thing", in\n/// this case for the `foo` function.  Markdown is\n/// allowed here.  See chapter 14 for more details.\nfn foo() {}\n\nmod bar {\n    //! This is a doc comment for the "parent thing",\n    //! in this case the "bar" module.\n}\n')),(0,r.kt)("h2",{id:"35---control-flow"},"3.5 - Control Flow"),(0,r.kt)("h3",{id:"if-expression"},"if Expression"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"if")," statements don't have braces around the condition, (much like Go, and much unlike Java, JavaScript, or C):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'if number < 5 {\n    println!("less than 5");\n} else if number > 10 {\n    println!("greater than 10");\n} else {\n    println!("greater than 4, less than 11");\n}\n')),(0,r.kt)("p",null,"Note that ",(0,r.kt)("inlineCode",{parentName:"p"},"if"),' can be used as an expression. In this case each "arm" of the if must be the same type:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// This is OK\nlet number = if condition { 5 } else { 6 };\n\n// This breaks! `if` and `else` have\n// incompatible types\nlet wat = if condition { 5 } else { "six" };\n\n// But this is OK.\nloop {\n    let wat = if condition { 5 } else { break };\n}\n')),(0,r.kt)("h3",{id:"repetition-with-loops"},"Repetition with Loops"),(0,r.kt)("p",null,"Rust has three kinds of loops: ",(0,r.kt)("inlineCode",{parentName:"p"},"loop"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"while"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"for"),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"break")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"continue")," statements work exactly as they do in other languages: ",(0,r.kt)("inlineCode",{parentName:"p"},"break")," will stop the loop, and ",(0,r.kt)("inlineCode",{parentName:"p"},"continue")," will stop execution of the current iteration and start the next one. Note that loops can be used as expressions."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"loop {\n    println!(\"Infinite loop!\")\n}\n\n// Loops can be used as expressions, with `break`\n// returning the value from the block.\nlet mut counter = 0;\nlet x = loop {\n    counter += 1;\n    if counter == 10 {\n        break counter * 2;\n    }\n};\n\n// Loops can be labeled with a single quote\n// followed by the label and the a colon.\n'outer: loop {\n    'inner: loop {\n        break 'outer;\n    }\n}\n\n// A while loop looks a lot like a\n// while loop in every other language.\nlet mut number = 0;\nwhile number < 10 {\n    number++;\n}\n")),(0,r.kt)("p",null,"For loops in Rust are always of the format ",(0,r.kt)("inlineCode",{parentName:"p"},"for [var] in [iterator] {}"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// Iterate over an array\nlet a = [1, 2, 3, 4, 5];\nfor element in a {\n    println!("value is {element}");\n}\n\n// Count from 1 to 5\nfor element in (1..6) {\n    println!("value is {element}");\n}\n')),(0,r.kt)("p",null,"We'll see more about iterators in ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch13-functional-language-features",title:"Chapter 13: Functional Language Features: Iterators and Closures"},"chapter 13"),"."),(0,r.kt)("p",null,"Now that we know some basics, it's time to learn about ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch04-ownership",title:"Chapter 4: Ownership, References, and Slices"},"ownership"),"."))}d.isMDXComponent=!0}}]);