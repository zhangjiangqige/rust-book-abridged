"use strict";(self.webpackChunkrust_book_abridged=self.webpackChunkrust_book_abridged||[]).push([[528],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>d});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},c="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),c=p(n),u=r,d=c["".concat(l,".").concat(u)]||c[u]||h[u]||o;return n?a.createElement(d,i(i({ref:t},m),{},{components:n})):a.createElement(d,i({ref:t},m))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:r,i[1]=s;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},6356:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const o={},i="4 - Ownership, References, and Slices",s={unversionedId:"ch04-ownership",id:"ch04-ownership",title:"4 - Ownership, References, and Slices",description:"Ownership is Rust's most unique feature and has deep implications for the rest of the language. It enables Rust to make memory safety guarantees without needing a garbage collector, so it's important to understand how ownership works.",source:"@site/docs/ch04-ownership.md",sourceDirName:".",slug:"/ch04-ownership",permalink:"/rust-book-abridged/ch04-ownership",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ch04-ownership.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"3 - Common Programming Concepts",permalink:"/rust-book-abridged/ch03-common-programming-concepts"},next:{title:"5 - Using Structs to Structure Related Data",permalink:"/rust-book-abridged/ch05-structs"}},l={},p=[{value:"4.1 - What is Ownership?",id:"41---what-is-ownership",level:2},{value:"Ownership Rules",id:"ownership-rules",level:3},{value:"Memory and Allocation",id:"memory-and-allocation",level:3},{value:"There Can Only Be One",id:"there-can-only-be-one",level:3},{value:"Stack-Only Data: Copy",id:"stack-only-data-copy",level:3},{value:"Ownership and Functions",id:"ownership-and-functions",level:3},{value:"4.2 - References and Borrowing",id:"42---references-and-borrowing",level:2},{value:"Mutable References",id:"mutable-references",level:3},{value:"Dereferencing",id:"dereferencing",level:2},{value:"Dangling References",id:"dangling-references",level:3},{value:"The Rules of References",id:"the-rules-of-references",level:3},{value:"4.3 - The Slice Type",id:"43---the-slice-type",level:2},{value:"String Literals as Slices",id:"string-literals-as-slices",level:3},{value:"String Slices as Parameters",id:"string-slices-as-parameters",level:3},{value:"Other Slices",id:"other-slices",level:3}],m={toc:p},c="wrapper";function h(e){let{components:t,...n}=e;return(0,r.kt)(c,(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"4---ownership-references-and-slices"},"4 - Ownership, References, and Slices"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Ownership is Rust's most unique feature and has deep implications for the rest of the language. It enables Rust to make memory safety guarantees without needing a garbage collector, so it's important to understand how ownership works.")),(0,r.kt)("p",null,"-- ",(0,r.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/stable/book/ch04-00-understanding-ownership.html"},'"The Rust Programming Language" Chapter 4 - Understanding Ownership')),(0,r.kt)("h2",{id:"41---what-is-ownership"},"4.1 - What is Ownership?"),(0,r.kt)("p",null,"The idea of ownership is quite core to Rust. If you're coming from a language like Python or JavaScript, and you're not familiar with the idea of the ",(0,r.kt)("a",{parentName:"p",href:"https://www.geeksforgeeks.org/stack-vs-heap-memory-allocation/"},"the stack and heap")," it's worth reading up about them. We're going to assume you're familiar with them in this chapter."),(0,r.kt)("p",null,"In a language like C, we can manage memory by explicitly calling ",(0,r.kt)("inlineCode",{parentName:"p"},"malloc")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"free"),". All memory management is up to us, which means it's easy to make mistakes. In a language like Java or JavaScript, memory is allocated automatically without us having to think about it, so memory allocation is very safe, but this incurs a runtime cost in the form of garbage collection."),(0,r.kt)("p",null,"Rust is rather unique in how it manages memory. Aside from simple values such as ",(0,r.kt)("inlineCode",{parentName:"p"},"i32")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"f64"),", In Rust, every value is ",(0,r.kt)("em",{parentName:"p"},"owned")," by some variable called the ",(0,r.kt)("em",{parentName:"p"},"owner"),". Ownership of a particular value can be transferred from one variable to another, and in some cases memory can be ",(0,r.kt)("em",{parentName:"p"},"borrowed"),". Once the variable that owns the value is no longer around we say that value has been ",(0,r.kt)("em",{parentName:"p"},"dropped"),", and once that happens any memory it allocated can safely be freed. When a value is dropped, it can optionally run code in a ",(0,r.kt)("em",{parentName:"p"},"destructor")," (defined by implementing the ",(0,r.kt)("inlineCode",{parentName:"p"},"Drop")," trait)."),(0,r.kt)("h3",{id:"ownership-rules"},"Ownership Rules"),(0,r.kt)("p",null,"From the original Rust Book:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Each value in Rust has an owner."),(0,r.kt)("li",{parentName:"ul"},"There can only be one owner at a time."),(0,r.kt)("li",{parentName:"ul"},"When the owner goes out of scope, the value will be ",(0,r.kt)("em",{parentName:"li"},"dropped"),".")),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"scope"),' of a variable in Rust works much like it does in most other languages - inside a set of curly braces, any variable you declare can be accessed only after its declaration, and it goes "out of scope" once we hit the closing brace. The key thing about Rust is that once a variable goes out of scope, if that variable currently owns some memory, then that memory will be freed.'),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"A variable can only have one owner at a time, but in ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch15-smart-pointers",title:"Chapter 15: Smart Pointers"},"chapter 15")," we'll talk about smart pointers like ",(0,r.kt)("inlineCode",{parentName:"p"},"Rc<T>")," that let us get around this restriction."),(0,r.kt)("p",{parentName:"admonition"},"We also say that each value in Rust has an owner, but it's possible to ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch15-smart-pointers#156---reference-cycles-can-leak-memory"},"leak memory")," in Rust, which would technically end with values that have no owners.")),(0,r.kt)("h3",{id:"memory-and-allocation"},"Memory and Allocation"),(0,r.kt)("p",null,"This is a trivial example demonstrating some memory being allocated on the heap and then freed:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'fn foo() {\n\n    if (true) {\n        // Create the variable `s` to own a String.\n        // Remember that Strings can store an arbitrary\n        // length of data, so this will allocate memory\n        // on the heap.\n        let s = String::from("hello");\n\n        // Do stuff with s\n\n    }\n    // At this point `s` has fallen out of scope, so the\n    // String that was owned by s will be dropped, and\n    // the memory it allocated on the heap will be freed.\n}\n')),(0,r.kt)("p",null,'You might read that and scratch your head and think "If everything disappears when it goes out of scope, isn\'t this the same as just allocating everything on the stack?" And this ',(0,r.kt)("em",{parentName:"p"},"would")," be true, except that ownership can be ",(0,r.kt)("em",{parentName:"p"},"moved"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let outer_string = foo();\n    println!("{}", outer_string);\n}\n\nfn foo() -> String {\n    let inner_string = String::from("hello world");\n    inner_string\n}\n')),(0,r.kt)("p",null,"Here the ",(0,r.kt)("inlineCode",{parentName:"p"},"foo")," function creates a ",(0,r.kt)("inlineCode",{parentName:"p"},"String")," (which allocates some memory on the heap) and ",(0,r.kt)("inlineCode",{parentName:"p"},"inner_string")," is the owner of that ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"foo")," function returns ",(0,r.kt)("inlineCode",{parentName:"p"},"inner_string"),", so ownership of the String (and the associated memory) is moved to ",(0,r.kt)("inlineCode",{parentName:"p"},"outer_string")," in the caller. When we reach the end of ",(0,r.kt)("inlineCode",{parentName:"p"},"main"),", then ",(0,r.kt)("inlineCode",{parentName:"p"},"outer_string")," falls out-of-scope. At this point the ",(0,r.kt)("inlineCode",{parentName:"p"},"String")," doesn't have an owner anymore, so it will be dropped."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"When we move ownership of a variable, it's location in memory will change:"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let x = String::from("hello world");\n    println!("Address: {:p}", &x);\n    let y = x;\n    println!("Address: {:p}", &y);\n}\n')),(0,r.kt)("p",{parentName:"admonition"},"The above example will print different addresses for ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),". In this example, the ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),' has some memory stored on the heap (the "hello world" part) but also has some memory on the stack (a pointer to that value and a length, amongst other data). When we move ownership of ',(0,r.kt)("inlineCode",{parentName:"p"},"x")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),", we're also moving the data on the stack from one place to another with ",(0,r.kt)("inlineCode",{parentName:"p"},"memcpy"),", although the heap part stays in the same place."),(0,r.kt)("p",{parentName:"admonition"},"If you need a piece of data to stay in one place in memory, see ",(0,r.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/std/pin/index.html"},(0,r.kt)("inlineCode",{parentName:"a"},"std::pin")),".")),(0,r.kt)("h3",{id:"there-can-only-be-one"},"There Can Only Be One"),(0,r.kt)("p",null,"Remember that we said there can only be one owner at a time?"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'fn strings() -> String {\n    // Create a string\n    let s1 = String::from("hello");\n\n    // Move ownership from s1 to s2\n    let s2 = s1;\n\n    // Can\'t use s1 anymore!\n    println!("{}", s1);\n\n    s2\n}\n')),(0,r.kt)("p",null,"This code fails to compile with the error:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-txt"},'error[E0382]: borrow of moved value: `s1`\n --\x3e src/main.rs:9:20\n  |\n3 |     let s1 = String::from("hello");\n  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait\n...\n6 |     let s2 = s1;\n  |              -- value moved here\n...\n9 |     println!("{}", s1);\n  |                    ^^ value borrowed here after move\n')),(0,r.kt)("p",null,"If you're coming from some other language, and you try to just pass values around and hope for the best without understanding ownership, you're going to see this error a lot."),(0,r.kt)("p",null,"In this example, we create a variable ",(0,r.kt)("inlineCode",{parentName:"p"},"s1"),", which owns the String. In most other languages, when we do ",(0,r.kt)("inlineCode",{parentName:"p"},"let s2 = s1;"),", we'd now have two variables that point to the same underlying object, but not so in Rust. In Rust, we ",(0,r.kt)("em",{parentName:"p"},"move")," ownership of the value from ",(0,r.kt)("inlineCode",{parentName:"p"},"s1")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"s2"),", so ",(0,r.kt)("inlineCode",{parentName:"p"},"s1")," stops being valid and can't be used from that point forwards. This is exactly the same as when we returned a variable in the example above."),(0,r.kt)("p",null,"If you think about this at the memory level, when we create ",(0,r.kt)("inlineCode",{parentName:"p"},"s1"),", we allocate some memory. When we say ",(0,r.kt)("inlineCode",{parentName:"p"},"let s2 = s1;"),", we're not creating a second ",(0,r.kt)("inlineCode",{parentName:"p"},"String")," (we didn't call ",(0,r.kt)("inlineCode",{parentName:"p"},"clone")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"new"),"). If we allowed ",(0,r.kt)("inlineCode",{parentName:"p"},"s1")," to be valid after this point then ",(0,r.kt)("inlineCode",{parentName:"p"},"s1")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"s2")," would have to point to the same memory. When we reach the end of the function, we return ",(0,r.kt)("inlineCode",{parentName:"p"},"s2")," but not ",(0,r.kt)("inlineCode",{parentName:"p"},"s1"),", which means ",(0,r.kt)("inlineCode",{parentName:"p"},"s1")," is going out of scope and should be dropped, but since ",(0,r.kt)("inlineCode",{parentName:"p"},"s2")," is being moved and refers to the same underlying object ",(0,r.kt)("inlineCode",{parentName:"p"},"s1")," can't be dropped. Rust's answer to this problem is to never let this happen - only one owner at a time."),(0,r.kt)("p",null,"If we wanted to deep-copy the data in the String, we could use the ",(0,r.kt)("inlineCode",{parentName:"p"},"clone")," method to allocate more memory on the heap:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'fn strings() {\n    let s1 = String::from("hello");\n    let s2 = s1.clone();\n\n    println!("{}", s1);\n}\n')),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"We can do something slightly tricky with a move like this too. We can take an immutable variable and turn it into a mutable one:"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let x = String::from("hello world");\n    let mut y = x;\n}\n')),(0,r.kt)("p",{parentName:"admonition"},"When ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," takes ownership of ",(0,r.kt)("inlineCode",{parentName:"p"},"x"),", it owns that memory now and can do what it wants with it, so it's perfectly acceptable to redeclare the variable as ",(0,r.kt)("inlineCode",{parentName:"p"},"mut"),". If you have a favorite book and you keep it in pristine condition, but then you decide to give me that book then it becomes my book. I can dog ear pages and crack the spine, because I own it. If you lend me your book, that's a different story - and we'll talk about borrowing in just a little bit.")),(0,r.kt)("h3",{id:"stack-only-data-copy"},"Stack-Only Data: Copy"),(0,r.kt)("p",null,"Similar to Java or JavaScript or C or... actually most other languages, Rust has special handling for basic data types:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'fn integers() {\n    let i1 = 1;\n    let i2 = i1;\n\n    println!("{}", i1);\n}\n')),(0,r.kt)("p",null,"This looks just like the string example above, but it compiles. This is because here ",(0,r.kt)("inlineCode",{parentName:"p"},"i1")," is an ",(0,r.kt)("inlineCode",{parentName:"p"},"i32"),", which takes up four bytes of memory. Since Rust knows this at compile time, it can allocate it on the stack instead of the heap, and making a copy of a four byte value on the stack to another four bytes of the stack is so cheap it is essentially free. So here, ",(0,r.kt)("inlineCode",{parentName:"p"},"let i2 = i1;")," doesn't move anything, it just makes a copy of the variable for you."),(0,r.kt)("p",null,"What types get copied like this? The quick answer to this is any basic type (integers, booleans, chars, etc...) and any tuple made up of basic types. More formally, the answer is any type that has the ",(0,r.kt)("inlineCode",{parentName:"p"},"Copy")," trait (see ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch10/ch10-01-generic-data-types",title:"Chapter 10: Generic Types, Traits, and Lifetimes"},"chapter 10")," for more information about traits). You can also implement it on your own data structures if they are made entirely of copyable types, or get Rust to ",(0,r.kt)("em",{parentName:"p"},"derive")," it for you (which means Rust will generate this code for you at compile time):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(Copy, Clone)]\npub struct MyStruct {\n    pub foo: i32,\n}\n")),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Structs with the ",(0,r.kt)("inlineCode",{parentName:"p"},"Copy")," trait are not allowed to implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"Drop")," trait, so they can't run any custom code when they go out of scope.")),(0,r.kt)("h3",{id:"ownership-and-functions"},"Ownership and Functions"),(0,r.kt)("p",null,"We already saw that if you return a variable, then ownership of the variable is moved to the caller. We also move ownership when we pass a variable to a function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let s = String::from("hello");\n    takes_ownership(s);\n\n    // Ownership of `s` was moved to `takes_ownership`\'s\n    // `some_string`, so s is no longer valid here.\n}\n\nfn takes_ownership(some_string: String) {\n    println!("{}", some_string);\n} // Here, some_string goes out of scope and `drop`\n  // is called. The backing memory is freed.\n')),(0,r.kt)("h2",{id:"42---references-and-borrowing"},"4.2 - References and Borrowing"),(0,r.kt)("p",null,'If you wanted to pass a variable to a function, but also keep it usable afterwards, you could pass the variable to the function and then return it from the function. This would move the variable into the function, and then move it back so you can keep using it. As you can imagine, using a variable more than once is something we want to do pretty often, and if this was "the way" to do it, then Rust would be a very annoying language to work in. Instead we can let the function we call ',(0,r.kt)("em",{parentName:"p"},"borrow")," the variable by passing a reference:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let s1 = String::from("hello");\n\n    let len = calculate_length(&s1);\n\n    println!("The length of \'{}\' is {}.", s1, len);\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n}\n')),(0,r.kt)("p",null,"Two things to note here - when we call ",(0,r.kt)("inlineCode",{parentName:"p"},"calculate_length")," instead of passing ",(0,r.kt)("inlineCode",{parentName:"p"},"s1")," we're passing ",(0,r.kt)("inlineCode",{parentName:"p"},"&s1"),", and in the signature for ",(0,r.kt)("inlineCode",{parentName:"p"},"calculate_length")," we take a ",(0,r.kt)("inlineCode",{parentName:"p"},"&String")," instead of a ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),'. What we\'re passing here is a "reference to a string". Essentially ',(0,r.kt)("inlineCode",{parentName:"p"},"&s1")," contains a pointer to the String held in ",(0,r.kt)("inlineCode",{parentName:"p"},"s1"),", and we're passing that pointer to ",(0,r.kt)("inlineCode",{parentName:"p"},"calculate_length"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"calculate_length")," doesn't take ownership of the ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),", it merely borrows it, so the ",(0,r.kt)("inlineCode",{parentName:"p"},"String")," won't be dropped when ",(0,r.kt)("inlineCode",{parentName:"p"},"s")," goes out of scope."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"The syntax for getting a reference to a value - ",(0,r.kt)("inlineCode",{parentName:"p"},"&x")," - is exactly the same as getting a pointer to a value in C or Go, and references in Rust behave a lot like pointers. ",(0,r.kt)("a",{parentName:"p",href:"https://stackoverflow.com/questions/64167637/is-the-concept-of-reference-different-in-c-and-rust/64167719#64167719"},"This Stack Overflow answer")," talks about ways that Rust references compare to C/C++ pointers.")),(0,r.kt)("h3",{id:"mutable-references"},"Mutable References"),(0,r.kt)("p",null,"As with variables, we can have both immutable references (the default) and mutable references:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let mut s = String::from("hello");\n\n    change(&mut s);\n}\n\nfn change(some_string: &mut String) {\n    some_string.push_str(", world");\n}\n')),(0,r.kt)("p",null,"Mutable references come with a restriction: if you have a mutable reference to a value, you can have no other references to that value."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let mut s = String::from("hello");\n\nlet r1 = &mut s;\nlet r2 = &mut s; // This is an error!\n\nprintln!("{}, {}", r1, r2);\n')),(0,r.kt)("p",null,'This restriction is imposed because it prevents data races. The compiler will stop us from creating data races at compile time! Some people prefer to think about references in terms of "shared references" and "exclusive references" in stead of as "immutable" and "mutable".'),(0,r.kt)("p",null,"The scope of a reference lasts only until it's last use, not until the end of the block, so this is fine:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let mut s = String::from("hello");\n\nlet r1 = &mut s;\nprintln!("{}", r1);\n\nlet r2 = &mut s; // r1 is now out-of-scope, so we can create r2.\nprintln!("{}", r2);\n')),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Where you place the ",(0,r.kt)("inlineCode",{parentName:"p"},"mut")," keyword changes how a reference can be used:"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// x1 is a reference to y.  We can't update x or y:\nlet x1 = &y;\n// x2 is a reference that can be used to change y:\nlet x2 = &mut y;\n// x3 is is a reference that currently points to,\n// an immutable y, but we could change x3 to point\n// somewhere else.\nlet mut x3 = &y;\n// x4 is a reference that can be used to change y,\n// and can also be updated to point somewhere else.\nlet mut x4 = &mut y;\n"))),(0,r.kt)("h2",{id:"dereferencing"},"Dereferencing"),(0,r.kt)("p",null,"Rust has a ",(0,r.kt)("inlineCode",{parentName:"p"},"*")," operator for dereferencing, very similar to C++ or Go:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"let num1 = 7; // num1 has type `i32`.\nlet num2 = &num1; // num2 has type `&i32`.\nlet num3 = *num2; // num3 has type `i32` again.\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"*")," follows the pointer (see ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch15-smart-pointers#following-the-pointer-to-the-value"},"chapter 15"),"). If the reference is mutable, we can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"*")," operator to modify what the reference points to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let mut val = 10;\nlet val_ref = &mut val;\n*val_ref = 5;\n\n// Prints 5, because we used `val_ref` to modify `val`.\nprintln!("{val}");\n')),(0,r.kt)("h3",{id:"dangling-references"},"Dangling References"),(0,r.kt)("p",null,"You can't return a reference to an object that will be dropped:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'fn dangle() -> &String {\n    let s = String::from("hello");\n    &s // This is an error.\n}\n')),(0,r.kt)("p",null,"Here ",(0,r.kt)("inlineCode",{parentName:"p"},"s")," goes out of scope at the end of the function, so the String will be dropped. That means if Rust let us return a reference to the String, it would be a reference to memory that had already been reclaimed."),(0,r.kt)("p",null,"There's no ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"nil")," in Rust. You can't have a null pointer like you could in C. (Instead there's something called an ",(0,r.kt)("inlineCode",{parentName:"p"},"Option")," which we'll talk about in ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch06-enums-and-pattern-matching",title:"Chapter 6: Enums and Pattern Matching"},"chapter 6"),".)"),(0,r.kt)("h3",{id:"the-rules-of-references"},"The Rules of References"),(0,r.kt)("p",null,"To sum up what we learned above:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"At any given time, you can have ",(0,r.kt)("em",{parentName:"li"},"either")," one mutable reference ",(0,r.kt)("em",{parentName:"li"},"or")," any number of immutable references."),(0,r.kt)("li",{parentName:"ul"},"References must always be valid. You can't have references to dropped memory or null pointers.")),(0,r.kt)("h2",{id:"43---the-slice-type"},"4.3 - The Slice Type"),(0,r.kt)("p",null,"A ",(0,r.kt)("em",{parentName:"p"},"slice")," is a reference to a contiguous sequence of elements in a collection. Slices are references so they don't take ownership. The type of a string slice is ",(0,r.kt)("inlineCode",{parentName:"p"},"&str"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let s = String::from("hello world");\n\nlet hello = &s[0..5]; // Type of `hello` is `&str`.\nlet world = &s[6..11];\n')),(0,r.kt)("p",null,"The range syntax is ",(0,r.kt)("inlineCode",{parentName:"p"},"[inclusive..exclusive]"),". Or, in other words ",(0,r.kt)("inlineCode",{parentName:"p"},"[0..5]")," includes the zeroth character in the string, but omits the fifth. With the range syntax, you can omit the first number to start at 0, and omit the second number to end at the length of the string."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let s = String::from("rust time");\n\nlet rust = &s[..4];\nlet time = &s[5..];\nlet rust_time = &s[..];\n')),(0,r.kt)("p",null,"Slices must occur at valid UTF-8 character boundaries. If you attempt to create a string slice in the middle of a multibyte character, your program will exit with an error. (Don't know what a multibyte character is? See ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch08-common-collections",title:"Chapter 8: Common Collections"},"chapter 8"),"!)"),(0,r.kt)("p",null,"Note that if you have a string slice, this counts as a reference, so you can't also have a mutable reference to that String:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'fn first_word(s: &String) -> &str {\n    let bytes = s.as_bytes();\n\n    for (i, &item) in bytes.iter().enumerate() {\n        if item == b\' \' {\n            return &s[0..i];\n        }\n    }\n\n    &s[..]\n}\n\nfn main() {\n    let mut s = String::from("hello world");\n\n    // `word` ends up being a slice of `s`, so\n    // `word` counts as a reference to `s`.\n    let word = first_word(&s);\n\n    s.clear(); // error!\n\n    println!("the first word is: {}", word);\n}\n')),(0,r.kt)("p",null,"Inside ",(0,r.kt)("inlineCode",{parentName:"p"},"main"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"word")," is a string slice from ",(0,r.kt)("inlineCode",{parentName:"p"},"s"),", and therefore a reference to the memory the ",(0,r.kt)("inlineCode",{parentName:"p"},"String")," uses. The call to ",(0,r.kt)("inlineCode",{parentName:"p"},"s.clear()")," will fail to compile because to clear the string, we'd need to mutate it (",(0,r.kt)("inlineCode",{parentName:"p"},"clear")," is a method with a mutable reference to ",(0,r.kt)("inlineCode",{parentName:"p"},"self"),"). Since we can't create a mutable reference while ",(0,r.kt)("inlineCode",{parentName:"p"},"word")," is in scope, this fails to compile."),(0,r.kt)("h3",{id:"string-literals-as-slices"},"String Literals as Slices"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let s = "Hello, world!";\n')),(0,r.kt)("p",null,"The type of ",(0,r.kt)("inlineCode",{parentName:"p"},"s")," here is ",(0,r.kt)("inlineCode",{parentName:"p"},"&str"),": it's a slice pointing to where this string is stored in the binary."),(0,r.kt)("h3",{id:"string-slices-as-parameters"},"String Slices as Parameters"),(0,r.kt)("p",null,"These two function signatures are very similar:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"fn first_word_string(s: &String) -> &str {...}\n\nfn first_word_str(s: &str) -> &str {...}\n")),(0,r.kt)("p",null,"The first takes a reference to a String, the second takes a string slice. The second one, though, is generally preferred. It's trivial to convert a string to a slice, so you can call the second with any ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),", string slice, or string literal, or even a reference to a ",(0,r.kt)("inlineCode",{parentName:"p"},"String")," (see ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch15-smart-pointers",title:"Chapter 15: Smart Pointers"},"chapter 15")," for more on ",(0,r.kt)("em",{parentName:"p"},"deref coercion"),")."),(0,r.kt)("p",null,"In the reverse direction, it's a bit tedious to convert a string slice into a ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),". As a result the first version, ",(0,r.kt)("inlineCode",{parentName:"p"},"first_word_string"),", is much less flexible."),(0,r.kt)("h3",{id:"other-slices"},"Other Slices"),(0,r.kt)("p",null,"Much like in Go, we can also create slices from arrays:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"let a = [1, 2, 3, 4, 5];\n\nlet slice = &a[1..3];\n\nassert_eq!(slice, &[2, 3]);\n")),(0,r.kt)("p",null,"The type of ",(0,r.kt)("inlineCode",{parentName:"p"},"slice")," here is ",(0,r.kt)("inlineCode",{parentName:"p"},"&[i32]"),"."),(0,r.kt)("p",null,"Continue to ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch05-structs",title:"Chapter 5: Using Structs to Structure Related Data"},"chapter 5"),"."))}h.isMDXComponent=!0}}]);