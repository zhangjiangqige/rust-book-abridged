"use strict";(self.webpackChunkrust_book_abridged=self.webpackChunkrust_book_abridged||[]).push([[757],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),m=p(n),c=r,h=m["".concat(l,".").concat(c)]||m[c]||d[c]||i;return n?a.createElement(h,o(o({ref:t},u),{},{components:n})):a.createElement(h,o({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[m]="string"==typeof e?e:r,o[1]=s;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},6876:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const i={},o="2 - Programming a Guessing Game",s={unversionedId:"ch02-guessing-game",id:"ch02-guessing-game",title:"2 - Programming a Guessing Game",description:"This chapter creates a little \"guessing game\" program. The program picks a random number, you try to guess the secret number, and the program will tell you if you're too high or too low. Hours of fun! We're going to introduce a bunch of concepts but not go into anything in too much detail in this chapter.",source:"@site/docs/ch02-guessing-game.md",sourceDirName:".",slug:"/ch02-guessing-game",permalink:"/rust-book-abridged/ch02-guessing-game",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ch02-guessing-game.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"1 - Getting Started",permalink:"/rust-book-abridged/ch01-getting-started"},next:{title:"3 - Common Programming Concepts",permalink:"/rust-book-abridged/ch03-common-programming-concepts"}},l={},p=[{value:"Storing Values with Variables",id:"storing-values-with-variables",level:2},{value:"Handling Potential Failure with <code>Result</code>",id:"handling-potential-failure-with-result",level:2},{value:"Printing Values with <code>println!</code> Placeholders",id:"printing-values-with-println-placeholders",level:2},{value:"Generating a Secret Number",id:"generating-a-secret-number",level:2},{value:"Comparing the Guess to the Secret Number",id:"comparing-the-guess-to-the-secret-number",level:2},{value:"Allowing Multiple Guesses with Looping",id:"allowing-multiple-guesses-with-looping",level:2},{value:"Handling Invalid Input",id:"handling-invalid-input",level:2}],u={toc:p},m="wrapper";function d(e){let{components:t,...n}=e;return(0,r.kt)(m,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"2---programming-a-guessing-game"},"2 - Programming a Guessing Game"),(0,r.kt)("p",null,"This chapter creates a little \"guessing game\" program. The program picks a random number, you try to guess the secret number, and the program will tell you if you're too high or too low. Hours of fun! We're going to introduce a bunch of concepts but not go into anything in too much detail in this chapter."),(0,r.kt)("p",null,"Create the project with:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"$ cargo new guessing_game\n$ cd guessing_game\n")),(0,r.kt)("p",null,"To start, let's just worry about getting some user input. Open up ",(0,r.kt)("em",{parentName:"p"},"src/main.rs")," in your favorite text editor and copy/paste the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},'use std::io;\n\nfn main() {\n    println!("Guess the number!");\n\n    println!("Please input your guess.");\n\n    let mut guess = String::new();\n\n    io::stdin()\n        .read_line(&mut guess)\n        .expect("Failed to read line");\n\n    println!("You guessed: {guess}");\n}\n')),(0,r.kt)("p",null,"You can run this with ",(0,r.kt)("inlineCode",{parentName:"p"},"cargo run"),", and it should ask you to enter a value and then print out what you entered."),(0,r.kt)("p",null,"In order to read user input, we're using the ",(0,r.kt)("inlineCode",{parentName:"p"},"io")," library from the standard library, but to reference ",(0,r.kt)("inlineCode",{parentName:"p"},"io")," more conveniently we bring it into ",(0,r.kt)("em",{parentName:"p"},"scope"),". We do this with the first line, ",(0,r.kt)("inlineCode",{parentName:"p"},"use std::io"),". This is a bit like an ",(0,r.kt)("inlineCode",{parentName:"p"},"import")," statement in python or Java, but note that that don't need to explicitly import ",(0,r.kt)("inlineCode",{parentName:"p"},"io")," to use it. We could remove the ",(0,r.kt)("inlineCode",{parentName:"p"},"use")," line and replace ",(0,r.kt)("inlineCode",{parentName:"p"},"io::stdin()")," with ",(0,r.kt)("inlineCode",{parentName:"p"},"std::io::stdin()"),". There are a number of symbols that Rust brings into scope for you from the standard library automatically - things that get used in almost every program you're going to write. This set is called ",(0,r.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/stable/std/prelude/index.html"},"the ",(0,r.kt)("em",{parentName:"a"},"prelude")),"."),(0,r.kt)("h2",{id:"storing-values-with-variables"},"Storing Values with Variables"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"    let mut guess = String::new();\n")),(0,r.kt)("p",null,"This creates new String and binds it to a mutable variable called ",(0,r.kt)("inlineCode",{parentName:"p"},"guess"),". By default variables in Rust are immutable. Obviously if this were an immutable string then the ",(0,r.kt)("inlineCode",{parentName:"p"},"read_line")," function would have a difficult time storing anything it it, so we use the ",(0,r.kt)("inlineCode",{parentName:"p"},"mut")," keyword to make it mutable. In the call to ",(0,r.kt)("inlineCode",{parentName:"p"},"String::new()"),", the ",(0,r.kt)("inlineCode",{parentName:"p"},"::")," part tells us that ",(0,r.kt)("inlineCode",{parentName:"p"},"new")," is an ",(0,r.kt)("em",{parentName:"p"},"associated function")," implemented on the String type. Many types in Rust implement a ",(0,r.kt)("inlineCode",{parentName:"p"},"new")," constructor like this."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'    io::stdin()\n        .read_line(&mut guess)\n        .expect("Failed to read line");\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"read_line")," reads some input from stdin, and stores it in ",(0,r.kt)("inlineCode",{parentName:"p"},"guess"),". We pass in ",(0,r.kt)("inlineCode",{parentName:"p"},"&mut guess")," instead of just ",(0,r.kt)("inlineCode",{parentName:"p"},"guess"),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"&")," means we pass a reference to the object that the ",(0,r.kt)("inlineCode",{parentName:"p"},"guess")," variable points to, and ",(0,r.kt)("inlineCode",{parentName:"p"},"mut")," means that ",(0,r.kt)("inlineCode",{parentName:"p"},"read_line")," is allowed to mutate that variable."),(0,r.kt)("p",null,"Passing by reference here works very similar to passing by pointer in Go or C, or passing an object in Java or JavaScript - the called function/method can modify the passed in object, and those changes will be visible in the caller's scope. References also have a lot of implications for ownership. We'll go into references in much greater detail in ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch04-ownership",title:"Chapter 4: Ownership, References, and Slices"},"chapter 4"),"."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"If you're coming from a C/C++ background, Rust references are a little bit like C++ references, and a little bit like C pointers.  We'll go into this in more detail in chapter 4. You might also assume that without the ",(0,r.kt)("inlineCode",{parentName:"p"},"&")," Rust would pass a copy of ",(0,r.kt)("inlineCode",{parentName:"p"},"guess"),", but this isn't true. When we pass a value without using a reference in Rust, we actually transfer ownership of the value to the called function. This is getting way ahead of ourselves though - again, we'll get there in ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch04-ownership",title:"Chapter 4: Ownership, References, and Slices"},"chapter 4"),".")),(0,r.kt)("h2",{id:"handling-potential-failure-with-result"},"Handling Potential Failure with ",(0,r.kt)("inlineCode",{parentName:"h2"},"Result")),(0,r.kt)("p",null,"In Rust, when a function can fail it returns a ",(0,r.kt)("inlineCode",{parentName:"p"},"Result")," (see ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch09-error-handling",title:"Chapter 9: Error Handling"},"chapter 9"),"). ",(0,r.kt)("inlineCode",{parentName:"p"},"read_line")," can theoretically fail - here we're reading from stdin which is probably not going to fail, but if we were reading from a file or a network connection it could."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Result")," is an enum (see ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch06-enums-and-pattern-matching",title:"Chapter 6: Enums and Pattern Matching"},"chapter 6"),") which will either be an ",(0,r.kt)("inlineCode",{parentName:"p"},"Ok")," variant in the success case or an ",(0,r.kt)("inlineCode",{parentName:"p"},"Err")," variant to signal an error has occurred. Enums are a bit unique in Rust in that an enum can carry extra information with it. If the ",(0,r.kt)("inlineCode",{parentName:"p"},"Result")," is an ",(0,r.kt)("inlineCode",{parentName:"p"},"Err"),", it will contain the reason why this operation failed. If the ",(0,r.kt)("inlineCode",{parentName:"p"},"Result")," is an ",(0,r.kt)("inlineCode",{parentName:"p"},"Ok")," it could contain some information (although here it doesn't)."),(0,r.kt)("p",null,"We're kind of glossing over the error handling here by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"expect")," on the ",(0,r.kt)("inlineCode",{parentName:"p"},"Result"),", which will cause a ",(0,r.kt)("em",{parentName:"p"},"panic")," if there's an error. If you were to remove the call to ",(0,r.kt)("inlineCode",{parentName:"p"},"expect"),", then the program would still compile, but you'd get a warning that you have a possible error case that you might not have handled correctly."),(0,r.kt)("h2",{id:"printing-values-with-println-placeholders"},"Printing Values with ",(0,r.kt)("inlineCode",{parentName:"h2"},"println!")," Placeholders"),(0,r.kt)("p",null,"The last line is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'    println!("You guessed: {guess}");\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"println!")," here is a macro that writes some string to stdout. It's very similar to ",(0,r.kt)("inlineCode",{parentName:"p"},"printf")," in C or Go. In one of those languages we could rewrite the above as ",(0,r.kt)("inlineCode",{parentName:"p"},'printf("You guessed: %s", guess)'),"."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"{}")," is a placeholder. You can place a single variable directly in the placeholder, but if you have an expression you'd have to use ",(0,r.kt)("inlineCode",{parentName:"p"},"{}")," as the placeholder and then pass your expression as a second parameter:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'    println!("1 + 2 = {}", 1 + 2);\n')),(0,r.kt)("h2",{id:"generating-a-secret-number"},"Generating a Secret Number"),(0,r.kt)("p",null,"We now have a program that asks you to guess a number, but we're not yet generating a secret number to guess. Since Rust has no random number generator in the standard library, we'll rely on the \"rand\" ",(0,r.kt)("em",{parentName:"p"},"crate")," from ",(0,r.kt)("a",{parentName:"p",href:"https://crates.io/"},"crates.io"),". To add ",(0,r.kt)("inlineCode",{parentName:"p"},"rand")," to our project we can run:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"$ cargo add rand\n")),(0,r.kt)("p",null,"Once you do this, if you open up ",(0,r.kt)("em",{parentName:"p"},"Cargo.toml"),", you'll see rand listed as one of our dependencies:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-toml"},'[dependencies]\nrand = "0.8.5"\n')),(0,r.kt)("p",null,"Just like node.js dependencies, this uses ",(0,r.kt)("a",{parentName:"p",href:"https://semver.org/"},"semantic versioning"),'. Here "0.8.5" is short for "^0.8.5", which means Cargo will install a version ',(0,r.kt)("inlineCode",{parentName:"p"},">= 0.8.5")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"< 0.9.0"),". When you run ",(0,r.kt)("inlineCode",{parentName:"p"},"cargo build")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"cargo run"),", cargo will automatically download this dependency (and any transitive dependencies it relies on) and add them to ",(0,r.kt)("em",{parentName:"p"},"Cargo.lock"),". If a new patch version of ",(0,r.kt)("inlineCode",{parentName:"p"},"rand")," comes out and you want to upgrade to it, you can update the lock file with ",(0,r.kt)("inlineCode",{parentName:"p"},"cargo update"),". If a new minor or major version comes out, you'd have to update the ",(0,r.kt)("inlineCode",{parentName:"p"},"Cargo.toml")," file."),(0,r.kt)("p",null,"You can run ",(0,r.kt)("inlineCode",{parentName:"p"},"cargo doc --open")," to generate HTML documentation for all the crates you're using (and all of their dependencies) and also for all of your code (see ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch14-more-about-cargo",title:"Chapter 14: More About Cargo and Crates.io"},"chapter 14"),")."),(0,r.kt)("p",null,'Now that we have the "rand" crate, let\'s update ',(0,r.kt)("em",{parentName:"p"},"src/main.rs"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},'use std::io;\nuse rand::Rng;\n\nfn main() {\n    println!("Guess the number!");\n\n    let secret_number = rand::thread_rng()\n        .gen_range(1..=100);\n\n    println!("The secret number is: {secret_number}");\n\n    println!("Please input your guess.");\n\n    let mut guess = String::new();\n\n    io::stdin()\n        .read_line(&mut guess)\n        .expect("Failed to read line");\n\n    println!("You guessed: {guess}");\n}\n')),(0,r.kt)("p",null,"This line generates our random number:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"    let secret_number = rand::thread_rng()\n        .gen_range(1..=100);\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"rand::thread_rng()")," returns an object that implements the ",(0,r.kt)("inlineCode",{parentName:"p"},"Rng")," ",(0,r.kt)("em",{parentName:"p"},"trait")," (see ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch10/ch10-01-generic-data-types",title:"Chapter 10: Generic Types, Traits, and Lifetimes"},"chapter 10"),'). A trait is very similar to what other languages would call an "interface". We call the ',(0,r.kt)("inlineCode",{parentName:"p"},"gen_range")," method (from the ",(0,r.kt)("inlineCode",{parentName:"p"},"Rng")," trait) passing in a ",(0,r.kt)("em",{parentName:"p"},"range expression")," to generate a random number between 1 and 100 inclusive (if the range express was ",(0,r.kt)("inlineCode",{parentName:"p"},"1..100")," it would be 1 to 99 inclusive)."),(0,r.kt)("p",null,"Notice we ",(0,r.kt)("inlineCode",{parentName:"p"},"use rand::Rng")," to bring ",(0,r.kt)("inlineCode",{parentName:"p"},"Rng")," into scope. This might seem a little strange, because if you read through this code we never use ",(0,r.kt)("inlineCode",{parentName:"p"},"Rng")," directly. In Rust, though, in order to call the ",(0,r.kt)("inlineCode",{parentName:"p"},"gen_range")," method on an object that has the ",(0,r.kt)("inlineCode",{parentName:"p"},"Rng")," trait we need to have the ",(0,r.kt)("inlineCode",{parentName:"p"},"Rng")," trait in scope."),(0,r.kt)("h2",{id:"comparing-the-guess-to-the-secret-number"},"Comparing the Guess to the Secret Number"),(0,r.kt)("p",null,"Now that we have a guess from our user and a random number from ",(0,r.kt)("inlineCode",{parentName:"p"},"rand"),", we can compare them. Add ",(0,r.kt)("inlineCode",{parentName:"p"},"use std::cmp::Ordering")," to the top of the file, and then we can:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'    println!("You guessed: {guess}");\n\n    let guess: u32 = guess.trim().parse().expect("Please type a number!");\n    match guess.cmp(&secret_number) {\n        Ordering::Less => println!("Too small!"),\n        Ordering::Greater => println!("Too big!"),\n        Ordering::Equal => println!("You win!"),\n    }\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"comp")," compares two comparable things and returns an ",(0,r.kt)("inlineCode",{parentName:"p"},"Ordering"),", which is another enum (like ",(0,r.kt)("inlineCode",{parentName:"p"},"Result")," above). We use a ",(0,r.kt)("inlineCode",{parentName:"p"},"match")," statement to decide what to do with the ",(0,r.kt)("inlineCode",{parentName:"p"},"Ordering"),". A ",(0,r.kt)("inlineCode",{parentName:"p"},"match")," statement is very similar to a ",(0,r.kt)("inlineCode",{parentName:"p"},"switch/case")," statement in other languages. A ",(0,r.kt)("inlineCode",{parentName:"p"},"match")," expression in Rust is made up of ",(0,r.kt)("em",{parentName:"p"},"arms"),", each of which consists of a pattern to match against, and the code that should be run if the value fits that arm's pattern, with a ",(0,r.kt)("inlineCode",{parentName:"p"},"=>")," between them. Patterns and matches will be covered in more detail in ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch06-enums-and-pattern-matching",title:"Chapter 6: Enums and Pattern Matching"},"chapter 6")," and ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch18-patterns-and-matching",title:"Chapter 18: Patterns and Matching"},"chapter 18"),"."),(0,r.kt)("p",null,"Notice the line in the block above where we call ",(0,r.kt)("inlineCode",{parentName:"p"},"parse"),". We're creating a new variable here called ",(0,r.kt)("inlineCode",{parentName:"p"},"guess")," of type ",(0,r.kt)("inlineCode",{parentName:"p"},"u32"),", but we already had a variable named ",(0,r.kt)("inlineCode",{parentName:"p"},"guess")," of type ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),". This is OK, as Rust lets us ",(0,r.kt)("em",{parentName:"p"},"shadow")," the old variable."),(0,r.kt)("p",null,"We are annotating the new ",(0,r.kt)("inlineCode",{parentName:"p"},"guess")," variable with ",(0,r.kt)("inlineCode",{parentName:"p"},": u32"),". This makes guess an unsigned 32 bit integer. If you're coming from another language, you might find the need to annotate the type here surprising. Shouldn't Rust be inferring the type automatically based on what ",(0,r.kt)("inlineCode",{parentName:"p"},"parse")," returns? Actually, exactly the opposite is happening. ",(0,r.kt)("inlineCode",{parentName:"p"},"parse")," is a generic function, that can return different types depending on what we want it to return, and the Rust compiler here is inferring from the fact that we're assigning to a u32 that it should call the version of ",(0,r.kt)("inlineCode",{parentName:"p"},"parse")," that returns a u32. In fact, annotating the type of ",(0,r.kt)("inlineCode",{parentName:"p"},"guess")," here also changes the type of ",(0,r.kt)("inlineCode",{parentName:"p"},"secret_number"),". By default ",(0,r.kt)("inlineCode",{parentName:"p"},"secret_number")," would have been an i32 - a signed 32 bit number - because this is the default Rust picks for a number unless we give it reason not to. But, because we're calling ",(0,r.kt)("inlineCode",{parentName:"p"},"cmp")," to compare ",(0,r.kt)("inlineCode",{parentName:"p"},"secret_number")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"guess"),", Rust's type inference engine makes ",(0,r.kt)("inlineCode",{parentName:"p"},"secret_number")," a u32 as well, so we're not comparing mismatched types. The type inference engine in Rust is magic!"),(0,r.kt)("h2",{id:"allowing-multiple-guesses-with-looping"},"Allowing Multiple Guesses with Looping"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"loop")," keyword creates an infinite loop, and the ",(0,r.kt)("inlineCode",{parentName:"p"},"break")," keyword can be used to break out of it:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'    loop {\n        println!("Please input your guess.");\n\n        // --snip--\n\n        match guess.cmp(&secret_number) {\n            Ordering::Less => println!("Too small!"),\n            Ordering::Greater => println!("Too big!"),\n            Ordering::Equal => {\n                println!("You win!");\n                break; // Break out of this loop.\n            }\n        }\n    }\n')),(0,r.kt)("h2",{id:"handling-invalid-input"},"Handling Invalid Input"),(0,r.kt)("p",null,'When prompted for a guess, if you enter something that isn\'t a number such as "hello" then the program will crash. This is because ',(0,r.kt)("inlineCode",{parentName:"p"},"parse")," won't be able the parse the number, so will return a ",(0,r.kt)("inlineCode",{parentName:"p"},"Result")," of type ",(0,r.kt)("inlineCode",{parentName:"p"},"Err"),", and the ",(0,r.kt)("inlineCode",{parentName:"p"},"expect")," call will cause a panic. We can use a ",(0,r.kt)("inlineCode",{parentName:"p"},"match")," statement just like we did for ",(0,r.kt)("inlineCode",{parentName:"p"},"cmp")," to handle the Result from ",(0,r.kt)("inlineCode",{parentName:"p"},"parse")," more gracefully:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"        let guess: u32 = match guess.trim().parse() {\n            Ok(num) => num,\n            Err(_) => continue,\n        };\n")),(0,r.kt)("p",null,"Here we're using ",(0,r.kt)("inlineCode",{parentName:"p"},"match")," as an expression instead of just as flow control. If the user enters a valid number, ",(0,r.kt)("inlineCode",{parentName:"p"},"parse")," will return an ",(0,r.kt)("inlineCode",{parentName:"p"},"Ok")," which will match the first arm of the ",(0,r.kt)("inlineCode",{parentName:"p"},"match"),". This will cause the whole ",(0,r.kt)("inlineCode",{parentName:"p"},"match")," expression to evaluate to ",(0,r.kt)("inlineCode",{parentName:"p"},"num"),", which will be assigned back to ",(0,r.kt)("inlineCode",{parentName:"p"},"guess"),". If the input is invalid, we ",(0,r.kt)("inlineCode",{parentName:"p"},"continue")," to the top of the loop and ask for the number again."),(0,r.kt)("p",null,"The Err may contain some information, but we're assigning it to the special ",(0,r.kt)("inlineCode",{parentName:"p"},"_")," variable because we don't care what kind of error this is."),(0,r.kt)("p",null,"Here's the final program:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},'use rand::Rng;\nuse std::cmp::Ordering;\nuse std::io;\n\nfn main() {\n    println!("Guess the number!");\n\n    let secret_number = rand::thread_rng().gen_range(1..=100);\n\n    loop {\n        println!("Please input your guess.");\n\n        let mut guess = String::new();\n\n        io::stdin()\n            .read_line(&mut guess)\n            .expect("Failed to read line");\n\n        let guess: u32 = match guess.trim().parse() {\n            Ok(num) => num,\n            Err(_) => continue,\n        };\n\n        println!("You guessed: {guess}");\n\n        match guess.cmp(&secret_number) {\n            Ordering::Less => println!("Too small!"),\n            Ordering::Greater => println!("Too big!"),\n            Ordering::Equal => {\n                println!("You win!");\n                break;\n            }\n        }\n    }\n}\n')),(0,r.kt)("p",null,"Now that you have a rough idea of what a Rust program looks like, and we have some terminology down, let's start looking at some ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch03-common-programming-concepts",title:"Chapter 3: Common Programming Concepts"},"basic Rust syntax in more detail"),"."))}d.isMDXComponent=!0}}]);