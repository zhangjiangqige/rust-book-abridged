"use strict";(self.webpackChunkrust_book_abridged=self.webpackChunkrust_book_abridged||[]).push([[622],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>f});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),u=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},c=function(e){var n=u(e.components);return a.createElement(l.Provider,{value:n},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=u(t),m=r,f=d["".concat(l,".").concat(m)]||d[m]||p[m]||o;return t?a.createElement(f,i(i({ref:n},c),{},{components:t})):a.createElement(f,i({ref:n},c))}));function f(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=m;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[d]="string"==typeof e?e:r,i[1]=s;for(var u=2;u<o;u++)i[u]=t[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},341:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>u});var a=t(7462),r=(t(7294),t(3905));const o={},i="19.1 - Unsafe Rust",s={unversionedId:"ch19/ch19-01-unsafe",id:"ch19/ch19-01-unsafe",title:"19.1 - Unsafe Rust",description:"This chapter is meant as an introduction to unsafe code, but if you find yourself actually writing unsafe code, it would be a good idea to read through the Rustonomicon. There are many things you can do in unsafe code that will result in undefined behavior, some of which you might surprise you if you're coming from a language like C/C++.",source:"@site/docs/ch19/ch19-01-unsafe.md",sourceDirName:"ch19",slug:"/ch19/ch19-01-unsafe",permalink:"/rust-book-abridged/ch19/ch19-01-unsafe",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ch19/ch19-01-unsafe.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"19 - Advanced Features",permalink:"/rust-book-abridged/category/19---advanced-features"},next:{title:"19.2 - Advanced Traits",permalink:"/rust-book-abridged/ch19/ch19-02-advanced-traits"}},l={},u=[{value:"Unsafe Superpowers",id:"unsafe-superpowers",level:2},{value:"Dereferencing a Raw Pointer",id:"dereferencing-a-raw-pointer",level:2},{value:"Calling an Unsafe Function or Method",id:"calling-an-unsafe-function-or-method",level:2},{value:"Creating a Safe Abstraction over Unsafe Code",id:"creating-a-safe-abstraction-over-unsafe-code",level:3},{value:"Using <code>extern</code> Functions to Call External Code",id:"using-extern-functions-to-call-external-code",level:3},{value:"Accessing or Modifying a Mutable Static Variable",id:"accessing-or-modifying-a-mutable-static-variable",level:2},{value:"Implementing an Unsafe Trait",id:"implementing-an-unsafe-trait",level:2},{value:"Accessing Fields of a Union",id:"accessing-fields-of-a-union",level:2},{value:"Soundness",id:"soundness",level:2},{value:"Verifying unsafe code with Miri",id:"verifying-unsafe-code-with-miri",level:2}],c={toc:u},d="wrapper";function p(e){let{components:n,...t}=e;return(0,r.kt)(d,(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"191---unsafe-rust"},"19.1 - Unsafe Rust"),(0,r.kt)("admonition",{type:"danger"},(0,r.kt)("p",{parentName:"admonition"},"This chapter is meant as an introduction to unsafe code, but if you find yourself actually writing unsafe code, it would be a good idea to ",(0,r.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/nomicon/intro.html"},"read through the Rustonomicon"),". There are many things you can do in unsafe code that will result in undefined behavior, some of which you might surprise you if you're coming from a language like C/C++.")),(0,r.kt)("p",null,"Rust enforces all sort of safety features for us, preventing us from dereferencing null pointers, preventing us from creating potential data races. Sometimes, though, we know better than the compiler."),(0,r.kt)("p",null,"Imagine we have a vector with six elements in it. We could create a mutable slice to elements 0-2 and a second mutable slice from elements 3-5, and there'd be no chance of a data race, since these two mutable references point to different regions of memory. The problem with this is that when we call ",(0,r.kt)("inlineCode",{parentName:"p"},"&mut values[0..=2]"),", we have a mutable reference to the underlying array, not to part of the array, and we won't be able to create a second one. Here the compiler is trying to protect us, but it's actually getting in our way."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Unsafe")," code in Rust is code where we're allowed to ignore or bypass some of the restrictions Rust places on us, and tell the compiler \"Don't worry, I got this.\" Of course, sometimes we only think we know better than the compiler when in fact what we're actually doing is creating dreaded ",(0,r.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/reference/behavior-considered-undefined.html"},"undefined behavior"),". So it's not a bad idea to keep unsafe code to a minimum."),(0,r.kt)("p",null,"But it's important to note that \"unsafe\" doesn't necessarily mean incorrect, it's just code that hasn't been inspected by the eagle eye of the Rust compiler. There are plenty of C programs in the world performing useful tasks that are correct (or reasonably correct) and C doesn't even have a borrow checker, so all C code is unsafe as far as a Rust programmer is concerned."),(0,r.kt)("p",null,"We can write code inside an unsafe block or inside an unsafe function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"fn main() {\n    unsafe {\n        // Do crazy stuff here!\n    }\n}\n")),(0,r.kt)("h2",{id:"unsafe-superpowers"},"Unsafe Superpowers"),(0,r.kt)("p",null,"There are five ",(0,r.kt)("em",{parentName:"p"},"unsafe superpowers"),". These are things you're allowed to do inside an ",(0,r.kt)("inlineCode",{parentName:"p"},"unsafe")," block or function that you aren't allowed to do outside of them:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Dereference a raw pointer"),(0,r.kt)("li",{parentName:"ul"},"Call another unsafe function or method"),(0,r.kt)("li",{parentName:"ul"},"Access or modify a mutable static variable"),(0,r.kt)("li",{parentName:"ul"},"Implement an unsafe trait"),(0,r.kt)("li",{parentName:"ul"},"Access fields of a ",(0,r.kt)("inlineCode",{parentName:"li"},"union"))),(0,r.kt)("p",null,"Other than these five things, unsafe code is mostly like safe code. The borrow checker is still checking your borrows, immutable references are still immutable, the sun still rises in the east. These five things do let you get into a surprising amount of trouble though - it's important to document your assumptions and invariants, and carefully ensure you're meeting the assumptions and invariants of any unsafe functions you're calling into."),(0,r.kt)("h2",{id:"dereferencing-a-raw-pointer"},"Dereferencing a Raw Pointer"),(0,r.kt)("p",null,"Raw pointers come in two types: ",(0,r.kt)("inlineCode",{parentName:"p"},"*const T")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"*mut T"),". These are a lot closer to pointers in C than references in Rust:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"You can have both immutable and mutable pointers pointing to the same location in memory."),(0,r.kt)("li",{parentName:"ul"},"Pointers can point to memory that has been freed or isn't valid."),(0,r.kt)("li",{parentName:"ul"},"Pointers can be null."),(0,r.kt)("li",{parentName:"ul"},"Pointers don't do any kind of automatic cleanup.")),(0,r.kt)("p",null,"Since Rust doesn't make any guarantees about raw pointers, it's up to you to make sure you use them correctly by reasoning about your code. Let's see a couple of examples:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let mut num = 5;\n\n// Create a mutable and const pointer to the same memory.\nlet r1 = &mut num as *mut i32;\nlet r2 = unsafe { &*r1 as *const i32 };\n\nunsafe {\n    println!("r1 is: {}", *r1);\n    println!("r2 is: {}", *r2);\n}\n\n// Create a pointer to a specific address.\n// (Hopefully this is memory we own!)\n// Note the `as` keyword to cast the value\n// into a raw pointer.\nlet address = 0x012345usize;\nlet r = address as *const i32;\n')),(0,r.kt)("p",null,"We're allowed to create pointers outside of unsafe code. Creating a pointer never hurt anyone, it's dereferencing a pointer that gets us into trouble, so the dereference is only allowed to happen inside an ",(0,r.kt)("inlineCode",{parentName:"p"},"unsafe")," block."),(0,r.kt)("p",null,'Why would you want to use a raw pointer instead of a reference? One case is for calling into C code. Another is when you want to build a "safe" abstraction that the borrow checker won\'t understand, like our "two mutable slices" example above. We\'ll see examples of both of these.'),(0,r.kt)("h2",{id:"calling-an-unsafe-function-or-method"},"Calling an Unsafe Function or Method"),(0,r.kt)("p",null,"The second of our superpowers is calling an unsafe function or method. If you want to call an unsafe function, you can only do so from an unsafe function or block:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"unsafe fn dangerous() {}\n\nunsafe {\n    dangerous();\n}\n")),(0,r.kt)("p",null,"Any function that's marked as ",(0,r.kt)("inlineCode",{parentName:"p"},"unsafe")," like this is implicitly an unsafe block."),(0,r.kt)("h3",{id:"creating-a-safe-abstraction-over-unsafe-code"},"Creating a Safe Abstraction over Unsafe Code"),(0,r.kt)("p",null,'Let\'s go back to our "two mutable slices" example from earlier. We want to write a function that will split a vector into two mutable slices:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"let mut v = vec![1, 2, 3, 4, 5, 6];\n\nlet r = &mut v[..];\n\nlet (a, b) = r.split_at_mut(3);\n\nassert_eq!(a, &mut [1, 2, 3]);\nassert_eq!(b, &mut [4, 5, 6]);\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"split_at_mut")," is going to call unsafe code, but that doesn't mean that it also has to be unsafe. In fact, the above code works because vector has this method on it already!"),(0,r.kt)("p",null,"What ",(0,r.kt)("inlineCode",{parentName:"p"},"split_at_mut")," is doing here is creating a \"safe abstraction\". This is a very common pattern - we hide away the unsafe stuff behind an API that's easy and safe to use. This makes it so we only have to reason about our small API. Here's the implementation of ",(0,r.kt)("inlineCode",{parentName:"p"},"split_at_mut"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"use std::slice;\n\nfn split_at_mut(values: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {\n    let len = values.len();\n    let ptr = values.as_mut_ptr();\n\n    assert!(mid <= len);\n\n    unsafe {\n        (\n            slice::from_raw_parts_mut(ptr, mid),\n            slice::from_raw_parts_mut(ptr.add(mid), len - mid),\n        )\n    }\n}\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"slice::from_raw_parts_mut")," is unsafe (because it uses a raw pointer to the underlying slice) so we need to call this inside an ",(0,r.kt)("inlineCode",{parentName:"p"},"unsafe")," block."),(0,r.kt)("h3",{id:"using-extern-functions-to-call-external-code"},"Using ",(0,r.kt)("inlineCode",{parentName:"h3"},"extern")," Functions to Call External Code"),(0,r.kt)("p",null,"Programming languages can call into code written in other languages via a ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Foreign_function_interface"},(0,r.kt)("em",{parentName:"a"},"Foreign Function Interface")," (FFI)"),". If you wanted to use OpenSSL from Rust, for example, rather than rewriting OpenSSL in Rust you could just call into the existing C code. You might build a wrapper crate around OpenSSL to turn it into something easy to use from Rust, and provide safe abstractions around everything the library does."),(0,r.kt)("p",null,"Here's an example of calling ",(0,r.kt)("inlineCode",{parentName:"p"},"abs")," from the C standard library:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'extern "C" {\n    fn abs(input: i32) -> i32;\n}\n\nfn main() {\n    unsafe {\n        println!("Absolute value of -3 according to C: {}", abs(-3));\n    }\n}\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},'extern "C"')," block tells Rust we're going to call an external function using the C ",(0,r.kt)("em",{parentName:"p"},"application binary interface"),"."),(0,r.kt)("p",null,"We can also use the ",(0,r.kt)("inlineCode",{parentName:"p"},"extern")," keyword to create a function that can be called from C:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#[no_mangle]\npub extern "C" fn call_from_c() {\n    println!("Just called a Rust function from C!");\n}\n')),(0,r.kt)("h2",{id:"accessing-or-modifying-a-mutable-static-variable"},"Accessing or Modifying a Mutable Static Variable"),(0,r.kt)("p",null,"As mentioned in ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch03-common-programming-concepts",title:"Chapter 3: Common Programming Concepts"},"chapter 3"),", Rust has global variables, called ",(0,r.kt)("em",{parentName:"p"},"static variables"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'static HELLO_WORLD: &str = "Hello, world!";\n\nfn main() {\n    println!("name is: {}", HELLO_WORLD);\n}\n')),(0,r.kt)("p",null,"When we use a constant in Rust, the compiler may duplicate the constant in multiple places in memory if they are referenced in multiple places. Static variables, on the other hand, are always guaranteed to occur only once in memory, so no matter where they are referenced in code you'll get back the same instance. Unlike constants, static variables can also be ",(0,r.kt)("inlineCode",{parentName:"p"},"mut"),", but accessing or modifying a mutable static variable is always unsafe:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'static mut COUNTER: u32 = 0;\n\nfn add_to_count(inc: u32) {\n    unsafe {\n        COUNTER += inc;\n    }\n}\n\nfn main() {\n    add_to_count(3);\n\n    unsafe {\n        println!("COUNTER: {}", COUNTER);\n    }\n}\n')),(0,r.kt)("p",null,"It is quite difficult, especially in a multi-threaded program, to ensure that access to a mutable static variable doesn't create a data race."),(0,r.kt)("h2",{id:"implementing-an-unsafe-trait"},"Implementing an Unsafe Trait"),(0,r.kt)("p",null,"We call a trait an ",(0,r.kt)("em",{parentName:"p"},"unsafe trait")," when it has some invariant that the compiler can't verify for us. An example would be the ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch16-fearless-concurrency#164---extensible-concurrency-with-the-sync-and-send-traits"},(0,r.kt)("inlineCode",{parentName:"a"},"Send")," and ",(0,r.kt)("inlineCode",{parentName:"a"},"Sync")," traits"),". Any struct made entire of ",(0,r.kt)("inlineCode",{parentName:"p"},"Send")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Sync")," members automatically becomes ",(0,r.kt)("inlineCode",{parentName:"p"},"Send")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Sync"),". If we want to create a struct that contains a raw pointer, and we can guarantee that this struct is safe to send across threads or can be accessed from multiple threads, then we'll have to mark the type as ",(0,r.kt)("inlineCode",{parentName:"p"},"Send")," and/or ",(0,r.kt)("inlineCode",{parentName:"p"},"Sync")," ourselves."),(0,r.kt)("p",null,"In order to do this, we use an ",(0,r.kt)("inlineCode",{parentName:"p"},"unsafe impl")," block:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"unsafe trait Foo {\n    // methods go here\n}\n\nunsafe impl Foo for i32 {\n    // method implementations go here\n}\n")),(0,r.kt)("h2",{id:"accessing-fields-of-a-union"},"Accessing Fields of a Union"),(0,r.kt)("p",null,"Unions are included in Rust mainly for calling into C code that uses them. If you want to access a union, it has to be done from an ",(0,r.kt)("inlineCode",{parentName:"p"},"unsafe")," block."),(0,r.kt)("p",null,"For the non-C programmers reading this, a ",(0,r.kt)("inlineCode",{parentName:"p"},"union")," is like a ",(0,r.kt)("inlineCode",{parentName:"p"},"struct"),", but each field in the union occupies the same memory. Only one of the fields is ever correct to access at a time, depending on what is stored in the union. This example, for instance, will be four bytes long and holds either a ",(0,r.kt)("inlineCode",{parentName:"p"},"u32")," or an ",(0,r.kt)("inlineCode",{parentName:"p"},"f32"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[repr(C)]\nunion MyUnion {\n    f1: u32,\n    f2: f32,\n}\n")),(0,r.kt)("p",null,"Rust has no idea what's stored in this union, and you'll get back a ",(0,r.kt)("inlineCode",{parentName:"p"},"u32")," or an ",(0,r.kt)("inlineCode",{parentName:"p"},"f32")," depending on which one you access, but odds are only one of them contains a meaningful value. You can learn more about unions in ",(0,r.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/stable/reference/items/unions.html"},"the Rust Reference"),"."),(0,r.kt)("h2",{id:"soundness"},"Soundness"),(0,r.kt)("p",null,"This is an example of an unsafe function, taken from ",(0,r.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/nomicon/working-with-unsafe.html"},"the Rustonomicon"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"fn index(idx: usize, arr: &[u8]) -> Option<u8> {\n    if idx < arr.len() {\n        unsafe {\n            Some(*arr.get_unchecked(idx))\n        }\n    } else {\n        None\n    }\n}\n")),(0,r.kt)("p",null,"This uses unsafe code, but it checks the bounds of the array before calling into ",(0,r.kt)("inlineCode",{parentName:"p"},"get_unchecked"),", so we can prove this function is ",(0,r.kt)("em",{parentName:"p"},"sound")," (it can't cause undefined behavior).  Note that if you change the first line of this function to ",(0,r.kt)("inlineCode",{parentName:"p"},"if idx <= arr.len()")," the function becomes unsound, even though we didn't modify any unsafe code!"),(0,r.kt)("h2",{id:"verifying-unsafe-code-with-miri"},"Verifying unsafe code with Miri"),(0,r.kt)("p",null,"TODO: Add section here about using ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/rust-lang/miri"},"Miri")," to test unsafe code.  The ",(0,r.kt)("a",{parentName:"p",href:"https://play.rust-lang.org/?version=stable&mode=debug&edition=2021"},"Rust Playground"),' has a "Run with Miri" under "Tools" in the upper right corner, which is handy for checking a function.'))}p.isMDXComponent=!0}}]);