"use strict";(self.webpackChunkrust_book_abridged=self.webpackChunkrust_book_abridged||[]).push([[482],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),d=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(l.Provider,{value:t},e.children)},h="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),h=d(n),u=r,m=h["".concat(l,".").concat(u)]||h[u]||c[u]||i;return n?a.createElement(m,o(o({ref:t},p),{},{components:n})):a.createElement(m,o({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[h]="string"==typeof e?e:r,o[1]=s;for(var d=2;d<i;d++)o[d]=n[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},17:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>d});var a=n(7462),r=(n(7294),n(3905));const i={},o="16 - Fearless Concurrency",s={unversionedId:"ch16-fearless-concurrency",id:"ch16-fearless-concurrency",title:"16 - Fearless Concurrency",description:"Concurrent programming has a lot of potential pit falls - race conditions, thread safe access to variables - in other languages these problems show up in production as tricky to reproduce problems. Access to memory is handled through Rust's type system and ownership rules, and it turns out these rules can do an excellent job of catching many concurrency problems at compile time too.",source:"@site/docs/ch16-fearless-concurrency.md",sourceDirName:".",slug:"/ch16-fearless-concurrency",permalink:"/rust-book-abridged/ch16-fearless-concurrency",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ch16-fearless-concurrency.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"15 - Smart Pointers",permalink:"/rust-book-abridged/ch15-smart-pointers"},next:{title:"17 - Object Oriented Features of Rust",permalink:"/rust-book-abridged/ch17-object-oriented-features"}},l={},d=[{value:"Threads for JavaScript Programmers",id:"threads-for-javascript-programmers",level:2},{value:"16.1 - Using Threads to Run Code Simultaneously",id:"161---using-threads-to-run-code-simultaneously",level:2},{value:"Creating a New Thread with <code>spawn</code>",id:"creating-a-new-thread-with-spawn",level:3},{value:"Using <code>move</code> Closures with Threads",id:"using-move-closures-with-threads",level:3},{value:"Scoped Threads",id:"scoped-threads",level:3},{value:"16.2 - Using Message Passing to Transfer Data Between Threads",id:"162---using-message-passing-to-transfer-data-between-threads",level:2},{value:"Sending Multiple Values and Seeing the Receiver Waiting",id:"sending-multiple-values-and-seeing-the-receiver-waiting",level:3},{value:"16.3 - Shared-State Concurrency",id:"163---shared-state-concurrency",level:2},{value:"Using Mutexes to Allow Access to Data from One Thread at a Time",id:"using-mutexes-to-allow-access-to-data-from-one-thread-at-a-time",level:3},{value:"Sharing a <code>Mutex&lt;T&gt;</code> Between Multiple Threads",id:"sharing-a-mutext-between-multiple-threads",level:3},{value:"16.4 - Extensible Concurrency with the <code>Sync</code> and <code>Send</code> traits",id:"164---extensible-concurrency-with-the-sync-and-send-traits",level:2}],p={toc:d},h="wrapper";function c(e){let{components:t,...n}=e;return(0,r.kt)(h,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"16---fearless-concurrency"},"16 - Fearless Concurrency"),(0,r.kt)("p",null,"Concurrent programming has a lot of potential pit falls - race conditions, thread safe access to variables - in other languages these problems show up in production as tricky to reproduce problems. Access to memory is handled through Rust's type system and ownership rules, and it turns out these rules can do an excellent job of catching many concurrency problems at compile time too."),(0,r.kt)("p",null,"Throughout this chapter we'll use the term ",(0,r.kt)("em",{parentName:"p"},"concurrent"),", but we really mean ",(0,r.kt)("em",{parentName:"p"},"concurrent or parallel")," (concurrent meaning multiple things happening on a single CPU, and parallel meaning multiple things happening on many CPUs). A lot of what we discuss in this chapter applies to both multithreaded code and async code. We'll talk a little bit about async code in ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch21-async",title:"Chapter 21: Bonus Chapter: Async Programming"},"chapter 21"),"."),(0,r.kt)("p",null,"Different languages tend to use different abstractions to deal with thread safety, each with their own strengths and weaknesses. For example, Java makes use of ",(0,r.kt)("inlineCode",{parentName:"p"},"synchronized")," blocks which take ownership of a monitor (very similar to a mutex), and your most frequent headaches in Java are deadlocks. In Go, concurrency is most frequently handled using message passing over a channel, and while deadlocks are thus rare in Go, goroutine leaks (where a goroutine is started but never terminates) are frighteningly common. Rust doesn't dictate a solution to you: Rust has both channels and mutexes and you can use whichever is a better fit for your particular problem."),(0,r.kt)("h2",{id:"threads-for-javascript-programmers"},"Threads for JavaScript Programmers"),(0,r.kt)("p",null,'This book is intended to people who already know another language, and so we\'re skipping a lot of beginner concepts. However, JavaScript is one of the most popular languages in the world, and it doesn\'t deal much with threads, so we\'ll briefly cover some thread concepts here. If you know what "thread" and "mutex" mean, feel free to skip ahead to the next section. If not, this is far from a complete introduction to threads, but it will at least introduce the terminology you need to make it through this chapter.'),(0,r.kt)("p",null,"If you've used JavaScript much, you know that JavaScript has an event loop. In node.js, if you call ",(0,r.kt)("inlineCode",{parentName:"p"},'fs.readFile(filename, {encoding: "utf-8"},  cb)'),", then node will ask the OS to open ",(0,r.kt)("inlineCode",{parentName:"p"},"filename")," and read it's contents, and once that data is available node will call into your callback. The actual reading of the file may or may not happen in some other thread, but your code all executes in a single thread, inside the event loop. Because of this, a calculation-heavy JavaScript program has a hard time making use of multiple CPUs. We say that JavaScript code can do a lot of things ",(0,r.kt)("em",{parentName:"p"},"concurrently"),", but not so much in ",(0,r.kt)("em",{parentName:"p"},"parallel"),". (At least, without using ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers"},"web workers"),".)"),(0,r.kt)("p",null,"You probably already know that spawning a ",(0,r.kt)("em",{parentName:"p"},"thread")," is a bit like starting a second program running. You can run two threads in parallel on two different CPUs. The biggest difference between running two separate programs and running two threads is that the threads can read and write the same memory."),(0,r.kt)("p",null,"When two threads want to read and write to the same memory, we need some way to synchronize access to that memory. If one thread is writing part of a data structure while another is reading it, then the reader might get a partially updated data structure, or one with pointers to data that has been allocated but hasn't been initialized yet. These introduce bugs in our program called ",(0,r.kt)("em",{parentName:"p"},"race conditions"),"."),(0,r.kt)("p",null,"One of the most common ways to synchronize access is called a ",(0,r.kt)("em",{parentName:"p"},"mutex"),' (short for "mutual exclusion"). Whenever a thread wants to read or write to shared memory, it ',(0,r.kt)("em",{parentName:"p"},"locks")," the mutex. Only one thread is allowed to own the lock on the mutex at a time, so if a second thread tries to lock the mutex, it will block until the mutex is available."),(0,r.kt)("p",null,"Sometimes a thread needs to access two different parts of memory, protected by two different mutexes. If a first thread tries to lock mutex ",(0,r.kt)("inlineCode",{parentName:"p"},"a")," and then mutex ",(0,r.kt)("inlineCode",{parentName:"p"},"b"),", and a second thread tries to lock mutex ",(0,r.kt)("inlineCode",{parentName:"p"},"b")," and then mutex ",(0,r.kt)("inlineCode",{parentName:"p"},"a"),", it's possible that the first thread will end up with ",(0,r.kt)("inlineCode",{parentName:"p"},"a")," and get stuck waiting for ",(0,r.kt)("inlineCode",{parentName:"p"},"b"),", while the second thread ends up with ",(0,r.kt)("inlineCode",{parentName:"p"},"b")," and waits for ",(0,r.kt)("inlineCode",{parentName:"p"},"a"),". This is called a ",(0,r.kt)("em",{parentName:"p"},"deadlock")," and both threads will end up waiting forever."),(0,r.kt)("p",null,"In this chapter we're going to talk about how to spawn threads, how to use mutexes to synchronize access, and we'll talk about channels which are a way for threads to pass messages back and forth to each other (if you are familiar with web workers, this is a little bit like ",(0,r.kt)("inlineCode",{parentName:"p"},"postMessage"),")."),(0,r.kt)("h2",{id:"161---using-threads-to-run-code-simultaneously"},"16.1 - Using Threads to Run Code Simultaneously"),(0,r.kt)("p",null,"If you're coming from a language like Go or Erlang, it's important to realize that threads in Rust are real, actual, OS level threads. In Go, ",(0,r.kt)("em",{parentName:"p"},"goroutines"),' are "green threads", where multiple goroutines map to a single OS thread. In Rust, each thread is bare metal OS thread (although, it\'s worth noting that there are crates that implement other models of threading).'),(0,r.kt)("p",null,"In ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch21-async",title:"Chapter 21: Bonus Chapter: Async Programming"},"chapter 21")," we'll talk about async programming where many I/O bound tasks (like many incoming requests to a web server) can be handled in parallel with a small number of threads, but in this chapter we're talking about plain old vanilla threads."),(0,r.kt)("h3",{id:"creating-a-new-thread-with-spawn"},"Creating a New Thread with ",(0,r.kt)("inlineCode",{parentName:"h3"},"spawn")),(0,r.kt)("p",null,"We start a new thread by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"thread::spawn"),", passing it a closure which will be run in the new thread:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},'use std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let handle = thread::spawn(|| {\n        for i in 1..10 {\n            println!("hi number {} from the spawned thread!", i);\n            thread::sleep(Duration::from_millis(1));\n        }\n    });\n\n    for i in 1..5 {\n        println!("hi number {} from the main thread!", i);\n        thread::sleep(Duration::from_millis(1));\n    }\n\n    handle.join().unwrap();\n}\n')),(0,r.kt)("p",null,"If you run this, then as you'd expect, you'll get a mix of messages from the main thread and the spawned thread intermixed with each other."),(0,r.kt)("p",null,"If you comment out the call to ",(0,r.kt)("inlineCode",{parentName:"p"},"join")," at the end of the ",(0,r.kt)("inlineCode",{parentName:"p"},"main")," function and run this, you probably will not see all 9 numbers from the spawned thread being printed. If the main thread quits, all child threads quit immediately. Rust doesn't wait for all threads to finish to quit the program, as some languages such as Java do. The ",(0,r.kt)("inlineCode",{parentName:"p"},"join")," function on ",(0,r.kt)("inlineCode",{parentName:"p"},"ThreadHandle")," will cause the calling thread to wait until the thread the handle references has terminated."),(0,r.kt)("h3",{id:"using-move-closures-with-threads"},"Using ",(0,r.kt)("inlineCode",{parentName:"h3"},"move")," Closures with Threads"),(0,r.kt)("p",null,"Here's an example that doesn't compile because of an ownership problem:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},"use std::thread;\n\nfn main() {\n    let v = vec![1, 2, 3];\n\n    // This doesn't work!\n    let handle = thread::spawn(|| {\n        println!(\"Here's a vector: {:?}\", v);\n    });\n\n    drop(v);\n\n    handle.join().unwrap();\n}\n")),(0,r.kt)("p",null,"Can you spot the problem? If you need a hint, notice that ",(0,r.kt)("inlineCode",{parentName:"p"},"v")," gets declared in the ",(0,r.kt)("inlineCode",{parentName:"p"},"main")," function, and we reference ",(0,r.kt)("inlineCode",{parentName:"p"},"v")," inside the closure. As you might recall from ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch13-functional-language-features",title:"Chapter 13: Functional Language Features: Iterators and Closures"},"chapter 13"),", Rust is going to infer that, since we're only reading from ",(0,r.kt)("inlineCode",{parentName:"p"},"v")," inside the closure, we can borrow a reference to ",(0,r.kt)("inlineCode",{parentName:"p"},"v"),"."),(0,r.kt)("p",null,"The problem here is that immediately after spawning the thread, the ",(0,r.kt)("inlineCode",{parentName:"p"},"main")," function drops ",(0,r.kt)("inlineCode",{parentName:"p"},"v"),". This means the memory associated with the vector is going to be freed, possibly before the thread has even had a chance to run. The Rust compiler throws an error here, because the thread might not have a valid reference to ",(0,r.kt)("inlineCode",{parentName:"p"},"v")," when it needs it. There's no way for the compiler to know."),(0,r.kt)("p",null,"More formally, from a type safety perspective, the closure passed to ",(0,r.kt)("inlineCode",{parentName:"p"},"thread::spawn")," has the trait bounds ",(0,r.kt)("inlineCode",{parentName:"p"},"F: FnOnce() -> T + Send + 'static"),". The closure has a static lifetime, which may or may not overlap the lifetime of the vector, so the closure can't borrow from the vector."),(0,r.kt)("p",null,"One way to fix this is with the ",(0,r.kt)("inlineCode",{parentName:"p"},"move")," keyword, which forces the closure to take ownership of ",(0,r.kt)("inlineCode",{parentName:"p"},"v"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'    let handle = thread::spawn(move || {\n        println!("Here\'s a vector: {:?}", v);\n    });\n\n')),(0,r.kt)("h3",{id:"scoped-threads"},"Scoped Threads"),(0,r.kt)("p",null,"Another way to solve the example above is with ",(0,r.kt)("inlineCode",{parentName:"p"},"thread::scope"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},'use std::thread;\n\nfn main() {\n    let v = vec![1, 2, 3];\n    let mut i = 32;\n\n    let scope = thread::scope(|s| {\n        s.spawn(|| {\n            // Can borrow from the outer scope.\n            println!("Here\'s a vector: {:?}", v);\n        });\n\n        s.spawn(|| {\n            // Can even mutably borrow, so long as\n            // no other threads borrow same variable.\n            i = 7;\n        });\n    });\n}\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"thread::scope")," passes a ",(0,r.kt)("inlineCode",{parentName:"p"},"Scope")," object to the passed in closure, which can be used to spawn new threads. All threads spawned this way are joined before ",(0,r.kt)("inlineCode",{parentName:"p"},"thread::scope")," returns, so their lifetime is known. These threads can therefore borrow from the enclosing function. If any individual thread panics, then ",(0,r.kt)("inlineCode",{parentName:"p"},"thread::scope")," will panic as well."),(0,r.kt)("h2",{id:"162---using-message-passing-to-transfer-data-between-threads"},"16.2 - Using Message Passing to Transfer Data Between Threads"),(0,r.kt)("p",null,"Rust has ",(0,r.kt)("em",{parentName:"p"},"channels"),", which will be very familiar to any Go programmers reading this. A channel is a bit like a FIFO queue - a producer can ",(0,r.kt)("em",{parentName:"p"},"transmit")," a message to the channel, and a consumer can ",(0,r.kt)("em",{parentName:"p"},"receive")," a message from a channel. Let's see an example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},'use std::sync::mpsc;\nuse std::thread;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let val = String::from("hi");\n        tx.send(val).unwrap();\n    });\n\n    let received = rx.recv().unwrap();\n    println!("Got: {}", received);\n}\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"mpsc"),' here stands for "multiple producers, single consumer", because this is how the channels from the standard library are implemented. The call to ',(0,r.kt)("inlineCode",{parentName:"p"},"mpsc::channel")," returns a ",(0,r.kt)("inlineCode",{parentName:"p"},"Sender<String>")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Receiver<String>")," in a tuple, which we're assigning to ",(0,r.kt)("inlineCode",{parentName:"p"},"tx")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"rx")," via a destructuring assignment."),(0,r.kt)("p",null,"As we saw in previous examples, we use ",(0,r.kt)("inlineCode",{parentName:"p"},"move")," to move ownership of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Sender")," to the spawned thread. The thread needs to own the ",(0,r.kt)("inlineCode",{parentName:"p"},"Sender")," in order to use it, which it does by calling ",(0,r.kt)("inlineCode",{parentName:"p"},"tx.send"),". It's important to realize that ",(0,r.kt)("inlineCode",{parentName:"p"},"send")," doesn't make a copy of the message being passed in, it takes ownership of the value and moves it to the receiving side. In effect the only thing being sent from sender to receiver is a pointer."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"send")," will return an error if the receiver has already been dropped and there's nowhere to send this message. Here we're calling ",(0,r.kt)("inlineCode",{parentName:"p"},"unwrap")," instead of properly handling the error since this is just an example."),(0,r.kt)("p",null,"On the receiving side, we call ",(0,r.kt)("inlineCode",{parentName:"p"},"rx.recv")," to receive a value from the channel. This will block until a message is available. Like ",(0,r.kt)("inlineCode",{parentName:"p"},"send"),", this will return an error if the transmitter has already been dropped (otherwise we could end up blocked waiting for a message forever). If we don't want the receiver to block, there's also a ",(0,r.kt)("inlineCode",{parentName:"p"},"rx.try_recv")," which will return an error immediately if the channel has no messages for us. It's a fairly common pattern for the main thread to periodically check to see if there are messages available, and if not go do some other work and come back later."),(0,r.kt)("h3",{id:"sending-multiple-values-and-seeing-the-receiver-waiting"},"Sending Multiple Values and Seeing the Receiver Waiting"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Receiver<T>")," type implements the ",(0,r.kt)("inlineCode",{parentName:"p"},"Iterator")," trait, which lets us handle incoming messages with a ",(0,r.kt)("inlineCode",{parentName:"p"},"for")," loop or using other ",(0,r.kt)("inlineCode",{parentName:"p"},"Iterator")," functions we've seen:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},'use std::sync::mpsc;\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let vals = vec![\n            String::from("hi"),\n            String::from("from"),\n            String::from("the"),\n            String::from("thread"),\n        ];\n\n        for val in vals {\n            tx.send(val).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n\n    for received in rx {\n        println!("Got: {}", received);\n    }\n}\n')),(0,r.kt)("p",null,"Notice that the sending thread is sleeping between sending each value. The ",(0,r.kt)("inlineCode",{parentName:"p"},"for received in rx")," loop here will call ",(0,r.kt)("inlineCode",{parentName:"p"},"recv"),", so it will block and wait for each message."),(0,r.kt)("h2",{id:"163---shared-state-concurrency"},"16.3 - Shared-State Concurrency"),(0,r.kt)("h3",{id:"using-mutexes-to-allow-access-to-data-from-one-thread-at-a-time"},"Using Mutexes to Allow Access to Data from One Thread at a Time"),(0,r.kt)("p",null,"First let's have a look at a single threaded program that uses a ",(0,r.kt)("inlineCode",{parentName:"p"},"Mutex<T>"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},'use std::sync::Mutex;\n\nfn main() {\n    let m = Mutex::new(5);\n\n    {\n        let mut num = m.lock().unwrap();\n        *num = 6;\n    }\n\n    println!("m = {:?}", m);\n}\n')),(0,r.kt)("p",null,"We acquire the lock with ",(0,r.kt)("inlineCode",{parentName:"p"},"m.lock().unwrap()"),". If you're wondering what that ",(0,r.kt)("inlineCode",{parentName:"p"},"unwrap")," is about: if a thread panics which it holds the mutex, then Rust marks this mutex as being ",(0,r.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/std/sync/struct.Mutex.html#poisoning"},"poisoned"),". The call to ",(0,r.kt)("inlineCode",{parentName:"p"},"lock")," actually returns a ",(0,r.kt)("inlineCode",{parentName:"p"},"LockResult<T>")," which, in the case of a poisoned mutex, will be an ",(0,r.kt)("inlineCode",{parentName:"p"},"Err"),". Generally here you would just call ",(0,r.kt)("inlineCode",{parentName:"p"},"unwrap")," as we have done above, which would propagate the panic since, after a panic, you will have a hard time guaranteeing that anything is in a reasonable state. However you can ",(0,r.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/std/sync/struct.PoisonError.html#method.into_inner"},"acquire the lock from the poisoned mutex")," if you wish."),(0,r.kt)("p",null,"After we ",(0,r.kt)("inlineCode",{parentName:"p"},"unwrap")," the ",(0,r.kt)("inlineCode",{parentName:"p"},"LockResult"),", the ",(0,r.kt)("inlineCode",{parentName:"p"},"num")," value here is bound to a ",(0,r.kt)("inlineCode",{parentName:"p"},"MutexGuard"),". When the ",(0,r.kt)("inlineCode",{parentName:"p"},"MutexGuard")," is dropped at the end of our inner scope, the mutex's lock will be released."),(0,r.kt)("p",null,"You'll notice that the mutex holds on to the value it's protecting inside of itself. ",(0,r.kt)("inlineCode",{parentName:"p"},"Mutex<T>")," is basically another kind of smart pointer, or more accurately the ",(0,r.kt)("inlineCode",{parentName:"p"},"MutexGuard")," is. ",(0,r.kt)("inlineCode",{parentName:"p"},"MutexGuard")," implements ",(0,r.kt)("inlineCode",{parentName:"p"},"Deref")," so we can use it like a reference to update the value inside."),(0,r.kt)("p",null,"Mutexes in rust are ",(0,r.kt)("em",{parentName:"p"},"not")," reentrant - if you hold a lock and try to acquire it a second time, this will result in a deadlock. Rust's fancy type and ownership system can protect us from many common thread safety issues, but deadlocks aren't one of them, and trying to acquire the two locks from two threads in a different order will also result in a deadlock."),(0,r.kt)("h3",{id:"sharing-a-mutext-between-multiple-threads"},"Sharing a ",(0,r.kt)("inlineCode",{parentName:"h3"},"Mutex<T>")," Between Multiple Threads"),(0,r.kt)("p",null,"A Mutex on only one thread isn't very useful. If you recall back to how we shared a single ",(0,r.kt)("inlineCode",{parentName:"p"},"Sender")," between multiple threads in our channels example, you might expect us to clone the mutex to pass it between multiple threads, but you'd be wrong - ",(0,r.kt)("inlineCode",{parentName:"p"},"Mutex<T>")," doesn't implement ",(0,r.kt)("inlineCode",{parentName:"p"},"Clone"),". We saw in ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch15-smart-pointers",title:"Chapter 15: Smart Pointers"},"chapter 15")," how we could use the ",(0,r.kt)("inlineCode",{parentName:"p"},"Rc<T>")," smart pointer to have a single piece of data with multiple owners, but we noted it isn't thread safe, so we can't use it here."),(0,r.kt)("p",null,"But there's a thread-safe version of ",(0,r.kt)("inlineCode",{parentName:"p"},"Rc<T>")," called ",(0,r.kt)("inlineCode",{parentName:"p"},"Arc<T>"),' - the "atomic reference counted" smart pointer. ',(0,r.kt)("inlineCode",{parentName:"p"},"Arc<T>")," uses the ",(0,r.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/stable/std/sync/atomic/index.html"},"std::sync::atomic")," library to atomically increment and decrement it's reference count, which makes it thread safe. Why doesn't ",(0,r.kt)("inlineCode",{parentName:"p"},"Rc<T>")," use the atomic library? How come everything isn't thread safe? Because thread safety comes with a performance penalty here, so ",(0,r.kt)("inlineCode",{parentName:"p"},"Rc<T>")," is there when you don't need thread safety and ",(0,r.kt)("inlineCode",{parentName:"p"},"Arc<T>")," is there for when you do."),(0,r.kt)("p",null,"Here's how we share a ",(0,r.kt)("inlineCode",{parentName:"p"},"Mutex<T>")," with an ",(0,r.kt)("inlineCode",{parentName:"p"},"Arc<T>"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},'use std::sync::{Arc, Mutex};\nuse std::thread;\n\nfn main() {\n    let counter = Arc::new(Mutex::new(0));\n    let mut handles = vec![];\n\n    for _ in 0..10 {\n        let counter = Arc::clone(&counter);\n        let handle = thread::spawn(move || {\n            let mut num = counter.lock().unwrap();\n\n            *num += 1;\n        });\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    println!("Result: {}", *counter.lock().unwrap());\n}\n')),(0,r.kt)("p",null,"Very similar to our channels example, we ",(0,r.kt)("inlineCode",{parentName:"p"},"clone")," the ",(0,r.kt)("inlineCode",{parentName:"p"},"Arc")," whenever we want to ",(0,r.kt)("inlineCode",{parentName:"p"},"move")," it into a new thread (so you were right - there was a clone in there somewhere). Note that we're still not cloning the ",(0,r.kt)("inlineCode",{parentName:"p"},"Mutex<T>")," though. The ",(0,r.kt)("inlineCode",{parentName:"p"},"Arc")," keeps ownership of the Mutex, allowing us to share a single mutex across multiple threads."),(0,r.kt)("p",null,"Notice that the ",(0,r.kt)("inlineCode",{parentName:"p"},"counter")," variable above is declared as immutable. Much like with ",(0,r.kt)("inlineCode",{parentName:"p"},"RefCell<T>"),", a ",(0,r.kt)("inlineCode",{parentName:"p"},"Mutex<T>")," provides interior mutability, and we're allowed to change the value held in a mutex even if we have an immutable reference to the mutex."),(0,r.kt)("h2",{id:"164---extensible-concurrency-with-the-sync-and-send-traits"},"16.4 - Extensible Concurrency with the ",(0,r.kt)("inlineCode",{parentName:"h2"},"Sync")," and ",(0,r.kt)("inlineCode",{parentName:"h2"},"Send")," traits"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Send")," is a marker trait that indicates a type can be transferred between threads. Any type composed entirely of ",(0,r.kt)("inlineCode",{parentName:"p"},"Send")," traits is automatically ",(0,r.kt)("inlineCode",{parentName:"p"},"Send"),". Almost every type in Rust is ",(0,r.kt)("inlineCode",{parentName:"p"},"Send"),", but we've already seen an example of one that isn't: ",(0,r.kt)("inlineCode",{parentName:"p"},"Rc<T>")," isn't ",(0,r.kt)("inlineCode",{parentName:"p"},"Send"),", since if you cloned it and transferred it between threads, the clone and the original might try to modify the reference count concurrently resulting in a data race. If you give this a try, you'll get a compile-time error, since ",(0,r.kt)("inlineCode",{parentName:"p"},"Rc<T>")," is not ",(0,r.kt)("inlineCode",{parentName:"p"},"Send"),". Raw pointers in rust (see ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch19/ch19-01-unsafe",title:"Chapter 19: Advanced Features"},"chapter 19"),") are also not ",(0,r.kt)("inlineCode",{parentName:"p"},"Send"),"."),(0,r.kt)("p",null,"The closely related ",(0,r.kt)("inlineCode",{parentName:"p"},"Sync")," marker trait is implemented by types that are safe to be referenced from multiple threads. To put it formally, a type ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"Sync")," if ",(0,r.kt)("inlineCode",{parentName:"p"},"&T")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"Send"),". If we can send an immutable reference to ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," to another thread, then ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"Sync"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"RefCell<T>")," is not ",(0,r.kt)("inlineCode",{parentName:"p"},"Sync"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"Mutex<T>")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"Sync")," which is why we can share an immutable reference across threads, as we did with ",(0,r.kt)("inlineCode",{parentName:"p"},"Arc<T>")," in the example above."),(0,r.kt)("p",null,"In general we never have to implement ",(0,r.kt)("inlineCode",{parentName:"p"},"Send")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Sync")," on a type ourselves. They are just marker traits with no methods, and they're implemented automatically on a type if that type is composed entirely of ",(0,r.kt)("inlineCode",{parentName:"p"},"Send"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"Sync")," members. The only cases where you'd want to implement these yourself is if you're creating new concurrency primitives, in which case you'll be using some ",(0,r.kt)("em",{parentName:"p"},"unsafe")," code (see ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch19/ch19-01-unsafe",title:"Chapter 19: Advanced Features"},"chapter 19"),"). There are many safety guarantees you'll have to implement yourself if you're going down this path, and you should consult ",(0,r.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/stable/nomicon"},"The Rustonomicon")," if you want to learn about this."),(0,r.kt)("p",null,"What's interesting to note here is that, aside from the ",(0,r.kt)("inlineCode",{parentName:"p"},"Sync")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Send")," traits, everything we've looked at in this chapter is implemented in the standard library instead of being part of the core Rust language. Many concurrency solutions are implemented in crates (such as the popular ",(0,r.kt)("a",{parentName:"p",href:"https://crates.io/crates/parking_lot"},"parking_lot crate"),"). When we dig into async programming in ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch21-async",title:"Chapter 21: Bonus Chapter: Async Programming"},"chapter 21")," we'll see the same thing there, with Rust providing the ",(0,r.kt)("inlineCode",{parentName:"p"},"async")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"await")," keywords, but with the actual runtime behavior being provided by a crate."),(0,r.kt)("p",null,"Continue to ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch17-object-oriented-features",title:"Chapter 17: Object Oriented Features of Rust"},"chapter 17"),"."))}c.isMDXComponent=!0}}]);