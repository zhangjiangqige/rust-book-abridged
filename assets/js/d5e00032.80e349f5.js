"use strict";(self.webpackChunkrust_book_abridged=self.webpackChunkrust_book_abridged||[]).push([[455],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>d});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},c="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=u(n),m=r,d=c["".concat(s,".").concat(m)]||c[m]||h[m]||o;return n?a.createElement(d,i(i({ref:t},p),{},{components:n})):a.createElement(d,i({ref:t},p))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[c]="string"==typeof e?e:r,i[1]=l;for(var u=2;u<o;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},9850:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>l,toc:()=>u});var a=n(7462),r=(n(7294),n(3905));const o={},i="13 - Functional Language Features: Iterators and Closures",l={unversionedId:"ch13-functional-language-features",id:"ch13-functional-language-features",title:"13 - Functional Language Features: Iterators and Closures",description:"In this chapter we will cover closures, which are a like functions you can assign to variables or pass around as parameters. We'll also learn about iterators which are used for iterating over a collection of items.",source:"@site/docs/ch13-functional-language-features.md",sourceDirName:".",slug:"/ch13-functional-language-features",permalink:"/rust-book-abridged/ch13-functional-language-features",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ch13-functional-language-features.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"12 - An I/O Project: Building a Command Line Program",permalink:"/rust-book-abridged/ch12-io-project-cli"},next:{title:"14 - More about Cargo and Crates",permalink:"/rust-book-abridged/ch14-more-about-cargo"}},s={},u=[{value:"13.1 - Closures: Anonymous Functions that Capture Their Environment",id:"131---closures-anonymous-functions-that-capture-their-environment",level:2},{value:"Capturing the Environment with Closures",id:"capturing-the-environment-with-closures",level:3},{value:"Closure Type Inference and Annotation",id:"closure-type-inference-and-annotation",level:3},{value:"Capturing References or Moving Ownership",id:"capturing-references-or-moving-ownership",level:3},{value:"Moving Captured Values Out of Closures and the Fn Traits",id:"moving-captured-values-out-of-closures-and-the-fn-traits",level:3},{value:"13.2 - Processing a Series of Items with Iterators",id:"132---processing-a-series-of-items-with-iterators",level:2},{value:"The <code>Iterator</code> Trait and the <code>next</code> Method",id:"the-iterator-trait-and-the-next-method",level:3},{value:"Methods that Consume the Iterator",id:"methods-that-consume-the-iterator",level:3},{value:"Methods that Produce Other Iterators",id:"methods-that-produce-other-iterators",level:3},{value:"Using Closures that Capture Their Environment",id:"using-closures-that-capture-their-environment",level:3},{value:"13.3 - Improving our I/O Project",id:"133---improving-our-io-project",level:2},{value:"Removing a <code>clone</code> Using an Iterator",id:"removing-a-clone-using-an-iterator",level:3},{value:"Making Code Clearer with Iterator Adaptors",id:"making-code-clearer-with-iterator-adaptors",level:3},{value:"Choosing Between Loops or Iterators",id:"choosing-between-loops-or-iterators",level:3},{value:"13.4 Comparing Performance: Loops vs. Iterators",id:"134-comparing-performance-loops-vs-iterators",level:2}],p={toc:u},c="wrapper";function h(e){let{components:t,...n}=e;return(0,r.kt)(c,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"13---functional-language-features-iterators-and-closures"},"13 - Functional Language Features: Iterators and Closures"),(0,r.kt)("p",null,"In this chapter we will cover ",(0,r.kt)("em",{parentName:"p"},"closures"),", which are a like functions you can assign to variables or pass around as parameters. We'll also learn about ",(0,r.kt)("em",{parentName:"p"},"iterators")," which are used for iterating over a collection of items."),(0,r.kt)("h2",{id:"131---closures-anonymous-functions-that-capture-their-environment"},"13.1 - Closures: Anonymous Functions that Capture Their Environment"),(0,r.kt)("p",null,"A closure is essentially a function that can access variables in the enclosing scope. You can store a closure in a variable or pass it as a parameter.If you're a JavaScript programmer, you're no doubt very familiar with closures."),(0,r.kt)("h3",{id:"capturing-the-environment-with-closures"},"Capturing the Environment with Closures"),(0,r.kt)("p",null,"Here's the scenario that we're going to use for this section, taken directly from the original \"The Rust Programming Language\": Every so often, our t-shirt company gives away an exclusive, limited-edition shirt to someone on our mailing list as a promotion. People on the mailing list can optionally add their favorite color to their profile. If the person chosen for a free shirt has their favorite color set, they get that color shirt. If the person hasn't specified a favorite color, they get whatever color the company currently has the most of."),(0,r.kt)("p",null,"We'll implement this using an ",(0,r.kt)("inlineCode",{parentName:"p"},"enum ShirtColor")," for the color of the shirt, and we'll use a ",(0,r.kt)("inlineCode",{parentName:"p"},"Vec<ShirtColor>")," to represent stock - each item in the vector represents a t-shirt. We'll define a ",(0,r.kt)("inlineCode",{parentName:"p"},"giveaway")," method on ",(0,r.kt)("inlineCode",{parentName:"p"},"Inventory")," to figure out which shirt to give a customer:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},'#[derive(Debug, PartialEq, Copy, Clone)]\nenum ShirtColor {\n    Red,\n    Blue,\n}\n\nstruct Inventory {\n    // A vector of shirt colors, one for each shirt we have in stock.\n    shirts: Vec<ShirtColor>,\n}\n\nimpl Inventory {\n    /// Figure out what color of shirt to give away.\n    fn giveaway(&self, user_preference: Option<ShirtColor>) -> ShirtColor {\n        user_preference.unwrap_or_else(|| self.most_stocked())\n    }\n\n    // Figure out what shirt color we have the most of in inventory.\n    fn most_stocked(&self) -> ShirtColor {\n        let mut num_red = 0;\n        let mut num_blue = 0;\n\n        for color in &self.shirts {\n            match color {\n                ShirtColor::Red => num_red += 1,\n                ShirtColor::Blue => num_blue += 1,\n            }\n        }\n        if num_red > num_blue {\n            ShirtColor::Red\n        } else {\n            ShirtColor::Blue\n        }\n    }\n}\n\nfn main() {\n    let store = Inventory {\n        shirts: vec![ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue],\n    };\n\n    let user_pref1 = Some(ShirtColor::Red);\n    let giveaway1 = store.giveaway(user_pref1);\n    println!(\n        "The user with preference {:?} gets {:?}",\n        user_pref1, giveaway1\n    );\n\n    let user_pref2 = None;\n    let giveaway2 = store.giveaway(user_pref2);\n    println!(\n        "The user with preference {:?} gets {:?}",\n        user_pref2, giveaway2\n    );\n}\n')),(0,r.kt)("p",null,"Everything here should be familiar. The part we want to focus on is the ",(0,r.kt)("inlineCode",{parentName:"p"},"giveaway")," method, specifically this line:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"user_preference.unwrap_or_else(|| self.most_stocked())\n")),(0,r.kt)("p",null,"We're calling ",(0,r.kt)("inlineCode",{parentName:"p"},"unwrap_or_else")," on an ",(0,r.kt)("inlineCode",{parentName:"p"},"Option<ShirtColor>"),". If the ",(0,r.kt)("inlineCode",{parentName:"p"},"Option")," is the ",(0,r.kt)("inlineCode",{parentName:"p"},"Some")," variant, this will unwrap the value and return it, just like ",(0,r.kt)("inlineCode",{parentName:"p"},"unwrap"),". But if it's ",(0,r.kt)("inlineCode",{parentName:"p"},"None"),", this will call into the closure we pass as the first parameter: ",(0,r.kt)("inlineCode",{parentName:"p"},"|| self.most_stocked()"),". This closure is a tiny function that takes no parameters (if there were some, they'd appear between the ",(0,r.kt)("inlineCode",{parentName:"p"},"||"),") and returns the result of ",(0,r.kt)("inlineCode",{parentName:"p"},"self.most_stocked()"),". Notice that the closure is using the ",(0,r.kt)("inlineCode",{parentName:"p"},"self")," variable, which isn't being passed explicitly as a parameter to the closure. This parameter is ",(0,r.kt)("em",{parentName:"p"},"captured")," from the outer scope."),(0,r.kt)("h3",{id:"closure-type-inference-and-annotation"},"Closure Type Inference and Annotation"),(0,r.kt)("p",null,"With functions, we always have to annotate the type of the function. With closures, generally we don't have to annotate the types, as Rust can usually infer the correct types from the function we're passing the closure to. We can annotate them the same way we do functions though:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let expensive_closure = |num: u32| -> u32 {\n    println!("calculating slowly...");\n    thread::sleep(Duration::from_secs(2));\n    num\n};\n')),(0,r.kt)("p",null,"Even if a closure is not annotated, it ",(0,r.kt)("em",{parentName:"p"},"does")," have concrete types. This example would fail to compile:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let example_closure = |x| x;\n\nlet s = example_closure(String::from("hello"));\nlet n = example_closure(5);\n')),(0,r.kt)("p",null,"If we were to call this with only a ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),", then rust would infer the type of ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," in the closure to be a ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),". Since we call it once with a ",(0,r.kt)("inlineCode",{parentName:"p"},"String")," and once with an ",(0,r.kt)("inlineCode",{parentName:"p"},"i32"),", Rust won't know which it should be and will generate a compiler error."),(0,r.kt)("h3",{id:"capturing-references-or-moving-ownership"},"Capturing References or Moving Ownership"),(0,r.kt)("p",null,"In JavaScript or Go, when a closure captures a value, this just counts as one more reference to the value for the garbage collector. Since Rust has no garbage collector, ownership rules apply to closures just like anywhere else. A closure can capture an immutable reference to a value, a mutable reference, or can take ownership of the value. Generally which of these happens is inferred by the compiler depending on what the closure does with the value."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},'fn immutable_example() {\n    let list = vec![1, 2, 3];\n    println!("Before defining closure: {:?}", list);\n\n    // Here `list` is captured as an immutable reference.\n    let only_borrows = || println!("From closure: {:?}", list);\n\n    println!("Before calling closure: {:?}", list);\n    only_borrows();\n    println!("After calling closure: {:?}", list);\n}\n\nfn mutable_example() {\n    let mut list = vec![1, 2, 3];\n    println!("Before defining closure: {:?}", list);\n\n    // Here `list` is captured as a mutable reference,\n    // since we `push` a new item onto the list.\n    let mut borrows_mutably = || list.push(7);\n\n    borrows_mutably();\n    println!("After calling closure: {:?}", list);\n}\n')),(0,r.kt)("p",null,"In ",(0,r.kt)("inlineCode",{parentName:"p"},"mutable_example"),", notice that we've declared the ",(0,r.kt)("inlineCode",{parentName:"p"},"borrows_mutably")," closure as mutable itself! If you think about a closure as an implicit data structure, containing data captured from the environment, then in order to mutate any values held in that structure we have to declare the owning variable as ",(0,r.kt)("inlineCode",{parentName:"p"},"mut"),". Second, notice that in ",(0,r.kt)("inlineCode",{parentName:"p"},"mutable_example")," we can't print the contents of ",(0,r.kt)("inlineCode",{parentName:"p"},"list")," in between when we create ",(0,r.kt)("inlineCode",{parentName:"p"},"borrows_mutably")," and when we call it, since ",(0,r.kt)("inlineCode",{parentName:"p"},"borrows_mutably")," has a mutable reference to ",(0,r.kt)("inlineCode",{parentName:"p"},"list")," and if we have a mutable reference, we can't have any other references at the same time."),(0,r.kt)("p",null,"A closure will automatically take ownership of a value if it needs to. We can force a closure to take ownership of all captured values with the ",(0,r.kt)("inlineCode",{parentName:"p"},"move")," keyword:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},'use std::thread;\n\nfn main() {\n    let list = vec![1, 2, 3];\n    println!("Before defining closure: {:?}", list);\n\n    thread::spawn(move || println!("From thread: {:?}", list))\n        .join()\n        .unwrap();\n}\n')),(0,r.kt)("p",null,"Here we're transferring ownership of ",(0,r.kt)("inlineCode",{parentName:"p"},"list")," to a new thread. We haven't covered threads yet, but we will in ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch16-fearless-concurrency",title:"Chapter 16: Fearless Concurrency"},"chapter 16"),". Transferring ownership is required here, because our ",(0,r.kt)("inlineCode",{parentName:"p"},"main")," function might finish before the thread, or the thread might finish first. If the thread borrowed a mutable reference, and ",(0,r.kt)("inlineCode",{parentName:"p"},"main")," finished first, the value would be dropped and the underlying memory would be freed, leaving the thread with a dangling reference."),(0,r.kt)("h3",{id:"moving-captured-values-out-of-closures-and-the-fn-traits"},"Moving Captured Values Out of Closures and the Fn Traits"),(0,r.kt)("p",null,"Depending on what a closure does with the values it captures, the compiler will automatically add some or all of these traits to the closure:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"FnOnce")," applies to all closures. It represents a closure that can be called once. All closures can be called at least once, so all closures implement this trait. If a closure moves captured values out of it's body, then it will ",(0,r.kt)("em",{parentName:"li"},"only")," implement this trait. Such a closure can not safely be called twice, since it won't be able to move the captured values a second time."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"FnMut")," applies to any closure that doesn't move captured values out of its body. Despite the name, the closure may or may not mutate captured values. These closures can safely be called multiple times."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Fn")," applies to any closure that implements ",(0,r.kt)("inlineCode",{parentName:"li"},"FnMut")," but that also doesn't mutate any captured values. Such a closure can safely be called multiple times concurrently.")),(0,r.kt)("p",null,"Let's take a look at the implementation of ",(0,r.kt)("inlineCode",{parentName:"p"},"Option<T>::unwrap_or_else"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"impl<T> Option<T> {\n    pub fn unwrap_or_else<F>(self, f: F) -> T\n    where\n        F: FnOnce() -> T\n    {\n        match self {\n            Some(x) => x,\n            None => f(),\n        }\n    }\n}\n")),(0,r.kt)("p",null,"Here ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," is the type of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Option<T>")," itself, and ",(0,r.kt)("inlineCode",{parentName:"p"},"F")," is the type of the parameter we pass to ",(0,r.kt)("inlineCode",{parentName:"p"},"unwrap_or_else"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"F")," has a trait bound for ",(0,r.kt)("inlineCode",{parentName:"p"},"FnOnce() -> T"),", which means F must be a closure that can be called at least once, takes no parameters, and must return a T. Since all closures implement ",(0,r.kt)("inlineCode",{parentName:"p"},"FnOnce"),", this lets ",(0,r.kt)("inlineCode",{parentName:"p"},"unwrap_or_else")," accept any closure."),(0,r.kt)("p",null,"A regular function can implement these traits as well! If what we are doing doesn't require capturing any values, we can use the name of a function in place of a closure when passing a closure to a function."),(0,r.kt)("p",null,"Let's have a look at another standard library function, ",(0,r.kt)("inlineCode",{parentName:"p"},"sort_by_key")," defined on slices:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="src/main.rs"',title:'"src/main.rs"'},'#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let mut list = [\n        Rectangle { width: 10, height: 1 },\n        Rectangle { width: 3, height: 5 },\n        Rectangle { width: 7, height: 12 },\n    ];\n\n    list.sort_by_key(|r| r.width);\n    println!("{:#?}", list);\n}\n')),(0,r.kt)("p",null,"This sorts the list in place, sorting by the ",(0,r.kt)("inlineCode",{parentName:"p"},"width")," of each rectangle. ",(0,r.kt)("inlineCode",{parentName:"p"},"sort_by_key")," takes a ",(0,r.kt)("inlineCode",{parentName:"p"},"FnMut")," instead of a ",(0,r.kt)("inlineCode",{parentName:"p"},"FnOnce"),". The closure we passed to ",(0,r.kt)("inlineCode",{parentName:"p"},"sort_by_key")," doesn't mutate any values, but it does need to be called more than once (at least once for each ",(0,r.kt)("inlineCode",{parentName:"p"},"Rectangle"),"), so it can't be ",(0,r.kt)("inlineCode",{parentName:"p"},"FnOnce"),"."),(0,r.kt)("p",null,"If we tried to do something like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let mut sort_operations = vec![];\nlet value = String::from("by key called");\n\n// This doesn\'t compile!\nlist.sort_by_key(|r| {\n    sort_operations.push(value);\n    r.width\n});\n')),(0,r.kt)("p",null,"this wouldn't work. The problem here is that the closure takes ownership of ",(0,r.kt)("inlineCode",{parentName:"p"},"value")," from the enclosing scope when it is created, then gives away ownership to ",(0,r.kt)("inlineCode",{parentName:"p"},"sort_operations")," when it calls ",(0,r.kt)("inlineCode",{parentName:"p"},"push"),". This means this closure only implements ",(0,r.kt)("inlineCode",{parentName:"p"},"FnOnce"),". It can't be called a second time, since it won't be able to transfer ownership of ",(0,r.kt)("inlineCode",{parentName:"p"},"value")," a second time. If we changed this closure to increment a counter in the enclosing scope instead of pushing a value onto a vector, this would fix the issue, as the closure could borrow the counter as a mutable reference, and would be ",(0,r.kt)("inlineCode",{parentName:"p"},"FnMut"),"."),(0,r.kt)("h2",{id:"132---processing-a-series-of-items-with-iterators"},"13.2 - Processing a Series of Items with Iterators"),(0,r.kt)("p",null,"In Rust, iterators are ",(0,r.kt)("em",{parentName:"p"},"lazy"),", meaning if you create an iterator and then don't call any functions on it, the iterator won't do any work:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let v1 = vec![1, 2, 3];\n\n// Create an iterator\nlet v1_iter = v1.iter();\n\n// Do something for each item the iterator returns.\n// The iterator doesn\'t do anything until we use it.\nfor val in v1_iter {\n    println!("Got: {}", val);\n}\n')),(0,r.kt)("h3",{id:"the-iterator-trait-and-the-next-method"},"The ",(0,r.kt)("inlineCode",{parentName:"h3"},"Iterator")," Trait and the ",(0,r.kt)("inlineCode",{parentName:"h3"},"next")," Method"),(0,r.kt)("p",null,"All iterators implement a trait from the standard library called, unsurprisingly, ",(0,r.kt)("inlineCode",{parentName:"p"},"Iterator"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub trait Iterator {\n    type Item;\n\n    fn next(&mut self) -> Option<Self::Item>;\n\n    // --snip--\n}\n")),(0,r.kt)("p",null,"This trait uses some syntax we haven't seen before: ",(0,r.kt)("inlineCode",{parentName:"p"},"type Item")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Self::Item"),". This is called an ",(0,r.kt)("em",{parentName:"p"},"associated type")," and it's a very much like a generic type. We'll talk more about this in ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch19/ch19-02-advanced-traits"},"chapter 19"),"."),(0,r.kt)("p",null,"The part we ",(0,r.kt)("inlineCode",{parentName:"p"},"--snip--"),"ed out only contains methods with default implementations, so if you want to implement ",(0,r.kt)("inlineCode",{parentName:"p"},"Iterator"),", you only need to implement ",(0,r.kt)("inlineCode",{parentName:"p"},"next"),". Every time ",(0,r.kt)("inlineCode",{parentName:"p"},"next")," is called, it returns ",(0,r.kt)("inlineCode",{parentName:"p"},"Some")," item until it runs out of items, and then it returns ",(0,r.kt)("inlineCode",{parentName:"p"},"None"),". For a vector, the items are returned in the same order they were present in the vector:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[test]\nfn iterator_demonstration() {\n    let v1 = vec![1, 2, 3];\n\n    let mut v1_iter = v1.iter();\n\n    assert_eq!(v1_iter.next(), Some(&1));\n    assert_eq!(v1_iter.next(), Some(&2));\n    assert_eq!(v1_iter.next(), Some(&3));\n    assert_eq!(v1_iter.next(), None);\n}\n")),(0,r.kt)("p",null,"Calling ",(0,r.kt)("inlineCode",{parentName:"p"},"next")," on an iterator changes it's internal state, which is why the ",(0,r.kt)("inlineCode",{parentName:"p"},"self")," parameter on ",(0,r.kt)("inlineCode",{parentName:"p"},"next")," is marked ",(0,r.kt)("inlineCode",{parentName:"p"},"&mut"),". This means we need to declare ",(0,r.kt)("inlineCode",{parentName:"p"},"v1_iter")," as ",(0,r.kt)("inlineCode",{parentName:"p"},"mut")," here as well. In the example above where we used a for loop, you might notice we didn't make ",(0,r.kt)("inlineCode",{parentName:"p"},"v1_iter")," mutable. This is because the ",(0,r.kt)("inlineCode",{parentName:"p"},"for")," loop ",(0,r.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/std/iter/index.html#for-loops-and-intoiterator"},"took ownership of the iterator")," and made it mutable - sneaky Rust."),(0,r.kt)("p",null,"Another thing to note is that the iterator returned by ",(0,r.kt)("inlineCode",{parentName:"p"},"iter")," returns immutable references to the underlying collection. There's an ",(0,r.kt)("inlineCode",{parentName:"p"},"iter_mut")," that returns mutable references, if we want to modify some or all of the members of a collection. There's also an ",(0,r.kt)("inlineCode",{parentName:"p"},"into_iter")," which takes ownership of the receiver (",(0,r.kt)("inlineCode",{parentName:"p"},"into")," because it converts the underlying collection into an iterator, and you won't be able to access the underlying collection anymore) and returns owned values. For example, if you called ",(0,r.kt)("inlineCode",{parentName:"p"},"v1.into_iter")," above, you'd get back an iterator of owned values, and wouldn't be able to use ",(0,r.kt)("inlineCode",{parentName:"p"},"v1")," anymore."),(0,r.kt)("h3",{id:"methods-that-consume-the-iterator"},"Methods that Consume the Iterator"),(0,r.kt)("p",null,"If you have a look at ",(0,r.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/std/iter/trait.Iterator.html#provided-methods"},"the documentation for ",(0,r.kt)("inlineCode",{parentName:"a"},"Iterator"))," you'll see that it provides quite a few methods with default implementations. Many of these call into ",(0,r.kt)("inlineCode",{parentName:"p"},"next"),", which is why you don't have to implement them all. Calling into ",(0,r.kt)("inlineCode",{parentName:"p"},"next")," though means that these will consume some or all of the items in the iterator. We call these ",(0,r.kt)("em",{parentName:"p"},"consuming adaptors"),"."),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.sum"},(0,r.kt)("inlineCode",{parentName:"a"},"sum")," method")," for example will consume all items in the iterator and sum them together. In order to ensure we can't use an iterator after calling ",(0,r.kt)("inlineCode",{parentName:"p"},"sum"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"sum")," takes ownership of the iterator."),(0,r.kt)("h3",{id:"methods-that-produce-other-iterators"},"Methods that Produce Other Iterators"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Iterator adaptors")," are methods on an iterator that don't consume the contents of the iterator, but they do take ownership of the iterator, converting it into some new kind of iterator. A common example of this is the ",(0,r.kt)("inlineCode",{parentName:"p"},"map")," method (which should be familiar if you're coming from JavaScript):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"let v1: Vec<i32> = vec![1, 2, 3];\n\nlet v2: Vec<_> = v1.iter().map(|x| x + 1).collect();\n")),(0,r.kt)("p",null,"Here ",(0,r.kt)("inlineCode",{parentName:"p"},"v2")," will be ",(0,r.kt)("inlineCode",{parentName:"p"},"vec![2, 3, 4]"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"map")," produces a new iterator of modified items from the underlying vector."),(0,r.kt)("p",null,"We call ",(0,r.kt)("inlineCode",{parentName:"p"},"collect")," here to transform the new iterator returned by ",(0,r.kt)("inlineCode",{parentName:"p"},"map")," into a vector. Note that ",(0,r.kt)("inlineCode",{parentName:"p"},"map"),", by itself, consumes no values! Until we call ",(0,r.kt)("inlineCode",{parentName:"p"},"collect"),' the closure won\'t be called. This "lazy" behavior is a bit different from ',(0,r.kt)("inlineCode",{parentName:"p"},"map")," in JavaScript."),(0,r.kt)("h3",{id:"using-closures-that-capture-their-environment"},"Using Closures that Capture Their Environment"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"filter"),' method (another familiar method for the JavaScript folks) is another iterator adaptor, which consumes the old iterator and returns a new one. It\'s parameter is a closure that returns a boolean, which is used to "filter out" some elements from the underlying iterator. The closure is called for each item, and if it returns true the new iterator will include the item, if false the item will be discarded:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(PartialEq, Debug)]\nstruct Shoe {\n    size: u32,\n    style: String,\n}\n\nfn shoes_in_size(shoes: Vec<Shoe>, shoe_size: u32) -> Vec<Shoe> {\n    shoes.into_iter().filter(|s| s.size == shoe_size).collect()\n}\n")),(0,r.kt)("p",null,"Notice here that the closure captures ",(0,r.kt)("inlineCode",{parentName:"p"},"shoe_size")," from the environment and uses it to decide whether a shoe should be included in the returned vector or not."),(0,r.kt)("h2",{id:"133---improving-our-io-project"},"13.3 - Improving our I/O Project"),(0,r.kt)("p",null,"With our new friend the iterator we can revisit our project from ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch12-io-project-cli",title:"Chapter 12: An I/O Project: Building a Command Line Program"},"chapter 12")," and make some of the code clearer and more concise."),(0,r.kt)("h3",{id:"removing-a-clone-using-an-iterator"},"Removing a ",(0,r.kt)("inlineCode",{parentName:"h3"},"clone")," Using an Iterator"),(0,r.kt)("p",null,"In chapter 12 we wrote this ",(0,r.kt)("inlineCode",{parentName:"p"},"Config")," struct:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'impl Config {\n    pub fn build(args: &[String]) -> Result<Config, &\'static str> {\n        if args.len() < 3 {\n            return Err("not enough arguments");\n        }\n\n        let query = args[1].clone(); // <= Ugly clone! It hurts us!\n        let file_path = args[2].clone();\n\n        let ignore_case = env::var("IGNORE_CASE").is_ok();\n\n        Ok(Config {\n            query,\n            file_path,\n            ignore_case,\n        })\n    }\n}\n')),(0,r.kt)("p",null,"and we promised that when we got to chapter 13, we'd talk more about that call to ",(0,r.kt)("inlineCode",{parentName:"p"},"clone"),". Our problem here was that the ",(0,r.kt)("inlineCode",{parentName:"p"},"args")," vector passed in here owns the strings we want to use, and we're only borrowing ",(0,r.kt)("inlineCode",{parentName:"p"},"args")," so we can't take ownership of them. But, if we go look at where ",(0,r.kt)("inlineCode",{parentName:"p"},"build")," is called:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let args: Vec<String> = env::args().collect();\n\nlet config = Config::build(&args).unwrap_or_else(|err| {\n    println!("Problem parsing arguments: {err}");\n    process::exit(1);\n});\n')),(0,r.kt)("p",null,"we're actually getting an iterator back from ",(0,r.kt)("inlineCode",{parentName:"p"},"env::args()")," and converting the iterator into a vector. Instead of doing this, we could pass the iterator directly to ",(0,r.kt)("inlineCode",{parentName:"p"},"build"),", then ",(0,r.kt)("inlineCode",{parentName:"p"},"build")," can consume the iterator and take ownership of the strings. In the caller we change the above to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let config = Config::build(env::args()).unwrap_or_else(|err| {\n    eprintln!("Problem parsing arguments: {err}");\n    process::exit(1);\n});\n')),(0,r.kt)("p",null,"And then in ",(0,r.kt)("inlineCode",{parentName:"p"},"build")," we can do:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'impl Config {\n    pub fn build(\n        mut args: impl Iterator<Item = String>,\n    ) -> Result<Config, &\'static str> {\n        args.next();\n\n        let query = match args.next() {\n            Some(arg) => arg,\n            None => return Err("Didn\'t get a query string"),\n        };\n\n        let file_path = match args.next() {\n            Some(arg) => arg,\n            None => return Err("Didn\'t get a file path"),\n        };\n\n        let ignore_case = env::var("IGNORE_CASE").is_ok();\n\n        Ok(Config {\n            query,\n            file_path,\n            ignore_case,\n        })\n    }\n}\n')),(0,r.kt)("p",null,"We've updated the function signature so ",(0,r.kt)("inlineCode",{parentName:"p"},"args")," is now a generic type with a trait bound allowing any iterator which returns Strings. Since we're taking ownership of ",(0,r.kt)("inlineCode",{parentName:"p"},"args")," and we'll be mutating it, we'll mark it as ",(0,r.kt)("inlineCode",{parentName:"p"},"mut"),". Then we read out parameters one by one. We start with a call to ",(0,r.kt)("inlineCode",{parentName:"p"},"args.next()")," to skip over the first parameter - the name of our executable - then we copy each subsequent value into a variable, taking ownership without having to clone anything."),(0,r.kt)("h3",{id:"making-code-clearer-with-iterator-adaptors"},"Making Code Clearer with Iterator Adaptors"),(0,r.kt)("p",null,"Recall our original implementation of ",(0,r.kt)("inlineCode",{parentName:"p"},"search"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {\n    let mut results = Vec::new();\n\n    for line in contents.lines() {\n        if line.contains(query) {\n            results.push(line);\n        }\n    }\n\n    results\n}\n")),(0,r.kt)("p",null,"We can now rewrite this in a more functional style, and eliminate our mutable ",(0,r.kt)("inlineCode",{parentName:"p"},"results")," vector:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {\n    contents\n        .lines()\n        .filter(|line| line.contains(query))\n        .collect()\n}\n")),(0,r.kt)("h3",{id:"choosing-between-loops-or-iterators"},"Choosing Between Loops or Iterators"),(0,r.kt)("p",null,'In general, the "functional" style with iterators is preferred by most Rust programmers. The code is more concise, and in most cases will be easier to read. In our ',(0,r.kt)("inlineCode",{parentName:"p"},"search")," example, a theoretical enhancement would be to do the filtering in parallel across multiple threads. This will be easier to do now that we no longer has to manage a mutable ",(0,r.kt)("inlineCode",{parentName:"p"},"results")," vector."),(0,r.kt)("h2",{id:"134-comparing-performance-loops-vs-iterators"},"13.4 Comparing Performance: Loops vs. Iterators"),(0,r.kt)("p",null,'How well do iterators perform? The original "The Rust Programming Language" had this to say:'),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"We ran a benchmark by loading the entire contents of The Adventures of Sherlock Holmes by Sir Arthur Conan Doyle into a ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),' and looking for the word "the" in the contents. Here are the results of the benchmark on the version of ',(0,r.kt)("inlineCode",{parentName:"p"},"search")," using the ",(0,r.kt)("inlineCode",{parentName:"p"},"for")," loop and the version using iterators:"),(0,r.kt)("pre",{parentName:"blockquote"},(0,r.kt)("code",{parentName:"pre",className:"language-txt"},"test bench_search_for ... bench: 19,620,300 ns/iter (+/- 915,700)\ntest bench_search_iter ... bench: 19,234,900 ns/iter (+/- 657,200)\n"))),(0,r.kt)("p",null,'We can see that for our implementation, the iterator implementation was ever so slightly faster. Understand the point here is not to say "iterators are faster" or "for loops are faster", the point is that in most situations, they\'re going to be pretty close. Rust calls iterators a ',(0,r.kt)("em",{parentName:"p"},"zero cost abstraction"),' meaning that they don\'t add any extra overhead over "hand coding" a solution. If you try to use an iterator over a short fixed size array, in many cases Rust will "unroll the loop" and if you examine the underlying assembly, you\'ll find no loop at all, no bounds checks, and all your values stored in registers, exactly as if you\'d hand coded it.'),(0,r.kt)("p",null,"If you really need to eek out every last bit of performance, you'll want to write some ",(0,r.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/unstable-book/library-features/test.html"},"benchmark tests")," that exercise your code with a variety of different inputs."),(0,r.kt)("p",null,"Continue to ",(0,r.kt)("a",{parentName:"p",href:"/rust-book-abridged/ch14-more-about-cargo",title:"Chapter 14: More About Cargo and Crates.io"},"chapter 14"),"."))}h.isMDXComponent=!0}}]);